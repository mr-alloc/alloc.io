[{"_path":"/docs/electric/about_electron","_header":{"layout":"tweet","title":"전기에너지를 만드는 전자","categories":["Development","Electric"],"tags":["원자","전자","원자핵","렙톤"],"date":1694348520000,"profile_image":"/assets/blogging/profile/winkkom.png","current_company":"NEOWIZ","current_position":"Software Engineer","summary":"전자란?","excerpt_separator":"<!--more-->","hide":false,"breadcrumbs":["electric","전자란?"]},"_description":"# 전기에너지를 만드는 전자\n\n전자는 대부분의 원자에 모두 존재한다.\n원자가 전기적으로 중성이려면, 음전하를 띄고 있는 전자와, 양전하를 띄고있는 양성자의 개수가 동일해야 한다.\n따라서, 자연에 존재하는 모든 원소는 전자를 갖고있다고 봐도 된다.\n\n전자는 양전하에서 음전하로 이동하게 되는데, 이를 이용해 전기 에너지를 흐르게 할 수 있다.\n`(+)양전하` 에서 `(-)음전하`의 방향으로 전자가 이동하게 되면, 그 반대방향으로 전기장이 만들어진다.\n전기에너지는 그 전기장을 통에 전달이 된다.  \n\n","_content":"\n"},{"_path":"/docs/electric/about_atom","_header":{"layout":"tweet","title":"만물을 이루는 원자","categories":["Development","Electric"],"tags":["원자","전자","원자핵","양성자","중성자","반도체"],"date":1693486620000,"profile_image":"/assets/blogging/profile/winkkom.png","current_company":"NEOWIZ","current_position":"Software Engineer","summary":"원자란?","excerpt_separator":"<!--more-->","hide":false,"breadcrumbs":["electric","원자란?"]},"_description":"# 만물을 이루는 원자\n\n원자는 모든 물질을 이루는 가장 기본적인 입자이다. \n원자핵과 그 주변을 이동하는 전자로 구성되어있다. \n원자핵을 구성하는 핵자는 양성자와 중성자가 있으며, 화학적 또는 물리적 방법으로 분해할 수 없다.\n\n일반적으로 원자핵을 양전하를 띄고, 전자는 음전하를 띈다. \n원자핵에서 양성자가 양전하를 띄게 되는데,  해당 양전하의 개수와 전자의 개수가 같을 때 가장 안정적으로 전기적인 중성 상태가 된다. \n즉, 전하를 띄지 않는다. 양성자는 바꿀 수 없지만, 전자는 다른 원자로 이동시킬 수 있기 때문에 양전하와 음전하의 개수가 달라지게 된다.\n\n이때, 양전하의 개수보다 음전하(전자)의 개수가 많으면 음이온, 적으면 양이온이라고 칭하기도 한다. \n전자는 원자핵 주변을 돌게 되는데 이때 이동 속도는 약 30만 km (진공 상태의 빛의 속도)이다. \n전자가 이동하는 궤도는 양자 역학으로 인해 일정하지 않다고 한다. \n전자의 수(또는 양성자의 수)에 따라 원자번호가 결정되기 때문에 우리가 과학적으로 정의하는 원소가 고유성을 가질 수 있는 이유이기도 하다. \n양성자를 비롯한 핵자의 수가 바뀌는건 핵융합과 핵분열이 대표적이다.\n\n전자는 원자핵 주위를 돌며 , 원자의 가장 안쪽 핵자의 주변부터 원자의 밖의 방향으로 껍질처럼 배치된 위치에서 운동한다. \n또한 최대로 배치될 수 있는 이 개수는 (양성자의 개수와 같아야 하기 때문에) 정해져 있다.  \n전자는 외부로부터 에너지를 가하면, 가장자리부터 떨어져 나가며, 모든 전자가 떨어져 나가, 원자핵만 남은 경우 플라즈마라고 한다.\n","_content":"\n"},{"_path":"/docs/tools/intellij_config","_header":{"layout":"post","title":"Intellij 단축키 와 설정","categories":["Development","Tools"],"tags":["Intellij","Shortcut","인텔리제이","단축키","기본설정"],"date":1693219320000,"profile_image":"/assets/blogging/profile/winkkom.png","current_company":"NEOWIZ","current_position":"Software Engineer","thumbnail":"/assets/blogging/tool/intellij_shortcut.png","summary":"단축키와 기본설정","excerpt_separator":"<!--more-->","hide":false,"breadcrumbs":["도구","단축키와 기본설정"]},"_description":"Intellij에서 유용한 단축키 정리\n","_content":"\n\n## 기본 단축키\n| 단축키 <span class=\"key key-mac\">`MAC`</span> <span class=\"key key-win\">`Win`</span>     | 설명 |\n|:-----------|:--|\n| <span class=\"key-mac\">`⌥` `⌘` `X`</span><br/><span class=\"key-win\">`Ctrl` `Alt` `X`</span>   | 리턴타입이 있는 메소드 호출위에 커서를 두고 실행 |\n| <span class=\"key-mac\">`⌃` `⇧` `숫자`</span><br/><span class=\"key-win\">`Ctrl` `Shift` `숫자`</span> | 북마크된 라인으로 이동은 <span class=\"key-mac\">`⌃`</span> or <span class=\"key-win\">`Ctrl`</span>) + `숫자` |\n| <span class=\"key-mac\">`⌥` `⌘` `V`</span><br/><span class=\"key-win\">`Ctrl` `Alt` `V`</span> | 리턴타입 자동 완성 |\n| <span class=\"key-mac\">`⌥` `⌥` 누른 상태로 `↓` or `↑` </span><br/><span class=\"key-win\">`Shift` `Shift` 누른 상태로 `↓` or `↑`</span> | 멀티라인 선택 |\n| <span class=\"key-mac\">`⌥` `⌘` `←` or `→` </span><br/><span class=\"key-win\">`Shift` `Shift` `←` or `→`</span> | 커서 스택내 이동 |\n\n##  Live Template\nSetting > Live Template 검색  \ncustom 으로 등록  \n![Live Template 설정](/assets/blogging/intellij/intellij1.png)\n"},{"_path":"/docs/typescript/typescript_getting_start","_header":{"layout":"post","title":"타입스크립트 시작하기 1 (소개)","categories":["Development","Typescript"],"tags":["Typescript","Javascript","Type"],"date":1681552860000,"current_company":"NEOWIZ","current_position":"Software Engineer","profile_image":"/assets/blogging/profile/profile1.JPG","thumbnail":"/assets/blogging/typescript/typescript_getting_start.png","summary":"타입스크립트 소개","excerpt_separator":"<!--more-->","hide":true,"breadcrumbs":["타입스크립트","타입스크립트 소개"]},"_description":"타입스크립트 시작하기.\n도대체 왜 사용하는거고, 뭐가 좋은걸까?\n","_content":"\n\n## 우리가 아는 자바스크립트\n\n사실 나도 타입스크립트를 처음 배우는 거고, 잘 알지 못한다. 하지만, 자바스크립트와 같이 **동적타입**의 언어는 결국 많은 문제를 유발 시킬수 있는걸 알고 있다.\n일반 자바스크립트에는 타입이 없기 때문에 코드대로 그냥 변수로 받아야한다. 따라서 아래와 같은 일반 자바스크립트에서는 해괴한 연산도 가능하다.\n\n```javascript{3,7}\n//일반 자바스크립트 함수의 선언\nfunction getNow() {\n    return new Date()\n}\n\nvar now = getNow();\nvar plus1Day = now + '1Day';\nconsole.log('plusDay:', plus1Day) \n//출력결과 -> plusDay: Sat Apr 15 2023 19:12:32 GMT+0900 (한국 표준시)1Day\n```\n\n3번라인에서 보면 `getNow()` 함수는 `Date` 타입의 현재시간 값을 리턴한다. 근데, 7번라인에서 다시보면 `Date` 타입과 `string` 연산을 한다.\n하지만, 어떠한 에러도 발생되지 않는다. 결과적으로 연산된 `plus1Day` 변수의 타입은 `string`이다.\n`Date` 함수와 `string`의 덧셈에 결과타입이 `string`인 내용은, 타입스크립트를 알아보는 과정에서 별로 중요하지 않기에 넘어간다.\n\n이 처럼 타입이 존재는 하지만, 변수가 타입에 연연하지않은 언어를 `동적타입 언어`라고 한다. \n우리가 일반적으로 알고있는 객체지향 언어는 모두 정적타입 언어 이다. 각 변수의 타입이 정해져있고, 정해진대로 연산을 하기 때문이다.\n게다가 `javascript`는 ECMA Script(ES)라는 표준 스크립트 버전이 있는데, 현재 우리가 사용중인 브라우저는 ES5 버전만 해석할 수 있다.\n\n`ES5`버전은 2009년에 공개된 버전이며, 현재까지 브라우저는 해당 버전이상의 자바스크립트는 해석할 수 없다.\n이 이상의 버전을 사용하려면, Babel(Javascript Compiler)같은 특정도구를 이용해 브라우저가 해석할 수 있는 자바스크립트의 버전으로 컴파일 해줘야 한다.\n이 외에도 `ES5`이상에서 지원되는 javascript 버전에는 여러가지 기능 및 문법들을 사용할수 있었다.\n\n```javascript\n//ES6 문법 const\nconst sum = (a, b) => {\n    return a + b\n}\n```\n위의 설명대로 브라우저는 `const`를 알 수 없다. 하지만 브라우저 내부에있는 js 엔진이 해석할 수 있기에 우리는 `ES`버전은 딱히 몰라도 상관없다.\n타입스크립트를 배우기위해선, 위의 내용들을 알고있어야한다. `ES5`의 문법은 당연히 `ESNext(6, 7..)`에서 포함하고 있고, 이또한 `Typescript`에서 포함하고있다.\n`타입스크립트`또한, `ESNext`와 동일하게 ES5로 `Transpile`을 해줘야 하는건 예외 없다. \n\n그럼 우리가 아는 자바스크립트를 그냥 사용해도 되는데, 왜 굳이 타입스크립트를 사용하는 걸까?\n\n## 타입스크립트는 무엇인가?\n\n간단하게 설명하면, 동적타입의 언어와 같이 모든 객체는 타입을 가지며, `Null-Sefe`한 연산을 할 수 있는 등 여러 장점이 있다.\n예를 들어 다음과 같은 `Javascript` 코드에서 문제가 발생 했을 때, 쉽게 문제를 알수 없다.\n\n```javascript\nfunction makePerson(name, age) {\n    return {\n        name: name,\n        age: age\n    }\n}\n\nconst person = makePerson(30, 'Kim')\n```\n\n하지만, 위와 같은 코드에 각 변수에대한 타입이 생긴다면, 작성할 때부터 문제를 알 수 있다.\n만약 위에 코드에서 타입이 추가된다면 어떻게 달라질까?\n\n```typescript\nclass Person {\n    name: string\n    age: number\n\n    constructor(name: string, _age_: number) {\n        this.name = name\n        this.age = age\n    }\n}\n\nfunction makePerson(name: string, age: number): Person {\n    return new Person(name, age)\n}\n\nconst person: Person = makePerson('Kim', 4)\n```\n\n좀 더 많은 코드가 작성되었다. 하지만, 각 변수는 타입을 가지며, 좀 더 견고한 어플리케이션을 만들수 있는 타입이 생겼다.\n클래스 생성을 통해, 의도한 값을 가지는 타입의 객체가 생성되었다. 이는 정말 중요한 내용이다.\n기존에 자바스크립트에서 할 수 없었던, 그리고 걱정하지 않아도 되었던, 코드를 작성할 수 있게된다.\n\n## 타입스크립트를 배우기전 ES5 또는 ESNext의 주요 문법을 알아보자\n\n앞서 말한것처럼 `Typescript`는 `ESNext`, `ES5`모두 포괄하고 있는 상위 집합이기에, 두가지 문법을 모두 사용할 수 있다.\n타입스크립몇가지 간단한 문법을 \n\n### 비구조화 할당\n\n`비구조화 할당(destructuring assignment)`는 객체와 배열에 적용할 수 있으며, 말그대로 구조화 하지않은 채 값을 특정 변수로 할당 하는 것 이다.\n이는 `ESNext`에서 제공되며,\n```javascript{6}\nlet person = {\n    first_name: 'John',\n    age: 30\n}\n\nlet { first_name, age } = person\n\nconsole.log(typeof age) // \"number\"\nconsole.log(age)        // 30\nconsole.log(first_name) // \"John\"\n```\n\nperson을 이용하여, 비구조화 할당을 통해 `first_name` field와 `age`필드를 할당 할 수 있다.\n그럼 이 할당을 통해, `let { first_name, age }`의 값 중 `first_name`의 값을 바꾸면 어떻게 될까?\n\n```javascript\nlet person = {\n    first_name: 'John',\n    age: 30\n}\n\nlet { first_name, age } = person\n\nfirst_name = 'Micheal'\nconsole.log('person:', person)\n/*\n    person: {\n        \"first_name\": \"John\",\n        \"age\": 30\n    }\n */\nperson.first_name = 'Smith'\nconsole.log('first_name:', first_name)\n/*\n    first_name: Micheal\n */\n```\n\n첫번째로 할당된 `first_name`의 값을 변경했지만, 변경 되지 않았다.\n또한, 반대로 `person.first_name`의 값을 변경 했지만, 역시나 `first_name`의 값이 변경 되지 않았다.\n여기서 `비구조화 할당`은 얕은복사를 하는걸 알 수 있다.\n배열의 비구조화 할 당은 어떻게 사용할 수 있을까?\n\n```javascript{2}\nlet array = [1, 7, 54, 66, 90]\nlet [first, ...mod] = array\n\nconsole.log(array) // [1, 7, 54, 66, 90]\nconsole.log(first) // 1\nconsole.log(mod)   // [7, 54, 66, 90]\n```\n\n>2번 라인의 `...mod`는 `스프레드 연산자`이며, 내부 요소를 한번에 가져온다.\n> 스프레드 연산자는 인자의 마지막에만 사용할 수 있다.\n\n`first`와 `mod`로 나누어 할당 했고 출력 결과는 위 처럼 배열의 순서에 맞는 값들로 나뉘어졌다.\n`객체`또는 `배열`의 구조를 분해해서 할당하기 때문에 `구조분해 할당`(`또는 \"비구조화 할당\"`)이라고 칭한다.\n\n\n### 화살표 함수 (arrow function)\n\n```javascript\n// 일반 함수형\nfunction toUpperCase(str) {\n    return str.toUpperCase()\n}\n\n// 화살표 함수형\nconst toUpperCase = () => str.toUpperCase()\n```\n\n자바스크립트에서는 함수또한 객체로 취급되며, 위와 같은 표현식으로 선언할 수 있다.\n이 화살표 함수(`arrow function`)은 내부로직이 한줄로 표현이 된다면, `{}`괄호와 `return`을 생략할 수있다.\n중요한 부분은 `=`다음으로 오는 `() => {}`구문이다. `()`에는 일반함수처럼 매개변수를 받을 수 있고, `{}` 내부 또한 함수와 동일하게 작성할 수 있다.\n*주의할 점*은 `화살표 함수` 내에서 `this` 키워드는 함수 `자신`을 의미한다는 점을 알고 있어야 한다. \n이는 `javascript`객체와 관련된 부분인데, `javascript`에서 `this`는 객체의 참조를 의미한다. \n`class` 또는 모듈에서 사용한다면, 현재 속해있는 객체(`브라우저`일반적으로 `window: DOM tree`로 바인딩) 에대해 바인딩 하기때문에, \n객체 자체인 `arrow`함수는 `this`에 대해 자기 자신이 바인드 되는 것이다.\n\n### 클래스 (class)\n\n일반적으로 객체지향 언어에서 지원 하는 `class`의 개념은 어떤 객체에 대해 정적인 관점에서 서술 할 때 사용 된다.\n아래의 예제를 통해 `알람시계`가 갖고있는 정적인 관점의 상태와 책임에 대해 좀더 객체지향적으로 이해하기 위해 `typescript`를 통해 알아보자.\n\n```typescript\n\nclass Speaker {\n    ringing() {\n        //저장된 음악으로, 스피커 동작 로직    \n    }\n}\n\ninterface Alarm {\n    alert(message: string): never\n}\n\nclass Clock implements Alarm {\n\n    private readonly _speaker: Speaker\n\n    constructor(speaker: Speaker) {\n        this._speaker = speaker\n    }\n    \n    setTimeOfRinging(milis: number, message: string): never {\n        setTimeout(() => {\n            this._speaker.ringing()\n            alert()\n        }, milis)\n    }\n    \n    alert(message: string): never {\n        console.log(message)\n    }\n}\n\nconst clock: Clock = new Clock(new Speaker())\nclock.setTimeOfRinging(1000, '1초가 지났습니다.')\n```\n\n기존에 `javascript`에서는 할 수 없던, 객체의 상속, 추상화가 가능 하므로서, 간단한 알람시계 클래스지만,각 객체들의 `책임`을 부여하므로써,\n좀 더 견고한 `어플리케이션`을 만들 수 있다.\n"},{"_path":"/docs/algorithm/heap_sort","_header":{"layout":"post","title":"-Algorithm- Heap sort (힙 정렬) feat.java","categories":["Development","Algorithm"],"tags":["Java","Algorithm","Sort","Heap Sort","Heap"],"date":1651837980000,"profile_image":"/assets/blogging/profile/profile4.jpeg","thumbnail":"/assets/blogging/algorithm/heap/heap_sort_intro.png","current_company":"Herit Corporation","current_position":"Backend Server Developer","summary":"힙과 힙정렬","excerpt_separator":"<!--more-->","hide":false,"breadcrumbs":["알고리즘","힙과 힙정렬"]},"_description":"열라 간단한 우선순위 큐의 자료구조인 Heap에 대해 공부합니다.\n힙의 속성?! 힙이 최소 또는 최대값을 유지하는 방법?!\n\n힙을통해 정렬하는 방법까지 공부합니다. 😁\n","_content":"\n\n\n# 힙 정렬 (Heap Sort)\n\n## 배울수 있는 내용\n\n* Heap의 속성\n* Heap을 만드는 방법\n* Heap이 우선 값을 유지하는 방법\n* Heap을 이용해 정렬을 하는 방법\n\n🌸 힙(Heap)은 요소의 우선순위를 이용하여 정렬된 상태를 유지할 수 있는 매우 편한 자료구조입니다.\n먼저, 힙 정렬을 알기전에 힙이 어떤 속성을 갖고 있는지 알아보아요.\n\n---\n\n## 설명\n\n간단하게 말하여, 힙은 우선순위 큐 입니다. `JAVA`에서는 `PriorityQueue`라는 구현체를 통해 Heap 자료구조를 사용할 수 있어요.\n힙은 두 종류가 있는데 `최대 힙`과 `최소 힙`이 있어요. \n최대 Heap(최소 Heap)은 단어와 같이 최대 값(최소 값)을 우선순위로 판단하여, 어떠한 값이 들어와도, 항상 같은 순서의\n트리를 유지하며, 언제든지 최고 우선순위의 값을 적은 비용으로 쉽게 얻을수 있는 자료구조 입니다.\n\n### Heap의 속성 (특징)\n\n* 최대 힙(**또는 최소 힙**)은 `잎(leaf)`의 계층을 제외한 모든 노드는 자식의 노드 보다 큰(**또는 작은**) 값을 가지고 있어야합니다.\n* 왼쪽부터 차례대로 채워져있는 `완전 이진 트리(Complete binary tree)`이어야 합니다.\n* 같은 계층의 노드들과는 정렬하지 않습니다.\n* 루트(뿌리)노드로 부터 내려오는 위치의 노드들 오름차순(**또는 내림차순**)입니다\n\n![어떤것이 힙일까요?](/assets/blogging/algorithm/heap/tree_images.svg)\n\n트리 A: 잎을 제외한 노드는 모두 정렬되었지만, 왼쪽부터 채워지지않아 Heap이 아닙니다.\n트리 B: 왼쪽부터 채워졌지만, 2번노드의 값은 그 자식에값보다 작습니다. 따라서 Heap이 아닙니다.\n트리 C: 잎을 제외한 모든 노드가 자식 또는 부모와 정렬 되어있고, 왼쪽부터 채워져있으므로 `Heap`입니다.\n\n이를 정리하면 아래와 같습니다.\n\n> 1. 𝑛개의 노드를 가진 힙은 정확히 하나만 있고 그 힙(트리)의 높이(height)는 ⎣log₂𝑛⎦이다\n> * 트리의 전체 노드의 개수가 8일경우 트리(힙)의 높이는 3이다. 즉 힢의 높이는 힙의 성질(속성)에 부합되는 노드들만 인정이 된다는 의미이다.\n\n> 2. 힙의 루트 노드는 항상 최댓값(**또는 최솟값**)을 저장한다.\n> * 최대 힙(**또는 최소 힙**)은 쵀댓값(**또는 최솟값**)을 효율적으로 관리하기 위한 자료구조이며, 루트에는 항상 가장 큰(**또는 작은**)값을 유지한다.\n\n> 3. 힙의 한 노드와 그 노드의 자손 노드들로 이루어진 부분 트리(subtree)도 힙이다.\n> * 힙은 힙으로 이루어져있으며 자식노드도 힙이 될수있지만, 노드의 자식이없다면 힙이될 수없다. 따라서 위 C 트리의 4, 5, 6번 노드는 힙이 아니다.\n\n\n### Heap을 만드는 방법\n\n힙을 구성 하기 위해서는 다음의 순서대로 진행됩니다.\n\n1. 순회를 시작할 힙이되는 마지막 노드`⎣𝑛/₂⎦`를 찾는다.\n2. 마지막 노드 i를 이용해 자식노드가 있는지, 또한 있다면 그 중 자신 보다 큰값을 자신과 찾는다.\n3. 찾은 값과 자신을 바꾸고 바꾼 자신의 위치는 그값의 자식이 되며, 자신보다 큰값이 나오지 않을때까지 반복한다.\n4. 다음 노드(i -1)에서 다시 `3.`을 반복한다.\n\n- 자식 노드의 위치를 찾을때는 왼쪽`arr[2i]`값과 오른쪽`arr[2i + 1]`로 구할 수 있습니다.\n\n위 의 내용을 정리하면 아래와 같습니다.\n\n\n![힙 만들기 1단계](/assets/blogging/algorithm/heap/first_iteration.svg)\n\n> 위의 트리는 *완전 이진트리* 입니다. 힙은 완전이진트리에서 만들수 있으므로, 일반 이진트리는 Compact하게 완전이진트리로 바꿔야\n> 힙을 만들수 있습니다.\n> \n> 왼쪽 트리의 마지막 힙의 값은 15 이며, 이는 자식(6, 4) 어느것 보다도 큰값입니다. 따라서 다음 순회로 넘어갑니다.\n> 순회는 내부 노드의 마지막 힙의 위치에서 부터 1까지 이어집니다. 따라서 다음 인덱스인 3번 노드(9)로 넘어갑니다.\n> 3번노드는 자신의 자식들 중 6번째, 7번째 (7, 12)와 비교하여 더 큰값을 가지는 12와 바꿉니다.\n\n![힙 만들기 중간 단계](/assets/blogging/algorithm/heap/other_iteration.svg)\n\n> 이후 과정은 위와 같이 반복됩니다. 내부노드를 순회하며 자신의 자식노드가 있는지 확인하고 있다면, 자신과 비교하여 더큰 값으로\n> 바꿉니다. 이는 바꾼이후에도 `3.`이 반복되게 됩니다.\n> \n> 순회되는 노드가 최상위노드가 되고 모든 내부노드가 힙이 될때, 전체 트리는 힙이 됩니다. \n> 마지막까지 바꾼 최종트리는 아래와 같습니다. \n\n\n![힙 만들기 마지막 단계](/assets/blogging/algorithm/heap/last_iteration.svg)\n\n* 최상위 노드(루트)가 가장 큰값이 되며, 위는 최대힙을 만드는 단계였습니다.\n* 부모노드와 자식노드끼리는 순서의 값을 가지며, 항상 최대의 값을 가집니다.  \n\n### Heap이 우선 값을 유지하는 방법\n\n위에서는 완전이진트리로 힙을 어떻게 만드는지에 대해 알아봤습니다.\n하지만, 힙은 언제나 새로운값이 들어와도 항상 우선 순위로 값을 관리합니다. 만약 저기서 더큰값이 추가된다면,\n저 힙트리는 어떻게 바뀔까요? 새로운 값들을 추가해서 힙이 다시 어떻게 유지되는지 배워봅니다.\n\n#### 값추가\n\n힙트리에서 값을 추가 할때는 마지막 노드로 붙여주고 위에서 했던것과 동일하게 힙을 만들어 줍니다.\n만약 새로운 값 17이 힙에 들어온다면 순서는 아래와 같이 바뀝니다.\n\n![힙 유지하기 1단계](/assets/blogging/algorithm/heap/add_new_17.svg)\n![힙 유지하기 2단계](/assets/blogging/algorithm/heap/add_new_17_2.svg)\n\n\n> A: 새로 들어온 값 17은 트리의 맨뒤인 10번노드로 들어갑니다.   \n> 또한 마지막 내부노드이자 자신의 부모인 5번 노드(4)부터 다시 순회를 시작하며, \n> 자신보다 큰 값은 가진 자식 10번 노드(17)과 값을 바꿉니다.\n> \n> B: 값이 바뀐 10번 노드(4)는 자식을 가지고있지 않으므로 다음 순회로 넘어갑니다.\n> \n> C: 다음 순회인 4번 노드(6)은 자식들보다 큰값이므로 다음 3번 노드(12)로 이동합니다. 하지만 이또한 자식들보다 값이 크므로,\n> 2번 노드(8)로 이동합니다. 자신보다 큰값을 가지는 5번 자식노드(17)과 바꿉니다.\n> \n> D: 값이 바뀐 5번 노드(8)은 자식들 보다 값이 커, 바꿀 필요가 없으므로 다음 순회인 1번 노드(15)로 이동합니다.\n> \n> E: 현재 순회인 1번 노드(15)는 자신의 2번 노드(17)보다 값이 작으므로 바꿉니다.\n> \n> F: 최종적으로 힙이 완성되었습니다. \n\n\n\n### Heap을 이용해 정렬을 하는 방법\n\n힙 정렬을 위해서는 사전에 완전 이진 트리를 힙으로 만들고, 정렬을 수행할 수 있습니다.\n위에서 만든 힙을 통해 정렬을 하는 방법을 구현합니다.  \n힙 정렬은 간단하게, 아래의 정렬하는 순서를 가지고있습니다.\n\n1. 최상위 노드 `A`와 가장 끝의 노드 `B`를 바꾼다.\n2. 바꿔진 A는 맨뒤로 가며,힙에서 제외한다. \n3. 바꾼 값 `B`는, 자신의 자식이 있다면, 두개를 비교하여 가장 큰 값과 맞 바꾼다.\n4. `3.`의 내용을 힙이될때까지 반복한다.\n\n위의 순서를 반복하며, 만든 힙 정렬은 아래와 같습니다.\n\n![힙 정렬 1](/assets/blogging/algorithm/heap/heap_sort_1_1.svg)\n![힙 정렬 2](/assets/blogging/algorithm/heap/heap_sort_1_2.svg)\n![힙 정렬 3](/assets/blogging/algorithm/heap/heap_sort_1_3.svg)\n![힙 정렬 4](/assets/blogging/algorithm/heap/heap_sort_1_4.svg)\n![힙 정렬 5](/assets/blogging/algorithm/heap/heap_sort_1_5.svg)\n![힙 정렬 6](/assets/blogging/algorithm/heap/heap_sort_1_6.svg)\n![힙 정렬 7](/assets/blogging/algorithm/heap/heap_sort_1_7.svg)\n![힙 정렬 8](/assets/blogging/algorithm/heap/heap_sort_1_8.svg)\n\n## 구현 코드 (Java)\n\n```java\nimport java.util.Arrays;\n\npublic class Heap {\n    \n    //== 힙(Heap) 을 만드는 메소드 ==//\n    public static void makeHeap(int arr[]) {\n        // last heap\n        int lh = arr.length / 2;\n        System.out.println(\"Normal Array = \" + Arrays.toString(arr));\n        int eh = arr.length;\n        while (lh-- > 0) {\n\n            System.out.println(\"i: \" + lh);\n            pushDown(arr, lh, eh);\n        }\n\n        System.out.println(\"Array as Max Heap = \" + Arrays.toString(arr));\n    }\n    \n    \n    //== 노드와 그 자식중에서 더큰(또는 작은) 위치를 찾는 메소드 ==//\n    public static int findLargest(int arr[], int node, int eh) {\n        // first child\n        int fc = (2 * (node + 1)) - 1;\n\n        if (fc + 1 < eh) {\n            if (arr[fc] <= arr[fc + 1]) {\n                return arr[fc + 1] <= arr[node] ? node : fc + 1;\n            } else {\n                return arr[fc] <= arr[node] ? node : fc;\n            }\n        }\n        if (fc < eh && arr[node] < arr[fc]) {\n            return fc;\n        } else {\n            return node;\n        }\n    }\n    //== 값을 아래로 내리는 메소드 ==//\n\n    /**\n     * 간단하게 보면 트리에서 마지막 힙의 위치를 구하고,\n     * 루트 노드까지 역순으로 힙을 만들어갑니다.\n     * \n     * 최대 힙(또는 최소 힙)의 조건에 따라 더큰(또는 더 작은)값을 기준으로,\n     * 해당 노드를 위로올리고 변경된 대상은 아래로 내려가며 계속 바꿉니다.\n     */\n    public static void pushDown(int arr[], int node, int eh) {\n        do {\n            System.out.println(\"j: \" + node);\n            int temp = arr[node];\n            int large = findLargest(arr, node, eh);\n            System.out.println(drawBinaryTree(arr));\n\n            if (large == node)\n                break;\n\n            arr[node] = arr[large];\n            arr[large] = temp;\n\n            node = large;\n        } while (node <= eh);\n    }\n\n    public static void sort(int arr[]) {\n        int last = arr.length;\n        makeHeap(arr);\n\n        while (--last >= 0) {\n\n            int temp = arr[0];\n            arr[0] = arr[last];\n            arr[last] = temp;\n\n            System.out.println(\"last: \" + last);\n            pushDown(arr, 0, last);\n        }\n        ;\n    }\n\n    //== 출력 메소드 ==//\n    public static String drawBinaryTree(int arr[]) {\n        StringBuilder builder = new StringBuilder();\n\n        int nol = (int) (Math.log(arr.length) / Math.log(2)) + 1;\n        int max = (int) Math.pow(2, nol - 1);\n\n        int printed = 0;\n        for (int i = 0; i < nol; i++) {\n            int perFloor = (int) Math.pow(2, i);\n            int tab = (max - perFloor) / 2 + (max - perFloor) % 2;\n            int last = printed + perFloor;\n\n            for (int j = 0; j < tab; j++) {\n                builder.append(\"  \");\n            }\n            for (int j = printed; (j < arr.length && j < last); j++) {\n                builder.append(String.format(\"(%d)\", arr[j]));\n            }\n            builder.append(\"\\n\");\n            printed += perFloor;\n        }\n\n        return builder.toString();\n    }\n    \n    public static void main(String args []) throws Exception {\n        //== 힙 으로 만들기==//\n        int arrForMake [] = {1, 5, 8, 2, 74, 9, 12, 104, 87, 43};\n        Heap.makeHeap();\n        \n        //== 힙 + 정렬 ==//\n        int arrForSort [] = {1, 8, 9, 15, 4, 7, 12, 6, 4, 17};\n        Heap.sort(arr);\n        \n    }\n}\n```\n\n\n\n"},{"_path":"/docs/algorithm/insertion_sort","_header":{"layout":"post","title":"삽입 정렬 알아보기(Java)","categories":["Development","Algorithm"],"tags":["Java","Algorithm","Sort","Insertion Sort"],"date":1650551100000,"thumbnail":"/assets/blogging/algorithm/insertion_sort_intro.png","current_company":"Herit Corporation","current_position":"Backend Server Developer","summary":"삽입 정렬 알아보기","excerpt_separator":"<!--more-->","hide":false,"breadcrumbs":["알고리즘","삽입 정렬 알아보기"]},"_description":"이번 포스팅 순서는, \n기본 정렬 알고리즘중 하나인 삽입 정렬(Insertion Sort)입니다.\n\n이전 포스팅의 선택정렬하고는 또 다른 맛이있네용 ㅋㅋ\n\n지적 및 조언 댓글 환영입니다. ㅎㅎ\n","_content":"\n\n\n## 삽입정렬 (Insertion Sort)\n\n\n🌸 삽입정렬은 배열을 순회하며, 삽입할 위치를 찾고 요소들을 **한단계씩 밀어** 해당 위치에 삽입하며 정렬하는 알고리즘 입니다.\n삽입정렬 또한 선택정렬과 마찬가지로 정렬된 부분과 정렬되지 않은 부분으로 나뉩니다.\n\n> **한단계씩 밀어** 라는 말은 [ 1 ][ 3 ][ 2 ] 에서 2라는 요소를 임시로 빼고 1 과 3사이에 들어갈공간을 만들기 위해 뺀 2의 자리로 3을 한 단계밀어,\n> [ 1 ][   ][ 3 ] 처럼 빈 공간을 만든 다는 의미입니다.\n\n\n---\n\n### 설명\n\n순회 인덱스 i: 3 (0, 1, 2는 요소가 1, 4, 7이므로 정렬이되어 있으므로, 넘어갑니다.)\n\n<div class=\"array\">\n    <span class=\"over\">1</span>\n    <span class=\"over\">4</span>\n    <span class=\"target\">7</span>\n    <span class=\"current\">3</span>\n    <span>2</span>\n    <span>5</span>\n</div>\n\n> 삽입정렬은 선택정렬과 다르게 지나온 요소들과 비교하여 밀면서 정렬해 나갑니다. 위 배열에서 1, 4, 7 요소는 정렬 되있기때문에,\n> j는(j = i - 1, 현재 3) 0이 될때까지 계속 순회하며 이전값과 비교하여 정렬 대상인지 아닌지를 판단합니다. 3은 7과 정렬 대상이기 때문에 정렬을 위해 밀고 삽입합니다.\n\n\n순회 인덱스 i: 3 \n\n<div class=\"array\">\n    <span class=\"over\">1</span>\n    <span class=\"over\">4</span>\n    <span class=\"target\">7</span>\n    <span class=\"current\">7</span>\n    <span>2</span>\n    <span>5</span>\n</div>\n\n> 3의 값을 복사해두고 3의 자리로 7을 밀게됩니다. 그럼 위와 같은 상황이되고 삽입할 위치에 3을 삽입하여, 아래처럼 만들수있습니다.\n\n\n순회 인덱스 i: 3\n\n<div class=\"array\">\n    <span class=\"over\">1</span>\n    <span class=\"over\">4</span>\n    <span class=\"target\">3</span>\n    <span class=\"current\">7</span>\n    <span>2</span>\n    <span>5</span>\n</div>\n\n> 한번의 정렬이 끝났으니 j를 감소시켜 또다시 이전 요소 (3과 4)를 비교하여 정렬대상이 되었습니다. \n> i는 현재 3이지만 i이전의 인덱스를 가진 요소들은 정렬되지 않았기 때문에 j를 감소시켜가며 끝까지 정렬합니다.\n\n\n* 순회 인덱스 i: 3\n* 내부 순회 인덱스 j: 2\n\n<div class=\"array\">\n    <span class=\"over\">1</span>\n    <span class=\"target\">4</span>\n    <span class=\"current\">4</span>\n    <span class=\"over\">7</span>\n    <span>2</span>\n    <span>5</span>\n</div>\n\n* 내부 순회 인덱스 j: 1\n\n<div class=\"array\">\n    <span class=\"target\">1</span>\n    <span class=\"current\">3</span>\n    <span class=\"over\">4</span>\n    <span class=\"over\">7</span>\n    <span>2</span>\n    <span>5</span>\n</div>\n\n> 내부 순회 인덱스를 줄여가며 정렬을 하였고 현재 내부 순회 인덱스(j)인 1에대한 요소(3)가 비교할 인덱스 0에대한 요소(1)과 정렬되어있다고 판단 하기에,\n> j는 더이상 감소시키지 않습니다. 따라서 i를 다시 증가시키며 이과정을 반복하여 정렬합니다.\n> 이후의 과정은 아래와 같습니다.\n\n* 순회 인덱스 i: 4\n* 내부 순회 인덱스 j: 3 (i - 1)\n\n<div class=\"array\">\n    <span class=\"over\">1</span>\n    <span class=\"over\">3</span>\n    <span class=\"over\">4</span>\n    <span class=\"target\">7</span>\n    <span class=\"current\">2</span>\n    <span>5</span>\n</div>\n\n<div class=\"array\">\n    <span class=\"over\">1</span>\n    <span class=\"over\">3</span>\n    <span class=\"over\">4</span>\n    <span class=\"current\">2</span>\n    <span class=\"target\">7</span>\n    <span>5</span>\n</div>\n\n* 순회 인덱스 i: 4\n* 내부 순회 인덱스 j: 2 (j--)\n\n<div class=\"array\">\n    <span class=\"over\">1</span>\n    <span class=\"over\">3</span>\n    <span class=\"target\">4</span>\n    <span class=\"current\">2</span>\n    <span>7</span>\n    <span>5</span>\n</div>\n\n<div class=\"array\">\n    <span class=\"over\">1</span>\n    <span class=\"over\">3</span>\n    <span class=\"current\">2</span>\n    <span class=\"target\">4</span>\n    <span class=\"over\">7</span>\n    <span>5</span>\n</div>\n\n* 순회 인덱스 i: 4\n* 내부 순회 인덱스 j: 1 (j--)\n\n<div class=\"array\">\n    <span class=\"over\">1</span>\n    <span class=\"target\">3</span>\n    <span class=\"current\">2</span>\n    <span class=\"over\">4</span>\n    <span class=\"over\">7</span>\n    <span>5</span>\n</div>\n\n<div class=\"array\">\n    <span class=\"over\">1</span>\n    <span class=\"current\">2</span>\n    <span class=\"target\">3</span>\n    <span class=\"over\">4</span>\n    <span class=\"over\">7</span>\n    <span>5</span>\n</div>\n\n* 순회 인덱스 i: 5\n* 내부 순회 인덱스 j: 4 (j - 1)\n\n<div class=\"array\">\n    <span class=\"over\">1</span>\n    <span class=\"over\">3</span>\n    <span class=\"over\">2</span>\n    <span class=\"over\">4</span>\n    <span class=\"target\">7</span>\n    <span class=\"current\">5</span>\n</div>\n\n<div class=\"array\">\n    <span class=\"over\">1</span>\n    <span class=\"over\">2</span>\n    <span class=\"over\">3</span>\n    <span class=\"over\">4</span>\n    <span class=\"target\">5</span>\n    <span class=\"current\">7</span>\n</div>\n\n* 정렬 결과\n\n<div class=\"array\">\n    <span class=\"over\">1</span>\n    <span class=\"over\">2</span>\n    <span class=\"over\">3</span>\n    <span class=\"over\">4</span>\n    <span class=\"target\">5</span>\n    <span class=\"current\">7</span>\n</div>\n\n> 모든 정렬을 수행했으므로 정렬이 완료되었습니다.\n\n\n### 예제코드\n\n* 예제코드는 생각 보다 단순합니다. 아래와 같이 배열을 순회하는 i가 있고, `array[1..i]`에서 정렬을 하는 방식입니다.\n\n\n```java\npublic class InsertionSort {\n    \n    public static void sort(int [] array) {\n\n        for (int i = 1; i < array.length; i++) {\n            int current = array[i];\n            int j = i - 1;\n\n            while(array[j + 1] < array[j]) {\n                array[j + 1] = array[j];\n                array[j--] = current;\n            }\n        }\n    }\n}\n```\n"},{"_path":"/docs/algorithm/mathematical_induction","_header":{"layout":"post","title":"-Algorithm- Mathematical Induction (수학적 귀납법) feat.java","categories":["Development","Algorithm"],"tags":["Java","Algorithm","Mathematical Induction"],"date":1649681640000,"thumbnail":"/assets/blogging/algorithm/Mathematical_Induction.png","current_company":"Herit Corporation","current_position":"Backend Server Developer","summary":"수학적 귀납법","excerpt_separator":"<!--more-->","hide":false,"breadcrumbs":["알고리즘","수학적 귀납법"]},"_description":"\n이진탐색 주제의 전형적인 예로,\n배열에서 특정값을 찾을수 있는 알고리즘을 기준으로,\n수학적 귀납법을 조금이나마 쉽게 이해할 수 있어요.\n\n","_content":"\n\n\n## 수학적 귀납법(Mathematical Induction)\n\n🌸 정의: 수학적 귀납법은 모든 자연수가 어떤 주어진 성질을 만족시킨다는 명제를 증명하는 방법의 하나.  \n  \n위의 정의 처럼 배열내 최대값을 구하는(주어진 성질) 알고리즘이 어떤 명제에 의해 증명되는지 간단하게 정리 할 거에요.\n\n## 가정 및 순서\n\n* 가정\n> 𝑵(>= 1) : 탐색범위에 있는 정렬된 정수들의 수 (배열의 길이)  \n> 𝓍 : 찾는 정수\n\n* 단계\n\n1. 기본단계  \n𝑵 = 1일 때 𝓍를 목록에 있는 하나뿐인 정수와 한 번만 비교하면 𝓍가 목록에 있는지 여부를 알 수 있으므로 이진탐색은 맞다.  \n> 설명: 배열에 길이(𝑵)가 1이더라도 해당 요소와 \"한 번\" 비교하여 목록에 있는지 알 수 있기 때문에 이진탐색 이라는 의미.\n\n2. 귀납적 가설  \n𝑵 <= 𝓴(양의 정수)일 때 이진 탐색은 𝓍가 목록에 있는지 여부를 알려 준다고 가정하자.\n> 설명: 배열의 길이(𝑵)가 무조건 양수(정수)인 경우에 그값이 한 개라도 있다면 비교가 가능하기에 있는지에 대한 여부를 확인할수 있다.\n\n3. 귀납적 단계  \n𝑵 = 𝓴 + 1일 때 이진 탐색은 𝓍가 목록에 있는지 여부를 알려 준다는 것을 증명하자. 이진탐색은 먼저 𝓍를 𝑵개의 정수들의 중간 요소와 비교한다. 비교 결과는 다음과 같이 세 가지 경우가 있다.\n> 설명:  𝑵 = 𝓴 + 1라는 가정(배열내 요소가 존재)에서 이진탐색을 통해 𝓍가 목록에 있는지에 대한 여부를 알아 낼 수있다. 이진 탐색은 기본적으로 중간값 피벗을 정해두고 이를 기준으로 오른쪽(큰수) 또는 왼쪽(작은수)의 배열을 사용할 지를 구분할 수 있다.  \n> 물론 이 기준은 현재의 상황에서 오름차순(또는 내림차순)으로 정렬되어있는 경우에 이진 탐색을 시도할 수 있다.  \n> 만약 `[12, 22, 37, 39 ,50]`이라는 배열이 있고 찾는 값인 𝓍가 가운데 값인 `37`과 비교해서 어떤 배열(또는 37)에서 찾을 수 있는 지를 의미한다.  \n> 찾는값이 37이상 이라면 아래처럼 왼쪽의 값들은 비교조차 안하며 초록색의 값들에서만 찾는다.\n\n\n<div class=\"array\">\n    <span class=\"over\">12</span>\n    <span class=\"over\">22</span>\n    <span class=\"current\">37</span>\n    <span class=\"target\">39</span>\n    <span class=\"target\">50</span>\n</div>\n\n\n<table class=\"case-table\">\n    <tbody>\n        <tr>\n            <th><span class=\"case-head\">경우 1</span></th>\n            <td><span class=\"case-body\">𝓍가 중간요소와 같다.<br/>이 경우는 𝓍를 찾았으므로 이진 탐색은 맞다.</span></td>\n        </tr>\n        <tr>\n            <th><span class=\"case-head\">경우 2</span></th>\n            <td><span class=\"case-body\">𝓍가 중간 요소보다 작다.<br>이 경우는 𝓍를 목록의 왼쪽 반에서 찾아야한다. 목록의 왼쪽 반의 크기 𝑵'은 ⎣𝑵/2⎦이다. 𝑵' <= 𝓴이므로 귀납적 가설에 의해 이진탐색은 𝓍가 목록에 있는지 여부를 알려 준다.<br/>따라서 이진탐색은 맞다.</span></td>\n        </tr>\n        <tr>\n            <th><span class=\"case-head\">경우 3</span></th>\n            <td><span class=\"case-body\">𝓍가 중간요소보다 크다.<br/>이 경우는 경우 2와 비슷한 논리로 맞다.</span></td>\n        </tr>\n    </tbody>\n</table>\n\n따라서 이진탐색은 𝑵 = 𝓴 + 1일 때 맞다.\n\n> 잘못 설명된 내용이 있거나, 부적절한 예시가 있다면, 아래 댓글로 조언 부탁드립니다.  \n> 감사합니다.  😄"},{"_path":"/docs/algorithm/selection_sort","_header":{"layout":"post","title":"-Algorithm- Selection Sort (선택정렬 알고리즘) feat.java","categories":["Development","Algorithm"],"tags":["Java","Algorithm","Sort","Selection Sort"],"date":1649082840000,"thumbnail":"/assets/blogging/algorithm/selection_sort_intro.png","current_company":"Herit Corporation","current_position":"Backend Server Developer","summary":"선택 정렬","excerpt_separator":"<!--more-->","hide":false,"breadcrumbs":["알고리즘","선택 정렬"]},"_description":"기본 정렬 알고리즘중 하나인 선택 정렬(Selection Sort)입니다.\n간단한 그림과 함께 쉽게 이해할 수 있도록 정리했어요.\n","_content":"\n\n\n## 선택정렬 (Selection Sort)\n\n\n🌸 선택 정렬은 정렬할 배열을 순회하며, 어떤 원소로 대치할지 선택하여 정렬하는 알고리즘 입니다.\n설명을 보기에 앞서, 통상적으로 정렬은 오름 또는 내림으로 배열의 수열을 맞추어 순서를 만드는 행위로 의미합니다.\n\n---\n  \n  \n  \n\n<div class=\"array\">\n    <span>1</span>\n    <span>4</span>\n    <span>7</span>\n    <span>3</span>\n    <span>2</span>\n    <span>5</span>\n</div>\n\n\n> 정렬을 하기위해 배열을 준비합니다. 또한, 해당 배열을 순회하면서 *나머지들의 값들중 가장작은 값으로 변경합니다.\n\n순회 인덱스 i: 0\n\n<div class=\"array\">\n    <span class=\"current\">1</span>\n    <span>4</span>\n    <span>7</span>\n    <span>3</span>\n    <span>2</span>\n    <span>5</span>\n</div>\n\n> 첫번째 순회요소는 나머지의 값들중 가장작은 값인 1 입니다. 따라서, 변경하지않습니다.\n\n순회 인덱스 i: 1\n\n<div class=\"array\">\n    <span class=\"over\">1</span>\n    <span class=\"current\">4</span>\n    <span>7</span>\n    <span>3</span>\n    <span class=\"target\">2</span>\n    <span>5</span>\n</div>\n\n> 두번째는 4입니다. 나머지의 요소들중 가장작은값이 2가 존재합니다. 4와 2를 변경합니다. 다음 부터는 정렬 순서가 동일합니다. 배열의 끝까지 순회하며 나머지 값들로 선택후 변경으로 정렬합니다.\n\n순회 인덱스 i: 2\n\n<div class=\"array\">\n    <span class=\"over\">1</span>\n    <span class=\"over\">2</span>\n    <span class=\"current\">7</span>\n    <span class=\"target\">3</span>\n    <span>4</span>\n    <span>5</span>\n</div>\n\n순회 인덱스 i: 3\n\n<div class=\"array\">\n    <span class=\"over\">1</span>\n    <span class=\"over\">2</span>\n    <span class=\"over\">3</span>\n    <span class=\"current\">7</span>\n    <span class=\"target\">4</span>\n    <span>5</span>\n</div>\n\n순회 인덱스 i: 4\n\n<div class=\"array\">\n    <span class=\"over\">1</span>\n    <span class=\"over\">2</span>\n    <span class=\"over\">3</span>\n    <span class=\"over\">4</span>\n    <span class=\"current\">7</span>\n    <span class=\"target\">5</span>\n</div>\n\n순회 인덱스 i: 5\n\n<div class=\"array\">\n    <span class=\"over\">1</span>\n    <span class=\"over\">2</span>\n    <span class=\"over\">3</span>\n    <span class=\"over\">4</span>\n    <span class=\"over\">5</span>\n    <span class=\"over\">7</span>\n</div>\n\n## 과정 코드\n\n* 요소 교환\n```java\n    /**\n     * i 와 j 값 변경\n     * 각 인덱스로 접근하므로 시간복잡도는 상수시간을 갖는다. O(1)\n     * @param array\n     * @param i\n     * @param j\n     */\npublic static void swapElements(int [] array, int i, int j) {\n    int temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n}\n```\n\n* 최소값 찾기\n```java\n/**\n * start 인덱스 부터 시작해서 끝까지 순회중 가장 작은 값을 리턴한다.\n * @param array\n * @param start\n * @return\n */\npublic static int indexLowest(int [] array, int start) {\n    int lowIndex = start;\n\n    for(int i = start;i < array.length;i++) {\n        if(array[i] < array[lowIndex]) {\n            lowIndex = i;\n        }\n    }\n    return lowIndex;\n}\n```\n\n* 최소값을 찾고, 변경\n```java\n/**\n * indexLowest 메서드를 통해 얻어온 가장작은값의 인덱스를 현재 인덱스와 변경한다.\n * @param array\n */\npublic static void selectionSort(int [] array) {\n    System.out.printf(\"before selection sort : %s\\n\", Arrays.toString(array));\n    for(int i = 0;i < array.length;i++) {\n        int j = indexLowest(array, i);\n        swapElements(array, i, j);\n\n        System.out.printf(\"(i = %d) array : %s\\n\",i , Arrays.toString(array));\n    }\n\n}\n```\n\n### 호출\n\n```java\nimport sort.selection_sort.SelectionSort;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n    \n        int [] needSort = {1, 4, 7, 3, 2, 5};\n        \n        SelectionSort.selectionSort(needSort);\n    }\n}\n```\n\n### 콘솔\n```\nbefore selection sort : [1, 4, 7, 3, 2, 5]\n(i = 0) array : [1, 4, 7, 3, 2, 5]\n(i = 1) array : [1, 2, 7, 3, 4, 5]\n(i = 2) array : [1, 2, 3, 7, 4, 5]\n(i = 3) array : [1, 2, 3, 4, 7, 5]\n(i = 4) array : [1, 2, 3, 4, 5, 7]\n(i = 5) array : [1, 2, 3, 4, 5, 7]\nafter selection sort : [1, 2, 3, 4, 5, 7]\n```\n\n> 풀이 또는 잘못된 설명은 아래 댓글로 말씀 부탁드립니다.\n\n"}]