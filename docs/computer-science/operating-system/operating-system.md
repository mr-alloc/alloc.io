---
layout: post
title: Operating System (OS)
tags: [Operating System, OS]
date: 2021-01-20 20:19:30 +0900
thumbnail: /post/computer-science/operating-system.webp
current-company: Cubic INC
current-position: SI Researcher
profile-image: /post/profile/profile1.jpg
summary: 컴퓨터 OS
excerpt-separator: <!--more-->
hide: false
---
운영체제가 어떤일을 하는지를 알려면, 컴퓨터가 어떤 요소들로 구성되어 있는지를 이해 해야한다.
각 요소의 구성과 이해관계 그리고 역할을 알아보자.
<!--more-->

## 컴퓨터의 구성::computer-structure

컴퓨터는 크게 응용프로그램, 운영체제, 하드웨어 계층으로 분류된다.
이 문서에서는 응용프로그램을 제외하고 운영체제와 하드웨어에 대해 논한다.

[CPU](/wiki/central-processing-unit)와 [입출력 장치]() 그리고 [메모리]()는 [시스템 버스]()를 통해 서로 연결되어 있으며, 버스의 종류에 따라 단방향 또는 양방향으로 신호를 보낸다.
입출력 장치의 경우 메인보드 위에 사전에 만들어진 장치 컨트롤러를 운영체제의 장치 드라이버가 제어하며, 장치드라이버는 운영체제에 일관된 인터페이스를 제공한다.
CPU와 장치컨트롤러는 병렬로 실행되기 떄문에 메모리에 접근하기위해 메모리 사이클을 두고 경쟁한다. 이 메모리에 순차적으로 접근하기 위해 메모리 컨트롤러는 메모리에 대한 액세스를 동기화한다.


위에서 간단히 설명한 내용은 OS 내부의 커널과 시스템 프로그램에 의해 제어되며, 하드웨어의 경우 사전에 설계된 회로의 동작을 수행한다.

## 운영체제의 구조::structure-of-os

운영체제 같이 크고 복잡한 시스템은 쉽게 변경할 수 있으면서 올바르게 동작하려면 신중히 제작되어야 한다.
일반적으로 한 개의 일관된 시스템보다는 작업을 작은 구성요소로 분할 하는 것이다. 각각의 모듈은 신중히 정의된 인터페이스와 기능들을 가지는 시스템의 일부가 되어야 한다.  

예를 들어 `main()` 함수에 모든 코드를 넣는것 보다 필요한 기능을 올바른 인자와 반환값을 명시한 여러 함수로 분리하고 적재적소에 맞게 호출하는 것이다.  

운영체제의 공통적인 구성요소들이 어떻게 연결되어 하나의 커널로 결합하는지 알아보자.

### 모놀리식 구조::monolithic-structure

가장 간단한 방법으로 프로그램을 만드는 방법은 한개의 구조없이 한곳에서 모든 것을 관리하는 것이다.

**monolithic**[mɑ:nə│lɪθɪk]: 하나로된 거대한 덩어리
이러한 한개의 구조를 `모놀리식 (monolithic)`이라고 한다. 즉 단일 주소 공간에서 실행되는 단일 바이너리 파일에 커널의 모든 기능을 넣는 것이다.

`모놀리식 구조`라고 하는 이방법은 운영체제를 설계하는 일반적인 기법이다. 이러한 제한적인 구조를 가지는 운영체제는 최초의 UNIX 운영체제가 대표적인 예시이다.
커널과 시스템 프로그램의 두 부분으로 구성된다.

커널은 여러가지 인터페이스아 장치드라이버로 나뉘게 되는데, 이는 `UNIX`가 발전해 오면서 몇십년에 걸쳐 추가되고 확장 되었다.
계층 별로 이루어져 있는 `UNIX` 운영체제는 [시스템 콜](/wiki/system-call) 인터페이스 아래와 하드웨어 위 모든 것이 커널이다. 

![UNIX의 전통적인 시스템 구조(/post/computer/traditional-system-structure-of-unix.png)
:{ "align": "center", "max-width": "400px", "description": "UNIX의 전통적인 시스템 구조" }

커널은 시스템 콜을 통해 `파일 시스템`, `CPU 스케줄링`, `메모리 관리` 등의 기능을 제공한다. **이러한 기능은 한나의 주소 공간으로 결합하기에는 너무 많은 기능이다.**

`Linux` 운영체제는  `UNIX`에 기반을 두고 있으며 아래와 같은 유사한 구조로 구성된다.

![Linux의 시스템 구조(/post/computer/system-structure-of-linux.png)
:{ "align": "center", "max-width": "400px", "description": "Linux의 시스템 구조" }

응용 프로그램은 일반적으로 커널의 시스템콜 인터페이스와 통신할 때 [`glibc` 표준 C 라이브러리](/wiki/system-call#api-and-system-call)를 사용한다.  
`Linux` 커널은 단일 주소 공간에서 커널모드로 전부 실행된 다는 점에서 모놀리식이지만, 런타임에 커널을 정할 수 있는 [LKM]() 모듈식 설계를 갖추고 있다.

이러한 단순한 구조라도 확장은 어렵지만 시스템 콜의 오버헤드가 거의 없고 커널안에서의 통신속도가 빠르다는 단점이 있다.
따라서 모놀리식 커널의 단점에도 불구하고 속도와 효율성은 아직까지도 `UNIX`와 `Linux` 및 `Windows`에서 사용되는 것이 증명해준다.


### 계층적 접근::layered-approach

작성중...




## 운영체제의 동작 순서::workflow-of-os

컴퓨터의 전원을 켤 때 실행되는 부트스트랩 프로그램은 펌웨어이다.  
부트스트랩 프로그램은 하드웨어 위에서 동작하며 `CPU`, `메모리` `저장장치` 등을 초기화 한다. 또한 운영체제를 로드하기 위해 부트로더를 실행하며, 이는 저장장치에서 메모리로 [Kernel]()(`커널`)을 적재한다.

부트로더는 커널 실행에 필요한 초기설정(예: 커맨드라인 인자 전달 등)을 한뒤, 커널에 제어를 넘긴다. 이후에 커널은 시스템을 초기화하고 사용자 공간(user space)을 준비한다.
각 시스템에서 사용 되는 부트로더는 여러종류가 있다.

* GRUB (GNU GRUB):
  * 리눅스/유닉스 시스템에서 사용되는 부트로더
* LILO(Linux Loader)
  * 과거 리눅스 시스템에서 사용되는 부트로더
* Windows Boot Manager
  * 윈도우 시스템에서 사용하는 부트로더
* Android Bootloader
  * 안드로이드 기기에서 사용되는 부트로더로, 리커버리모드와 운영체제를 실행한다.

## 운영체제의 역할::role-of-os

운영체제는 사용자 또는 시스템 프로그램이 올바르게 실행되기 위해 커널에서 다양한 관리를 아래와 같이 제공한다.

* 메모리 관리
* 프로세스 관리
* 장치 드라이버
* 파일 시스템
* 네트워크 관리

### 메모리 관리::memory-management

### 프로세스 관리::process-management

운영체제는 자원을 관리하지만, 아마 그중에서도 가장 중요한건 [프로세스]()에 대한 관리이다. 대표적으로 아래와 같다.

* 사용자 프로세스와 시스템프로세스의 생성과 제거
* `CPU`에 프로세스와 스레드 스케줄링
* 프로세스의 일시중지(suspend) 와 재수행(resume)
* 프로세스 동기화 기법 제공
* 프로세스 간 통신(IPC) 제공

위와 같은 처리를 위해 운영체제는 프로세스의 상태를 관리하며, 프로세스의 상태(process stats)는 `생성`, `준비`, `실행`, `대기`, `종료`로 나뉜다.
이러한 상태는 아래처럼 나타낼 수 있다.
```
 New
  ↓
Ready ←→ Running → Terminated
  ↑        ┆
Waiting ←--╯
```
