[
  {
    "path": "/docs/algorithm/heap-sort",
    "header": {
      "layout": "post",
      "title": "Heap sort (힙 정렬) feat.java",
      "categories": [
        "algorithm"
      ],
      "tags": [
        "Java",
        "Algorithm",
        "Sort",
        "Heap Sort",
        "Heap"
      ],
      "date": 1651837980000,
      "profile-image": "/post/profile/profile4.jpeg",
      "thumbnail": "/post/algorithm/heap/heap_sort_intro.png",
      "current-company": "Herit Corporation",
      "current-position": "Backend Server Developer",
      "summary": "힙과 힙정렬 (우선순위 큐)",
      "expose-images": true,
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "알고리즘"
      ],
      "images": [
        {
          "src": "/post/algorithm/heap/tree_images.svg",
          "alt": "위 트리중 어떤것이 힙인지 찾아보세요."
        },
        {
          "src": "/post/algorithm/heap/first_iteration.svg",
          "alt": "힙을 만드려면 완전 이진트리가 있어야 해요."
        },
        {
          "src": "/post/algorithm/heap/other_iteration.svg",
          "alt": "만약 마지막 내부노드부터 순회할 때, 쵀대힙을 만드려면 위와 같이 만들수 있어요."
        },
        {
          "src": "/post/algorithm/heap/last_iteration.svg",
          "alt": "최대힙을 만들어 이런 형태로 노드를 나눌수 있어요."
        },
        {
          "src": "/post/algorithm/heap/add_new_17.svg",
          "alt": "만약 다음의 힙에서 17이라는 값이 추가 된다면"
        },
        {
          "src": "/post/algorithm/heap/add_new_17_2.svg",
          "alt": "이런식으로 부모노드와 바꿔가며, 다시 힙을 유지할 수 있어요."
        },
        {
          "src": "/post/algorithm/heap/heap_sort_1_1.svg",
          "alt": "힙 정렬 1"
        },
        {
          "src": "/post/algorithm/heap/heap_sort_1_2.svg",
          "alt": "힙 정렬 2"
        },
        {
          "src": "/post/algorithm/heap/heap_sort_1_3.svg",
          "alt": "힙 정렬 3"
        },
        {
          "src": "/post/algorithm/heap/heap_sort_1_4.svg",
          "alt": "힙 정렬 4"
        },
        {
          "src": "/post/algorithm/heap/heap_sort_1_5.svg",
          "alt": "힙 정렬 5"
        },
        {
          "src": "/post/algorithm/heap/heap_sort_1_6.svg",
          "alt": "힙 정렬 6"
        },
        {
          "src": "/post/algorithm/heap/heap_sort_1_7.svg",
          "alt": "힙 정렬 7"
        },
        {
          "src": "/post/algorithm/heap/heap_sort_1_8.svg",
          "alt": "힙 정렬 8"
        }
      ],
      "headlines": {
        "grade": 0,
        "title": "root",
        "fragmentId": "root",
        "children": [
          {
            "grade": 2,
            "title": "설명",
            "fragmentId": "%EC%84%A4%EB%AA%85",
            "children": [
              {
                "grade": 3,
                "title": "Heap의 속성 (특징)",
                "fragmentId": "heap%EC%9D%98-%EC%86%8D%EC%84%B1-(%ED%8A%B9%EC%A7%95)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "Heap을 만드는 방법",
                "fragmentId": "heap%EC%9D%84-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "Heap이 우선 값을 유지하는 방법",
                "fragmentId": "heap%EC%9D%B4-%EC%9A%B0%EC%84%A0-%EA%B0%92%EC%9D%84-%EC%9C%A0%EC%A7%80%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "Heap을 이용해 정렬을 하는 방법",
                "fragmentId": "heap%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%B4-%EC%A0%95%EB%A0%AC%EC%9D%84-%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95",
                "children": [],
                "isSelected": false
              }
            ],
            "isSelected": false
          },
          {
            "grade": 2,
            "title": "구현 코드 (Java)",
            "fragmentId": "%EA%B5%AC%ED%98%84-%EC%BD%94%EB%93%9C-(java)",
            "children": [],
            "isSelected": false
          }
        ],
        "isSelected": false
      }
    },
    "description": "열라 간단한 우선순위 큐의 자료구조인 Heap에 대해 공부합니다.\n힙의 속성?! 힙이 최소 또는 최대값을 유지하는 방법?!  \n\n힙을통해 정렬하는 방법까지 공부합니다. 😁\n\n",
    "content": "\n## 설명\n\n간단하게 말하여, 힙은 우선순위 큐 입니다. `JAVA`에서는 `PriorityQueue`라는 구현체를 통해 Heap 자료구조를 사용할 수 있어요.\n힙은 두 종류가 있는데 `최대 힙`과 `최소 힙`이 있어요. \n최대 Heap(최소 Heap)은 단어와 같이 최대 값(최소 값)을 우선순위로 판단하여, 어떠한 값이 들어와도, 항상 같은 순서의\n트리를 유지하며, 언제든지 최고 우선순위의 값을 적은 비용으로 쉽게 얻을수 있는 자료구조 입니다.\n\n### Heap의 속성 (특징)\n\n* 최대 힙(**또는 최소 힙**)은 `잎(leaf)`의 계층을 제외한 모든 노드는 자식의 노드 보다 큰(**또는 작은**) 값을 가지고 있어야합니다.\n* 왼쪽부터 차례대로 채워져있는 `완전 이진 트리(Complete binary tree)`이어야 합니다.\n* 같은 계층의 노드들과는 정렬하지 않습니다.\n* 루트(뿌리)노드로 부터 내려오는 위치의 노드들 오름차순(**또는 내림차순**)입니다\n\n![위 트리중 어떤것이 힙인지 찾아보세요.](/post/algorithm/heap/tree_images.svg)\n\n* 트리 A: 잎을 제외한 노드는 모두 정렬되었지만, 왼쪽부터 채워지지않아 Heap이 아닙니다.\n* 트리 B: 왼쪽부터 채워졌지만, 2번노드의 값은 그 자식에값보다 작습니다. 따라서 Heap이 아닙니다.\n* 트리 C: 잎을 제외한 모든 노드가 자식 또는 부모와 정렬 되어있고, 왼쪽부터 채워져있으므로 `Heap`입니다.\n\n> 이를 정리하면 아래와 같습니다.   \n> 1.`𝑛개`의 노드를 가진 힙은 정확히 하나만 있고 그 힙(트리)의 높이(height)는 `⎣log₂𝑛⎦`이다. 트리의 전체 노드의 개수가 `8`일경우 트리(힙)의 높이는 `3`이다. 즉 힢의 높이는 힙의 성질(속성)에 부합되는 노드들만 인정이 된다는 의미이다.  \n> 2.힙의 루트 노드는 항상 최댓값(**또는 최솟값**)을 저장한다. 최대 힙(**또는 최소 힙**)은 쵀댓값(**또는 최솟값**)을 효율적으로 관리하기 위한 자료구조이며, 루트에는 항상 가장 큰(**또는 작은**)값을 유지한다.  \n> 3.힙의 한 노드와 그 노드의 자손 노드들로 이루어진 부분 트리(subtree)도 힙이다. 힙은 힙으로 이루어져있으며 자식노드도 힙이 될수있지만, 노드의 자식이없다면 힙이될 수없다. 따라서 위 C 트리의 `4, 5, 6`번 노드는 힙이 아니다.  \n:{ \"type\": \"note\", \"icon\": \"info\" }\n\n### Heap을 만드는 방법\n\n힙을 구성 하기 위해서는 다음의 순서대로 진행됩니다.\n\n1. 순회를 시작할 힙이되는 마지막 노드`⎣𝑛/₂⎦`를 찾는다.\n2. 마지막 노드 i를 이용해 자식노드가 있는지, 또한 있다면 그 중 자신 보다 큰값을 자신과 찾는다.\n3. 찾은 값과 자신을 바꾸고 바꾼 자신의 위치는 그값의 자식이 되며, 자신보다 큰값이 나오지 않을때까지 반복한다.\n4. 다음 노드(i -1)에서 다시 `3.`을 반복한다.\n\n> 자식 노드의 위치를 찾을때는 왼쪽`arr[2i]`값과 오른쪽`arr[2i + 1]`로 구할 수 있습니다.\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\" }\n\n위 의 내용을 정리하면 아래와 같습니다.\n\n\n![힙을 만드려면 완전 이진트리가 있어야 해요.](/post/algorithm/heap/first_iteration.svg)\n\n> 위의 트리는 *완전 이진트리* 입니다. 힙은 완전이진트리에서 만들수 있으므로, 일반 이진트리는 Compact하게 완전이진트리로 바꿔야 힙을 만들수 있습니다.\n> 왼쪽 트리의 마지막 힙의 값은 `15` 이며, 이는 자식(`6, 4`) 어느것 보다도 큰값입니다. 따라서 다음 순회로 넘어갑니다.\n> 순회는 내부 노드의 마지막 힙의 위치에서 부터 1까지 이어집니다. 따라서 다음 인덱스인 3번 노드(9)로 넘어갑니다.\n> 3번노드는 자신의 자식들 중 6번째, 7번째 (7, 12)와 비교하여 더 큰값을 가지는 12와 바꿉니다.\n:{ \"type\": \"note\", \"icon\": \"info\" }\n\n![만약 마지막 내부노드부터 순회할 때, 쵀대힙을 만드려면 위와 같이 만들수 있어요.](/post/algorithm/heap/other_iteration.svg)\n\n> 이후 과정은 위와 같이 반복됩니다. 내부노드를 순회하며 자신의 자식노드가 있는지 확인하고 있다면, 자신과 비교하여 더큰 값으로 바꿉니다. 이는 바꾼이후에도 `3.`이 반복되게 됩니다. 순회되는 노드가 최상위노드가 되고 모든 내부노드가 힙이 될때, 전체 트리는 힙이 됩니다.   \n> 마지막까지 바꾼 최종트리는 아래와 같습니다.\n:{ \"type\": \"note\", \"icon\": \"info\" }\n\n![최대힙을 만들어 이런 형태로 노드를 나눌수 있어요.](/post/algorithm/heap/last_iteration.svg)\n\n* 최상위 노드(루트)가 가장 큰값이 되며, 위는 최대힙을 만드는 단계였습니다.\n* 부모노드와 자식노드끼리는 순서의 값을 가지며, 항상 최대의 값을 가집니다.  \n\n### Heap이 우선 값을 유지하는 방법\n\n위에서는 완전이진트리로 힙을 어떻게 만드는지에 대해 알아봤습니다.\n하지만, 힙은 언제나 새로운값이 들어와도 항상 우선 순위로 값을 관리합니다. 만약 저기서 더큰값이 추가된다면,\n저 힙트리는 어떻게 바뀔까요? 새로운 값들을 추가해서 힙이 다시 어떻게 유지되는지 배워봅니다.\n\n#### 값추가\n\n힙트리에서 값을 추가 할때는 마지막 노드로 붙여주고 위에서 했던것과 동일하게 힙을 만들어 줍니다.\n만약 새로운 값 17이 힙에 들어온다면 순서는 아래와 같이 바뀝니다.\n\n![만약 다음의 힙에서 17이라는 값이 추가 된다면](/post/algorithm/heap/add_new_17.svg)\n![이런식으로 부모노드와 바꿔가며, 다시 힙을 유지할 수 있어요.](/post/algorithm/heap/add_new_17_2.svg)\n\n\n> A: 새로 들어온 값 17은 트리의 맨뒤인 10번노드로 들어갑니다.     \n> 또한 마지막 내부노드이자 자신의 부모인 5번 노드(4)부터 다시 순회를 시작하며,  \n> 자신보다 큰 값은 가진 자식 10번 노드(17)과 값을 바꿉니다. \n> B: 값이 바뀐 10번 노드(4)는 자식을 가지고있지 않으므로 다음 순회로 넘어갑니다.  \n> C: 다음 순회인 4번 노드(6)은 자식들보다 큰값이므로 다음 3번 노드(12)로 이동합니다. 하지만 이또한 자식들보다 값이 크므로, 2번 노드(8)로 이동합니다. 자신보다 큰값을 가지는 5번 자식노드(17)과 바꿉니다.  \n> D: 값이 바뀐 5번 노드(8)은 자식들 보다 값이 커, 바꿀 필요가 없으므로 다음 순회인 1번 노드(15)로 이동합니다.  \n> E: 현재 순회인 1번 노드(15)는 자신의 2번 노드(17)보다 값이 작으므로 바꿉니다.  \n> F: 최종적으로 힙이 완성되었습니다.\n:{ \"type\": \"tip\", \"icon\": \"check-circle\" }\n\n\n### Heap을 이용해 정렬을 하는 방법\n\n힙 정렬을 위해서는 사전에 완전 이진 트리를 힙으로 만들고, 정렬을 수행할 수 있습니다.\n위에서 만든 힙을 통해 정렬을 하는 방법을 구현합니다.  \n힙 정렬은 간단하게, 아래의 정렬하는 순서를 가지고있습니다.\n\n1. 최상위 노드 `A`와 가장 끝의 노드 `B`를 바꾼다.\n2. 바꿔진 A는 맨뒤로 가며,힙에서 제외한다. \n3. 바꾼 값 `B`는, 자신의 자식이 있다면, 두개를 비교하여 가장 큰 값과 맞 바꾼다.\n4. `3.`의 내용을 힙이될때까지 반복한다.\n\n위의 순서를 반복하며, 만든 힙 정렬은 아래와 같습니다.\n\n![힙 정렬 1](/post/algorithm/heap/heap_sort_1_1.svg)\n![힙 정렬 2](/post/algorithm/heap/heap_sort_1_2.svg)\n![힙 정렬 3](/post/algorithm/heap/heap_sort_1_3.svg)\n![힙 정렬 4](/post/algorithm/heap/heap_sort_1_4.svg)\n![힙 정렬 5](/post/algorithm/heap/heap_sort_1_5.svg)\n![힙 정렬 6](/post/algorithm/heap/heap_sort_1_6.svg)\n![힙 정렬 7](/post/algorithm/heap/heap_sort_1_7.svg)\n![힙 정렬 8](/post/algorithm/heap/heap_sort_1_8.svg)\n\n## 구현 코드 (Java)\n\n```java\nimport java.util.Arrays;\n\npublic class Heap {\n    \n    //== 힙(Heap) 을 만드는 메소드 ==//\n    public static void makeHeap(int arr[]) {\n        // last heap\n        int lh = arr.length / 2;\n        System.out.println(\"Normal Array = \" + Arrays.toString(arr));\n        int eh = arr.length;\n        while (lh-- > 0) {\n\n            System.out.println(\"i: \" + lh);\n            pushDown(arr, lh, eh);\n        }\n\n        System.out.println(\"Array as Max Heap = \" + Arrays.toString(arr));\n    }\n    \n    \n    //== 노드와 그 자식중에서 더큰(또는 작은) 위치를 찾는 메소드 ==//\n    public static int findLargest(int arr[], int node, int eh) {\n        // first child\n        int fc = (2 * (node + 1)) - 1;\n\n        if (fc + 1 < eh) {\n            if (arr[fc] <= arr[fc + 1]) {\n                return arr[fc + 1] <= arr[node] ? node : fc + 1;\n            } else {\n                return arr[fc] <= arr[node] ? node : fc;\n            }\n        }\n        if (fc < eh && arr[node] < arr[fc]) {\n            return fc;\n        } else {\n            return node;\n        }\n    }\n    //== 값을 아래로 내리는 메소드 ==//\n\n    /**\n     * 간단하게 보면 트리에서 마지막 힙의 위치를 구하고,\n     * 루트 노드까지 역순으로 힙을 만들어갑니다.\n     * \n     * 최대 힙(또는 최소 힙)의 조건에 따라 더큰(또는 더 작은)값을 기준으로,\n     * 해당 노드를 위로올리고 변경된 대상은 아래로 내려가며 계속 바꿉니다.\n     */\n    public static void pushDown(int arr[], int node, int eh) {\n        do {\n            System.out.println(\"j: \" + node);\n            int temp = arr[node];\n            int large = findLargest(arr, node, eh);\n            System.out.println(drawBinaryTree(arr));\n\n            if (large == node)\n                break;\n\n            arr[node] = arr[large];\n            arr[large] = temp;\n\n            node = large;\n        } while (node <= eh);\n    }\n\n    public static void sort(int arr[]) {\n        int last = arr.length;\n        makeHeap(arr);\n\n        while (--last >= 0) {\n\n            int temp = arr[0];\n            arr[0] = arr[last];\n            arr[last] = temp;\n\n            System.out.println(\"last: \" + last);\n            pushDown(arr, 0, last);\n        }\n        ;\n    }\n\n    //== 출력 메소드 ==//\n    public static String drawBinaryTree(int arr[]) {\n        StringBuilder builder = new StringBuilder();\n\n        int nol = (int) (Math.log(arr.length) / Math.log(2)) + 1;\n        int max = (int) Math.pow(2, nol - 1);\n\n        int printed = 0;\n        for (int i = 0; i < nol; i++) {\n            int perFloor = (int) Math.pow(2, i);\n            int tab = (max - perFloor) / 2 + (max - perFloor) % 2;\n            int last = printed + perFloor;\n\n            for (int j = 0; j < tab; j++) {\n                builder.append(\"  \");\n            }\n            for (int j = printed; (j < arr.length && j < last); j++) {\n                builder.append(String.format(\"(%d)\", arr[j]));\n            }\n            builder.append(\"\\n\");\n            printed += perFloor;\n        }\n\n        return builder.toString();\n    }\n    \n    public static void main(String args []) throws Exception {\n        //== 힙 으로 만들기==//\n        int arrForMake [] = {1, 5, 8, 2, 74, 9, 12, 104, 87, 43};\n        Heap.makeHeap();\n        \n        //== 힙 + 정렬 ==//\n        int arrForSort [] = {1, 8, 9, 15, 4, 7, 12, 6, 4, 17};\n        Heap.sort(arr);\n        \n    }\n}\n```\n\n\n\n"
  },
  {
    "path": "/docs/database/mysql-explain",
    "header": {
      "layout": "post",
      "title": "MySQL의 EXPLAIN을 알아보자",
      "categories": [
        "database",
        "mysql"
      ],
      "tags": [
        "Database",
        "MySQL",
        "EXPLAIN"
      ],
      "date": 1650691620000,
      "thumbnail": "/post/database/mysql/mysql-explain-thumbnail.webp",
      "current-company": "Herit Corporation",
      "current-position": "Backend Server Developer",
      "summary": "MySQL EXPLAIN",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "database"
      ],
      "images": [],
      "headlines": {
        "grade": 0,
        "title": "root",
        "fragmentId": "root",
        "children": [
          {
            "grade": 2,
            "title": "EXPLAIN 출력 컬럼",
            "fragmentId": "explain-%EC%B6%9C%EB%A0%A5-%EC%BB%AC%EB%9F%BC",
            "children": [
              {
                "grade": 3,
                "title": "id (SELECT 순서)",
                "fragmentId": "id-(select-%EC%88%9C%EC%84%9C)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "select_type (SELECT 타입)",
                "fragmentId": "select_type-(select-%ED%83%80%EC%9E%85)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "table (참조 테이블)",
                "fragmentId": "table-(%EC%B0%B8%EC%A1%B0-%ED%85%8C%EC%9D%B4%EB%B8%94)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "partition (파티션)",
                "fragmentId": "partition-(%ED%8C%8C%ED%8B%B0%EC%85%98)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "type (조인타입)",
                "fragmentId": "type-(%EC%A1%B0%EC%9D%B8%ED%83%80%EC%9E%85)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "possible_kyes (사용가능한 인덱스)",
                "fragmentId": "possible_kyes-(%EC%82%AC%EC%9A%A9%EA%B0%80%EB%8A%A5%ED%95%9C-%EC%9D%B8%EB%8D%B1%EC%8A%A4)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "key (사용할 인덱스)",
                "fragmentId": "key-(%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%9D%B8%EB%8D%B1%EC%8A%A4)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "key_len (키의 길이)",
                "fragmentId": "key_len-(%ED%82%A4%EC%9D%98-%EA%B8%B8%EC%9D%B4)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "ref (참조 값)",
                "fragmentId": "ref-(%EC%B0%B8%EC%A1%B0-%EA%B0%92)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "rows (검사 행 개수)",
                "fragmentId": "rows-(%EA%B2%80%EC%82%AC-%ED%96%89-%EA%B0%9C%EC%88%98)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "filtered (필터된 수치)",
                "fragmentId": "filtered-(%ED%95%84%ED%84%B0%EB%90%9C-%EC%88%98%EC%B9%98)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "Extra ()",
                "fragmentId": "extra-()",
                "children": [],
                "isSelected": false
              }
            ],
            "isSelected": false
          }
        ],
        "isSelected": false
      }
    },
    "description": "MySQL의 쿼리실행계획에 대해 알아보자.\r\n",
    "content": "\r\n\r\n회사에서는 신규유입되는 쿼리에 한에 검수를 할수 있는 툴을 만들었다.\r\n\r\n나는 담당하는 서비스에 대해 신규 유입 쿼리를 검수해야하며, 매우 많은 쿼리를 봐야만 했다. \r\n이는 반복적인 업무(쿼리 복사, 테이블 및 인덱스확인, 검수)로 이어졌으며, 실행계획만으로 분석해야하는 대상인지를 1차적으로 판단할 필요가있었다.\r\n\r\n쿼리는 여러 유입 목록중 하나를 상세보기로 전체쿼리를 보아 DB Client(Datagrip)로 가져와서 한개씩 확인 해야했다. \r\n해당 목록에는 쿼리 실행계획도 포함이 되어있기때문에, 상세보기를 보지않고, 목록에서 실행계획만 본다면 바로 판단이 가능하다고 생각되어, 실행 계획을 공부하기로 했다.  \r\n\r\n---\r\n\r\n`EXPLAIN`은 MySQL이 statement를 어떻게 실행하는지에 대한 정보를 제공한다.\r\n`EXPLAIN`은 `SELECT`쿼리 에서 사용되는 각 테이블에 대한 정보를 반환하며, 이는 [Mysql Query Optimizer]() 가 명령문을 처리하면서 읽는 순서대로 테이블을 나열한다. \r\n이 말은 MySQL이 첫번째 테이블에서 행을 읽고 두번째 테이블에서 매치되는 행을 찾은 다음, 세번째 테이블에서, 그리고 계속 그렇게 진행한다는 의미이다. \r\n\r\n\r\n\r\n## EXPLAIN 출력 컬럼\r\n\r\n`EXPLAIN`의 각 출력 행은 하나의 테이블에 대한 정보를 제공한다. 각 행은  아래 `표 1.1 EXPLAIN 출력 컬럼들` 에 요약된 값을 포함한다.\r\n테이블의 첫번째 컬럼에는 컬럼명, 두번째는 `FORMAT=JSON`이 사용될때 출력에서 보여지는 프로퍼티명을 제공한다.\r\n\r\n\r\n\r\n*표 1.1 EXPLAIN 출력 컬럼들*\r\n\r\n| 컬럼          | JSON 이름     | 의미                             |\r\n| ------------- | ------------- | -------------------------------- |\r\n| id            | select_id     | SELECT 식별자                    |\r\n| select_type   | 없음          | SELECT 타입                      |\r\n| table         | table_name    | 결과 행에 대한 테이블            |\r\n| partitions    | partitions    | 매칭되는 파티션                  |\r\n| type          | access_type   | JOIN 타입                        |\r\n| possible_keys | possible_keys | 선택에 사용가능한 index들        |\r\n| key           | key_length    | 선택된 키의 길이                 |\r\n| ref           | ref           | index에 비교되는 컬럼들          |\r\n| rows          | rows          | 조사될 예상행                    |\r\n| filtered      | filtered      | 테이블 조건에서 걸러진 행의 비율 |\r\n| extra         | 없음          | 추가 정보                        |\r\n\r\n\r\n\r\n### id (SELECT 순서)\r\n(JSON: selected_id)  \r\nSELECT 식별자이다. 쿼리 내에서 SELECT의 순서가 있는 숫자이며,  다른 행의 `UNION` 결과를 행이 참조한다면 값은 null일 수 있다. \r\n이 경우 테이블 컬럼은 id 값들의 M과 N인 행의 `UNION`에 행이 참조하는 행을 나타내기 위해, <union**M**,**N**> 같은 값을 보여준다.\r\n  \r\n\r\n### select_type (SELECT 타입)   \r\n(JSON: 없음)  \r\n아래 보여진 테이블중 어떤 `SELECT`의 타입이다. JSON-formatted EXPLAIN은  `SIMPLE`이나 `PRIMARY`가 아닌 한  `query_block`의 프로퍼티로 SELECT 타입을 노출한다.\r\n\r\n| select_type **값**   | JSON 이름                  | Meaning                                                      |\r\n| -------------------- | -------------------------- | ------------------------------------------------------------ |\r\n| SIMPLE               | 없음                       | 간단한 SELECT (UNION 또는 서브쿼리 사용 X)                   |\r\n| PRIMARY              | 없음                       | 가장 바깥쪽 SELECT                                           |\r\n| UNION                | 없음                       | UNION의 두번째 이상의 SELECT                                 |\r\n| DEPENDENT UNION      | dependent (true)           | 바깥쪽 쿼리에 의존되는 UNION에서 두번째 이상의 SELECT        |\r\n| UNION RESULT         | union_result               | UNION의 결과                                                 |\r\n| SUBQUERY             | 없음                       | 서브쿼리의 첫번째 SELECT                                     |\r\n| DEPENDENT SUBQUERY   | dependent (true)           | 바깥쪽 쿼리에 의존되는 서브쿼리의 첫번째 SELECT              |\r\n| DERIVED              | 없음                       | 파생된 테이블 (서브쿼리로 만들어진 임시테이블)               |\r\n| DEPENDENT DERIVED    | depentent (true)           | 또다른 테이블을 의존하는 파생된 테이블                       |\r\n| MATERIALIZED         | materialized_from_subquery | 서브쿼리로 물질화                                            |\r\n| UNCHAHEABLE SUBQUERY | cacheable (false)          | 바깥쪽 쿼리의 각  행에대해 결과가 캐시될수 없고 재 평가 되어아야하는 서브쿼리 |\r\n| UNCACHEABLE UNION    | cacheable (false)          | 캐시를 할 수 없는 서브쿼리에 속해있는 UNION 내 두번째 이상 SELECT |\r\n\r\n> `DEPENDENT`는 일반적으로 [상관관계 서브쿼리]() 사용을 의미한다.\r\n:{ \"type\": \"note\", \"icon\": \"info\"}\r\n\r\n### table (참조 테이블)\r\n(JSON: table_name)    \r\n출력행이 참조하는 테이블명이며, 다음 값중 하나가 될 수도 있다.\r\n* <union**M**, **N**>:  행은 **M** 과 **N**의 id 값을 갖는 행의 union을 합집합을 참조한다.\r\n* <deribed**N**>: 행은 **N**의 값을 갖는 행에 대한 파생된 테이블의 결과를 참조한다.  파생된 테이블은 예를들어 `FROM`절 내 서브쿼리에서 생성될 수도 있다.\r\n* <subquery**N**>: 행은 **N**의 id값을 갖는 행에대해 구체화된 서브쿼리(Materialized Subquery)의 결과를 참조한다.\r\n\r\n### partition (파티션)\r\n(JSON: partitions)  \r\n  쿼리로부터 매칭될수 있는 레코드에서의 파티션이다. 파티셔닝 되지않은 테이블에 대해서는 `NULL` 이다.\r\n\r\n### type (조인타입) \r\n(JSON: access_type)\r\n조인 타입이며, 테이블들을 어떻게 조인하는지 설명을 출력한다. JSON-formatted 출력에서는 acess_type의 속성 값으로 나온다. 다음에 목록은 조인타입을 좋은 케이스부터 안좋은케이스 순으로 설명한다.\r\n* system  \r\n  테이블이 한개의 로우(= 시스템 테이블)만 가지고있다. `const` 조인타입의 특별한 케이스이다.\r\n* const  \r\n테이블에 매칭되는 행이 최대 한개만 있으며, 이는 쿼리의 시작시 읽힌다. 오직 한개의 행만 있기 때문인데, 이 행의 열에 있는 값은 옵티마이저의 나머지 부분에서 상수로 간주될 수 있다. `const` 테이블은 한번만 읽히므로 매우빠르다.\r\n`const` 는`UNIQUE` 인덱스나 `PRIMARY KEY` 의 모든 부분을 상수값과 비교할때 시용된다.  다음 쿼리는  *tbl_name*이 상수 테이블로 사용될 수 있다.\r\n```sql\r\nSELECT * FROM tbl_name WHERE primary_key = 1;\r\n  \r\nSELECT * FROM tbl_name\r\n    WHERE primary_key_part1 = 1 AND primary_key_part2 = 2;\r\n```\r\n\r\n* eq_ref  \r\n이전 테이블에서 각 행 조합마다 이 테이블에서 한 행씩 읽는다. `system`과 `const` 타입을 제외하면 이게 제일 나은 조인타입이다.  조인에서 인덱스의 모든 부분을 사용하고,  인덱스가 `PRIMARY` 또는 `UNIQUE NOT NULL` 인덱스인 경우에 사용된다.\r\n`eq_ref`는 `=` 연산자를 사용하여 비교된 컬럼  인덱스에 사용될 수있다. 비교값은 상수가 될수 있고, 이 테이블보다 먼저 읽은 테이블의 열을 사용하는 표현식이 될 수도 있다. 다음의 예제에서 MySQL 은 *ref_table*를 처리하기위해 `eq_ref` 조인을 사용 할 수 있다.\r\n```sql\r\nSELECT * FROM ref_table,other_table\r\n  WHERE ref_table.key_column = other_table.column; //표현식 비교\r\n  \r\nSELECT * FROM ref_table, other_table\r\n  WHERE ref_table.key_column_part1 = other_table.column\r\n  AND ref_table.key_column_part2 = 1; //상수비교\r\n```\r\n\r\n* ref  \r\n이전 테이블의 행조합마다 일치하는 인덱스 값이 있는 모든행이 이 테이블에서 읽혀진다. 키의 가장왼쪽 접두어만 조인에 사용되거나 키가 `PRIMARY KEY` 또는 `UNIQUE`인덱스(즉, 키 값을 기준으로 조인이 단일행을 선택할 수 없는 경우)가 아닌경우에 `ref`가 사용된다.\r\n사용된 키가 몇개의 행에만 일치하는경우, 좋은 조인 타입이다.\r\n`ref` 는 `<=>`또는 `=` 연산자를 사용하여 비교된 인덱스들에 대해 사용될 수 있다. 다음의 예제에서 MySQL은 *ref_table* 처리에 `ref` 조인을 사용할 수 있다.  \r\n```sql\r\nSELECT * FROM ref_table WHERE key_column = expr; //여기서 expr은 다른 테이블에 대한 조건 표현식을 의미한다.\r\n  \r\nSELECT * FROM ref_table, other_table\r\n  WHERE ref_table.key_column = other_table.column;\r\n  \r\nSELECT * FROM ref_table,other_table\r\n  WHERE ref_table.key_column_part1 = other_table.column\r\n  AND ref_table.key_column_part2 = 1;\r\n```\r\n* fulltext  \r\n`FULLTEXT` 인덱스를 사용하여 수행된 조인이다.\r\n\r\n* ref_or_null  \r\n이 조인 타입은 `ref` 와 유사하지만, MySQL이 `NULL` 값을 포함하는 행들에 대해 추가 검색 수행한다는 점이 다르다. 이 조인 타입 최적화는 서브쿼리를 해결하는데 가장 자주 사용된다. 다음의 예제에서 MySQL은 *ref_table*을 처리에 `ref_or_null` 조인을 사용할 수 있다.\r\n```sql\r\nSELECT * FROM ref_table\r\n  WHERE key_column = expr OR key_column IS NULL;\r\n```\r\n* index_merge  \r\n이 조인 타입은 인덱스 병합 최적화가 사용되었다는 것을 나타 낸다. 이 경우, 출력행의 `key` 컬럼은 사용된 인덱스들의 목록을 포함하며  `key_len` 은 사용된 인덱스에 대한 가장긴 키부분 목록을 포함한다.\r\n\r\n* unique_subquery  \r\n이 타입은 다음 형식의 `IN` 서브쿼리이 대한 `eq_ref`를 대체한다.\r\n```sql\r\nvalue IN (SELECT primary_key FROM single_table WHERE some_expr)\r\n```\r\n`unique_subquery`는 완전히 더나은 효율성을 위해 서브쿼리를 완전히 대체하는 인덱스 조회 함수일 뿐이다.\r\n\r\n* index_subquery  \r\n이 조인 타입은 `unique_subquery`와 비슷하다. `IN` 서브쿼리를 대체하지만, 다음의 형식의 서브쿼리에서 유니크가 아닌 인덱스에 대해 동작한다.\r\n```sql\r\nvalue IN (SELECT key_column FROM single_table WHERE some_expr)\r\n```\r\n\r\n* range  \r\n주어진 범위에 있는 행들만 조회되며, 행 선택에 인덱스를 사용한다. 출력 행의 `key` 컬럼은 해당 인덱스가 사용됨을 나타낸다. `key_len` 컬럼은 사용된 가장긴 키부분을 포함한다. `ref`컬럼은 이 타입에대해 `NULL` 이다.\r\n`range`는 `key`컬럼이  `=, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, LIKE` 또는  `IN()` 연산자를 사용하여 비교되는 상수일 때 사용된다.\r\n```sql \r\nSELECT * FROM tbl_name\r\n  WHERE key_column = 10;\r\n  \r\nSELECT * FROM tbl_name\r\n  WHERE key_column BETWEEN 10 and 20;\r\n  \r\nSELECT * FROM tbl_name\r\n  WHERE key_column IN (10, 20, 30);\r\n  \r\nSELECT * FROM tbl_name\r\n  WHERE key_part1 = 10 AND key_part2 IN (10, 20, 30);\r\n```\r\n* index   \r\n`index` 조인 타입은 인덱스 트리 스캔 빼고 `ALL` 하고 같으며, 두가지 상황에서 발생한다.\r\n* 인덱스가 쿼리에 대한 커버링 인덱스 이고,  테이블에서 필요한 모든 데이터를 충족하는 데 사용할 수 있는 경우 인덱스 트리만 스캔된다. 이 경우 `Extra` 컬럼은 `Using Index`라고 나온다. 보통 인덱스 전용 스캔은 일반적으로 인덱스 사이즈가 테이블 데이터보다 작기떄문에, `ALL`보다 빠르다.\r\n* 풀 스캔은 인덱스에서 읽어서 인덱스 순서대로 데이터 행을 조회하여 수행된다.  `Extra` 컬럼이 에는 인덱스 사용이 나오지 않는다.\r\nMySQL은 쿼리가 단일인덱스의 일부인 컬럼만 사용하는 경우, 이 조인타입을 사용할 수있다.\r\n\r\n* ALL  \r\n풀스캔은 이전 테이블의 행 조합 마다 수행된다. 테이블이 `const`로 표시되지않은 첫번째 테이블인 경우 일반적으로 좋지 않으며, 다른 모든 경우에는 *매우* 나쁘다. 보통은, 이전테이블의 상수값 이나 컬럼값을 기준으로 테이블에서 행을 검색할 수있는 인덱스를 추가하면 `ALL` 타입을 피할 수 있다.\r\n\r\n### possible_kyes (사용가능한 인덱스)\r\n(JSON: possible_keys)    \r\n`possible_keys` 컬럼은 MySQL이 이 테이블에서 행을 찾기위해 선택할 수 있는 인덱스들을 나타낸다. 참고로 이 컬럼은 `EXPLAIN`의 출력에 표시된 테이블들의 순서와 별개입니다. 이 말은 테이블 순서 생성된 실행에서  `possible_keys`에 어떤 키들은 사용될수 없을 수도 있다는 의미이다.\r\n이 컬럼이 `NULL`이라면, 적절한 인덱스가 없다는 뜻이다. 이 경우 인덱싱에 적합한 컬럼을 참조하는지 확인하기위해 `WHERE` 절을 검사사여 쿼리의 성능을 개선할 수 있다. 적절한 인덱스를 생성하고 `EXPLAIN` 쿼리를 확인해보자.\r\nSHOW INDEX FROM  *table_name* 으로 테이블 인덱스를 볼수 있다.\r\n\r\n### key (사용할 인덱스)\r\n(JSON: key)  \r\n`key`  컬럼은 MySQL이 사용하기로 정한 키(인덱스)를 나타냅니다. MySQL이 행조회에 `possible_keys` 인덱스들중 중 한개를 사용하기로 정했다면, 인덱스는 키값으로 나열된다.\r\n`key` 는 `possible_keys` 값에 없는 인덱스를 지정할 수도 있다.  이는 `possible_keys` 인덱스중 어느행도 조회되는데 적합하지 않지만, 쿼리의 선택된 모든 컬럼이 다른 인덱스의 컬럼인경우 발생할 수 있다. 즉, 지정된 인덱스가 선택된 컬럼들을 포함하고 있기때문에, 어느행을 검색할지를 결정하는 데는 사용되지 않더라도 인덱스 스캔은 데이터 행 스캔보다 효율적이다. (*이 내용은 \"커버링 인덱스\"의 효율성에 대한 내용이다.*)\r\n`InnoDB`의 경우 쿼리에서 기본키를 선택하더라도 보조 인덱스가 선택한 열을 포함할 수 있다. 이는 `InnoDB`가 각 보조인덱스에 기본 키 값을 저장하기 때문이다. `key`컬럼이 `NULL`이라면, `MySQL`은 쿼리를 보다 효율적으로 실행하는데 사용할 인덱스를 찾지 못한다.\r\n![보조 인덱스의 기본키 값]()\r\n`MySQL`이 `possible_keys` 컬럼 내 있는 인덱스를 강제로 사용하거나 무시하게 하려면, 쿼리에서 `FORCE_INDEX`, `USE_INDEX` 또는 `IGNORE_INDEX`를 사용하면 된다.\r\n\r\n### key_len (키의 길이) \r\n(JSON: key_length)    \r\n`key_len` 컬럼은 `MySQL`이 사용하기로 결정한 키의 길이를 나타낸다. `key_len`의 값은 MySQL이 실제로 사용하는 복합키의 일부가 얼마나 되는지 확인 할수 있게 해준다. \r\n실제 표시되는 값은 사용된 키의 바이트 길이를 나타내여 사용하는 유니코드마다 다를수 있다. (*실제로 사용하는 복합키의 일부의 의미는 쿼리에 따라 첫번째 컬럼만 사용할 수도 있고, 두번째 컬럼까지 사용할 수 있다는 의미이다.*)\r\n키 저장 포맷으로 인해, `NULL`이 될수 있는 컬럼의 키 길이는 `NOT NULL`인 컬럼의 길이보다 1이 크다. (*NULL을 구분할 비트가 추가되기 때문에*)\r\n\r\n### ref (참조 값)\r\n(JSON: ref)\r\n`ref`컬럼은 테이블에서 `key` 컬럼 내 어떤 컬럼이나 제약이 지정된 인덱스와 비교되었는지 보여줍니다.\r\n값이 `func`라면, 사용된 값은 어떤 함수의 결과입니다. 어떤 함수인지 확인하려면, 확장된 `EXPLAIN`결과를 보기위해 `EXPLAIN`뒤에 `SHOW WARNINGS`를 사용하면 된다. \r\n함수는 실제로 산술 연산자 같은 연산자 일 수 있다.\r\n\r\n### rows (검사 행 개수)\r\n(JSON: rows)    \r\n`rows`  컬럼은 `MySQL`이 쿼리 실행 검사를 해야만 한다고 여기는 행들의 개수를 나타낸다. `InnoDB` 테이블의 경우, 이 값은 예측치이며, 항상 정확하지 않을 수도 있다.\r\n\r\n### filtered (필터된 수치) \r\n(JSON: filtered)\r\n`filtered` 컬럼은 테이블 조건으로 필터된 테이블 행들의 예상 백분률을 나타낸다. \r\n최대 값은 100이며, 이는 행의 필터링이 발생되지않음을 의미한다. 100에서 감소된 값은 필터링 양이 증가함을 나타낸다. \r\n`rows` 는 검된 행의 예상치를 보여주고`rows` × `filtered`는 다음 테이블로 조인된 행의 갯수를 보여준다. 예를들어, `rows`가 1000이고 `filtered`가 50.00(50%)라면, 다음 테이블로 조인된 행의 개수는 1000 × 50% = 500이다.\r\n\r\n### Extra ()\r\n(JSON: 없음)\r\n이컬럼은  `MySQL`이 쿼리를 어떻게 해결하는지에 대한 추가적인 정보를 포함한다. 다른 값의 설명들은 `EXPLAIN` [Extra 정보]()을 보자.\r\n\r\n`Extra`컬럼에 해당하는 단일 JSON 속성 값은 따로 없지만, 이 컬럼 내에서 발생될수 있는 값들은 JSON 속성이나 `message` 속성의 텍스트로 노출된다.\r\n쿼리를 빠르게 만들고 싶다면, `Using filesort`와 `Using temporary`의 `Extra` 컬럼값을 조심하자. JSON 형식에서는 `using_filesort`와 `using_temporary_table` 값이 `true`와 같다.\r\n\r\n* Zero limit  \r\n쿼리에 `LIMIT 0`절이있고 어떤 행도 선택할 수 없는 경우이다.\r\n\r\n* Using Where with pushed condition\r\n이 항목은 [NDB]() 테이블들에만 적용된다.\r\n\r\n* Using Where\r\n`WHERE`절은 \r\n"
  },
  {
    "path": "/docs/computer/interrupts",
    "header": {
      "layout": "wiki",
      "title": "CPU와 인터럽트",
      "categories": [
        "computer"
      ],
      "tags": [
        "Operating System",
        "Interrupt"
      ],
      "date": 1610544780000,
      "current-company": "Cubic INC",
      "current-position": "SI Researcher",
      "summary": "인터럽트란?",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "computer"
      ],
      "images": [
        {
          "src": "/post/computer/move-unit.png",
          "alt": "캐릭터의 이동"
        }
      ],
      "headlines": {
        "grade": 0,
        "title": "root",
        "fragmentId": "root",
        "children": [
          {
            "grade": 2,
            "title": "인터럽트는 무엇인가?",
            "fragmentId": "%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F",
            "children": [],
            "isSelected": false
          },
          {
            "grade": 2,
            "title": "인터럽트 서비스 루틴",
            "fragmentId": "%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%A3%A8%ED%8B%B4",
            "children": [],
            "isSelected": false
          },
          {
            "grade": 2,
            "title": "인터럽트의 매커니즘",
            "fragmentId": "%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%9D%98-%EB%A7%A4%EC%BB%A4%EB%8B%88%EC%A6%98",
            "children": [],
            "isSelected": false
          }
        ],
        "isSelected": false
      }
    },
    "description": "",
    "content": "\n## 인터럽트는 무엇인가?\n\ninterrupt `[ˌɪntəˈrʌpt]`\n1. (말·행동을) 방해하다[중단시키다/가로막다]\n2. (무엇을 잠깐) 중단시키다\n\n사전 상의 `interrupt`(이하 인터럽트)는 위와 같은 어떤 행동이나 흐름을 중단시키는 의미로 등재 되어있다.\n컴퓨터에서도 인터럽트는 어떤 흐름을 중지하는 역할을 한다.\n\n[CPU]()는 순차적으로 명령어를 처리한다. 하지만 예상치못하거나 긴급한상황에 의도적으로 특별한 처리를 해야한다.\n예를 들어 스타크래프트나 리그오브레전드처럼 3인칭시점에서 마우스로 지면을 클릭하는 경우, 해당위치로 캐릭터가 이동한다.\n이 경우 이동이 끝나지 않아도, 우리는 새로운 위치를 클릭하여 방향을 바꿀수도있다. \n\n![캐릭터의 이동](/post/computer/move-unit.png)\n:{ \"max-width\": \"300px\", \"description\": \"눈꽃시비르의 방향을 조작하는 프로겐 선수\" }\n\n이 처럼 CPU가 명령을 실행하는중에도 긴급하거나, 실시간 처리가 필요한경우 IRQ를 통해, CPU에 인터럽트 신호를 보내 우선적으로 처리를 수행할 수 있다.\n\n> **I**nterrupt **R**e**Q**uest Line는 인터럽트 요청을 받을수있는 인터럽트 버스이다 이는 하드웨어에서 각 장치까지 물리적으로 연결된 신호선이다.\n:{ \"type\": \"note\", \"icon\": \"info\"}\n\n## 인터럽트 서비스 루틴\n\n**I**nterrupt **S**ervice **R**outine (이하 ISR)은 다른말로 Interrupt Handler(인터럽트 핸들러)라고도 한다.\n`ISR`은 인터럽트를 처리하기위한 어떤 일련의 프로세스이다. `IRQ`를 통해 `CPU`로 인터럽트 신호를 보내면(CPU의 인터럽트), CPU는 하던 일을 중단하고 ISR이 있는 주소로 실행을 옮긴다.\n그리고 `ISR`이 실행된후 다시 원래 연산을 재개한다. ISR은 인터럽트 번호 테이블로 구성되어있다. 이는 시스템마다 다를수 있고 콜백루틴 방식으로 처리된다.\n\n인터럽트 원인에 따라 처리되는 ISR이 별도로 있으며,이는 [커널(kernel)]()에 존재한다. \n인터럽트가 발생되는 원인은 일반적으로 `하드웨어 리셋`, `정해진 메모리 외부 참조`, `0으로 나누기` 등 여러 예외가 존재한다.\n\n인터럽트가 발생하면 `ISR`의 주소를 Interrupt Vector(이하 인터럽트 벡터)라고 하는 배열을 인터럽트 요청과 함께 장치 고유번호로 인덱싱한다.\n또한 `CPU`는 현재 실행 중이던 작업을 중단하고 `ISR`을 실행해야하기 때문에 실행중인 작업의 레지스터 값들을 스택에 저장하여 상태를 보존한다.\n이러한 값들에는 [프로그램 카운터(이하 PC)](), [스택 포인터]() 등 범용 레지스터 들이 포함된다. \n\n`ISR`이 실행되는 동안에는 프로세서의 레지스터 값을 변경할수 있기때문에, `ISR`이 끝나기전에 스택에 저장해 두었던 레지스터 값들을 다시 복원 하여 CPU가 인터럽트 발생 전 상태로 되돌아 갈수 있게 레지스터 값을 원복한다.\n`ISR`실행 후 인터럽트 요청에서 받았았던 복귀 주소를 `PC`로 적재하여 인터럽트 발생시점부터 실행을 옮겨 중단되었던 연산을 다시 시작한다.\n\n## 인터럽트의 매커니즘\n\n인터럽트는 CPU연산 중 신호를 받아 `ISR`을 실행한다고 하였다. 하지만 컴퓨터는 동기순차회로이기 때문에 순차적으로 연산이 이루어져야 한다.\n때문에, CPU가 하나의 명령어 실행이 완료될 때마다 IRQ를 감지하여 인터럽트 번호를 읽어 이 번호를 인터럽트 벡터의 인덱스로 사용하고, `ISR`로 점프하여 인덱스와 관련된 주소에서 실행을 시작한다.\n인터럽트 처리후 복원까지 수행하면 `return_from_interrupt` 명령어로 CPU를 인터럽트 전 실행상태로 되돌린다.\n\n\n"
  }
]