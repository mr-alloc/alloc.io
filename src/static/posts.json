[
  {
    "path": "/wiki/interrupt",
    "header": {
      "layout": "wiki",
      "title": "CPU와 인터럽트",
      "tags": [
        "Operating System",
        "Interrupt"
      ],
      "summary": "Interrupt",
      "hide": false,
      "date": 1999999999999,
      "breadcrumbs": [
        "문서",
        "컴퓨터"
      ],
      "images": [
        {
          "src": "/post/computer/move-unit.png",
          "alt": "캐릭터의 이동"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "인터럽트는 무엇인가?::what-is-interrupt",
            "title": "인터럽트는 무엇인가?",
            "fragment": "what-is-interrupt",
            "children": []
          },
          {
            "rank": 2,
            "origin": "인터럽트 서비스 루틴::interrupt-service-routine",
            "title": "인터럽트 서비스 루틴",
            "fragment": "interrupt-service-routine",
            "children": []
          },
          {
            "rank": 2,
            "origin": "인터럽트의 매커니즘::mechanism-of-interrupt",
            "title": "인터럽트의 매커니즘",
            "fragment": "mechanism-of-interrupt",
            "children": []
          },
          {
            "rank": 2,
            "origin": "타이머::timer",
            "title": "타이머",
            "fragment": "timer",
            "children": []
          }
        ]
      }
    },
    "description": "",
    "content": "\n## 인터럽트는 무엇인가?::what-is-interrupt\n\ninterrupt `[ˌɪntəˈrʌpt]`\n1. (말·행동을) 방해하다[중단시키다/가로막다]\n2. (무엇을 잠깐) 중단시키다\n\n사전 상의 `interrupt`(이하 인터럽트)는 위와 같은 어떤 행동이나 흐름을 중단시키는 의미로 등재 되어있다.\n컴퓨터에서도 인터럽트는 어떤 흐름을 중지하는 역할을 한다.\n\n[CPU](/wiki/central-processing-unit)는 순차적으로 명령어를 처리한다. 하지만 예상치못하거나 긴급한상황에 의도적으로 특별한 처리를 해야한다.\n예를 들어 스타크래프트나 리그오브레전드처럼 3인칭시점에서 마우스로 지면을 클릭하는 경우, 해당위치로 캐릭터가 이동한다.\n이 경우 이동이 끝나지 않아도, 우리는 새로운 위치를 클릭하여 방향을 바꿀수도있다. \n\n![캐릭터의 이동](/post/computer/move-unit.png)\n:{ \"align\": \"center\", \"max-width\": \"300px\", \"description\": \"눈꽃 시비르의 방향을 조작하는 프로겐 선수\" }\n\n이 처럼 CPU가 명령을 실행하는중에도 긴급하거나, 실시간 처리가 필요한경우 IRQ를 통해, CPU에 인터럽트 신호를 보내 우선적으로 처리를 수행할 수 있다.\n\n> **I**nterrupt **R**e**Q**uest Line는 인터럽트 요청을 받을수있는 인터럽트 버스이다 이는 하드웨어에서 각 장치까지 물리적으로 연결된 신호선이다.\n:{ \"type\": \"note\", \"icon\": \"info\"}\n\n## 인터럽트 서비스 루틴::interrupt-service-routine\n\n**I**nterrupt **S**ervice **R**outine (이하 ISR)은 다른말로 Interrupt Handler(인터럽트 핸들러)라고도 한다.\n`ISR`은 인터럽트를 처리하기위한 어떤 일련의 프로세스이다. `IRQ`를 통해 `CPU`로 인터럽트 신호를 보내면(CPU의 인터럽트), CPU는 하던 일을 중단하고 ISR이 있는 주소로 실행을 옮긴다.\n그리고 `ISR`이 실행된후 다시 원래 연산을 재개한다. ISR은 인터럽트 번호 테이블로 구성되어있다. 이는 시스템마다 다를수 있고 콜백루틴 방식으로 처리된다.\n\n인터럽트 원인에 따라 처리되는 ISR이 별도로 있으며,이는 [커널(kernel)]()에 존재한다. \n인터럽트가 발생되는 원인은 일반적으로 `하드웨어 리셋`, `정해진 메모리 외부 참조`, `0으로 나누기` 등 여러 예외가 존재한다.\n\n인터럽트가 발생(*raise*)하면 `ISR`의 주소를 Interrupt Vector(이하 인터럽트 벡터)라고 하는 배열을 인터럽트 요청과 함께 장치 고유번호로 인덱싱한다.\n또한 `CPU`는 인터럽트를 포착(*catch*)하면 현재 실행 중이던 작업을 중단하고 `ISR`로 전송(*dispatch*)하면 루틴을 실행해야하기 때문에 실행중인 작업의 레지스터 값들을 스택에 저장하여 상태를 보존한다.\n이러한 값들에는 [프로그램 카운터(이하 PC)](), [스택 포인터]() 등 범용 레지스터 들이 포함된다. \n\n| 벡터 번호  | 설명                 |\n|--------|--------------------|\n| 0      | 나눗셈 에러             |\n| 1      | 디버그 예외             |\n| 2      | Null 인터럽터          |\n| ...    |\n| 18     | 기기 검사              |\n| 19~31  | (Intel에서 예약, 사용금지) |\n| 32~255 | Maskale 인터럽트       |\n:{ \"description\": \"표 1: Intel Processor 이벤트-벡터\", \"align\": \"center\" }\n\n`ISR`이 실행되는 동안에는 프로세서의 레지스터 값을 변경할수 있기때문에, `ISR`이 끝나기전에 인터럽트를 지우고(*clear*) 스택에 저장해 두었던 레지스터 값들을 다시 복원 하여 CPU가 인터럽트 발생 전 상태로 되돌아 갈수 있게 레지스터 값을 원복한다.\n`ISR`실행 후 인터럽트 요청에서 받았았던 복귀 주소를 `PC`로 적재하여 인터럽트 발생시점부터 실행을 옮겨 중단되었던 연산을 다시 시작한다.\n\n실제로는 인터럽트 벡터의 주소 개수보다 많은 장치가 있기 때문에, `인터럽트 체인` 방식을 사용한다.   \n이는 벡터의 각 요소를 핸들럭 목록을 체인으로 묶어, 처리할수 있는 핸들러를 찾을 떄까지 하나씩 호출하는 방법이다.\n\n위에서 `표1`에서 0~31까지는 각 루틴에 대한 마스킹이 이미 되어있기때문에 `Non Maskable Interrupt`라고 하며 예약된 루틴이고, 32부터는 Maskable 이므로 그외 인터럽트를 처리하기 위해 사용된다.\n\n> 인터럽트 우선순위 레벨 (Interrupt Priority Level *이하 `IPL`)  \n> `IPL`은 인터럽트 별로 우선 순위를 정하여, 인터럽트 처리에도 우선순위를 둘 수 있다.  \n> `IPL`은 순위에 따라 처리를 연기하거나, 순위가 더높은 인터럽트가 실행을 선점 할 수 도있다.  \n: { \"type\": \"note\", \"icon\": \"info\" }\n\n\n## 인터럽트의 매커니즘::mechanism-of-interrupt\n\n인터럽트는 CPU연산 중 신호를 받아 `ISR`을 실행한다고 하였다. 하지만 컴퓨터는 동기순차회로이기 때문에 순차적으로 연산이 이루어져야 한다.\n때문에, CPU가 하나의 명령어 실행이 완료될 때마다 IRQ를 감지하여 인터럽트 번호를 읽어 이 번호를 인터럽트 벡터의 인덱스로 사용하고, `ISR`로 점프하여 인덱스와 관련된 주소에서 실행을 시작한다.\n인터럽트 처리후 복원까지 수행하면 `return_from_interrupt` 명령어로 CPU를 인터럽트 전 실행상태로 되돌린다.\n\n> 폴링 (Polling)  \n> CPU가 주기적으로 장치의 상태를 직접확인하고, 상태에따라 처리하는 방식이다.  \n> 이는 장치컨트롤러와 연관이이 있는데, CPU와 병렬로 실행되는 장치컨트롤러는 내부의 로컬버퍼와 장치간 데이터의 전송을 담당한다.  \n> 장치에서 입력이있다면, 로컬버퍼로 데이터를 이동시키고 상태 레지스터의 값을 변경한다. 여기서 CPU는 장치컨트롤러의 상태 레지스터를 주기적으로 확인하여, 상태가 변경되었는지 확인하며 로컬버퍼의 데이터를 읽어와 처리한다.  \n> 이러한 방식은 CPU가 주기적으로 장치의 상태를 확인하기 때문에, CPU의 부하가 높아지고, 실시간 처리에 적합하지 않다. 이때 전송하는 빈도를 폴링 레이트라고한다.  폴링레이트가 높을때 입력이 많은경우 CPU의 부하가 높아지는 이유가 이것 때문이다.  \n:{ \"icon\": \"warning-diamond\", \"type\": \"warning\" }\n\n## 타이머::timer\n\n타이머는 설정한 시간이 지났을때 인터럽트를 발생시킬수 있는 장치이다. \n예컨데 사용자 프로그램이 무한루프에 빠지거나, 시스템 서비스 호출에 실패하여, 제어가 운영체제로 복귀하지않는 경우에를 대비해 설정할 수 있다.\n\n대표 적인 예가 [DMA](/wiki/direct-memory-access)이다. DMA는 CPU의 개입없이 메모리와 I/O장치간 데이터를 전송하는 기술이다.\nDMAC이 입출력 장치간 데이터 전송을 관장하는경우 데이터 버스에 대한 제어권를 얻게 되는데, CPU가 제어권을 넘기는 시점에 타이머를 설정하여, 지정된 시간까지 DMA가 모두 이루어지지 않는 경우 인터럽트를 발생시킨다. \n"
  },
  {
    "path": "/wiki/central-processing-unit",
    "header": {
      "layout": "wiki",
      "title": "중앙처리장치 (CPU)",
      "tags": [
        "Hardware",
        "CPU"
      ],
      "summary": "CPU",
      "hide": false,
      "date": 1999999999999,
      "breadcrumbs": [
        "문서",
        "컴퓨터",
        "하드웨어"
      ],
      "images": [
        {
          "src": "/post/computer/multicore-processor.png",
          "alt": "멀티코어 프로세서"
        },
        {
          "src": "/post/computer/cpu-core-structure.png",
          "alt": "CPU 코어"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "CPU란?::what-is-cpu",
            "title": "CPU란?",
            "fragment": "what-is-cpu",
            "children": []
          },
          {
            "rank": 2,
            "origin": "Core의 구조::core-structure",
            "title": "Core의 구조",
            "fragment": "core-structure",
            "children": [
              {
                "rank": 3,
                "origin": "Control Unit (제어장치)::control-unit",
                "title": "Control Unit (제어장치)",
                "fragment": "control-unit",
                "children": []
              },
              {
                "rank": 3,
                "origin": "Data Processing Unit (처리장치)::data-processing-unit",
                "title": "Data Processing Unit (처리장치)",
                "fragment": "data-processing-unit",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "",
    "content": "\n## CPU란?::what-is-cpu\n\n**C**entral **P**rocessing **U**nit (이하 `CPU`)는 컴퓨터의 모든 연산을 실행하거나 처리하는 핵심적인 제어장치이며 `중앙처리장치`라고도 말한다. \n컴퓨터에 필수적인 4대 주요기능(`기억`, `해석`, `연산`, `제어`)을 관리하는 가장 중요한 장치이다.\n1\n처리기, 프로세서 등 여러 이름이 있으며 컴퓨터에 따라 한개 또는 그 이상의 장치가 들어간다. 일반적으로는 프로세서 칩 한개를 의미 하지만, 엔지니어 입장에서는 몇개가 존재하든 처리를 하는 역할은 변하지 않기에 프로세서라고 그냥 말 할 수 도 있다.  \n\n![멀티코어 프로세서](/post/computer/multicore-processor.png)\n:{ \"max-width\": \"300px\", \"align\": \"center\", \"description\": \"멀티코어는 하나의 칩에 두개 이상의 코어를 가지는 설계를 의미한다.\" }\n\nCPU의 코어는 실질적으로 연산을 수행하는 장치이다. 코어 내에는 연산하는 과정에서 임시로 적제할 여러 레지스터를 갖고 있다.\n제조사별로 [캐시메모리]() 구조가 다르지만, 왼쪽의 경우는 `L2 캐시`는 프로세서 내에서 공유가 가능하다.  \n\n때문에 `Level 1 캐시(이하 L1)`에는 접근이 매우 빠르지만 반대로 L2는 경합으로 인해 접근에 대한 [클럭]() 동기화로 시스템 시간을 맞추어 순차적인 접근이 필요하기 때문에 `L1`에 비해 느리다.\n코어별로 `L2`를 내장하고 있는 CPU도 있고, L2 부터 공유하는 CPU도 있다.\n\n[인텔의 메모리 성능 요약](https://www.intel.com/content/www/us/en/developer/articles/technical/memory-performance-in-a-nutshell.html)에 따르면 간단한 차이는 아래와 같다.\n\n| 메모리      | 크기    | 시간     | 대역폭    |\n|----------|-------|--------|--------|\n| L1 cache | 32KB  | 1ns    | 1TB/s  |\n| L2 cache | 256KB | 4ns    | 1TB/s  |\n| L3 cache | 8MB < | 40ns < | 400GB/s | \n:{ \"align\": \"center\", \"description\": \"인텔 캐시메모리의 성능 비교표\" }\n\n## Core의 구조::core-structure\n\n![CPU 코어](/post/computer/cpu-core-structure.png)\n:{ \"align\": \"center\", \"max-width\": \"500px\", \"description\": \"중앙처리장치의 코어 구조\" }\n\nCPU Core 안에서는 크게 제어장치와 처리장치 두가지로 나뉜다.\n\n### Control Unit (제어장치)::control-unit\n\n제어장치는 `CPU`와 다른 주변 장치와의 데이터 흐름을 제어하며, 각 장치로 제어신호를 보내어 명령어를 실행하도록 한다.\nCPU의 [명령어 사이클]()을 제어하며, 명령어를 해독하고 실행하는 역할을 한다.\n\n**제어 장치에 속하는 대표적인 구성요소**\n\n1. [명령어 디코더 (Instruction Decoder)]()\n    * 명령어를 해독하고, 필요한 작업을 결정한다.\n2. [제어 신호 생성기 (Control Signal Generator)]()\n    * 명령어를 해독한 결과에 따라 제어 신호를 생성한다.\n3. [인터럽트 컨트롤러 (Interrupt Controller)]()\n    * 인터럽트가 발생하면, 해당 인터럽트를 처리한다.\n4. [클럭 발생기 (Clock Generator)]()\n    * CPU의 클럭을 생성한다.\n5. [타이밍 신호 발생기 (Timing Signal Generator)]()\n    * 클럭 발생기로 부터 주기신호를 받아 작업 흐름을 나눈다.\n6. [명령어 사이클 제어기 (Instruction Cycle Controller)]()\n    * 타이밍 신호를 받아 명령어 실행 순서를 관리한다.\n\n### Data Processing Unit (처리장치)::data-processing-unit\n\n처리장치는 제어장치가 명령어를 해독하고, 실행할 작업을 결정하면, 실제로 데이터를 처리하는 장치이다.\n\n**제어 장치에 속하는 대표적인 구성요소**\n\n1. [산술 논리 연산 장치 (Arithmetic And Logical Unit)]()\n    * 산술(사칙: +, −, ✕, ÷)연산과 논리(AND, OR, NOT 등)연산을 처리한다.\n2. [부동소수점 연산 장치 (Floating Point Unit)]()\n    * 실수 데이터 연산을 처리한다.\n3. [레지스터 (Register)]()\n    * 데이터를 저장하고, 연산에 필요한 데이터를 임시로 저장한다.\n4. [캐시 메모리 (Cache Memory)]()\n    * 데이터를 빠르게 접근하기 위한 임시 저장소이다.\n5. [파이프 라인 (Pipeline)]()\n    * 명령어를 여러 단계로 나누어 병렬로 처리한다.\n"
  },
  {
    "path": "/wiki/direct-memory-access",
    "header": {
      "layout": "wiki",
      "title": "Direct Memory Access (DMA)",
      "tags": [
        "Hardware",
        "DMAC",
        "Direct Memory Access Controller"
      ],
      "summary": "DMA",
      "hide": false,
      "date": 1999999999999,
      "breadcrumbs": [
        "문서",
        "컴퓨터",
        "하드웨어"
      ],
      "images": [
        {
          "src": "/post/computer/data-transfer-between-memory-and-io-device.png",
          "alt": "메모리와 I/O 장치간의 데이터 전송"
        },
        {
          "src": "/post/computer/dma-request.png",
          "alt": "DMA 요청"
        },
        {
          "src": "/post/computer/cpu-and-io-devices.png",
          "alt": "시스템버스로 연결되어 있는 각 장치들"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "DMA란 무엇인가?::what-is-dma",
            "title": "DMA란 무엇인가?",
            "fragment": "what-is-dma",
            "children": []
          },
          {
            "rank": 2,
            "origin": "DMA는 어떻게 사용되는가?::how-dma-used-for",
            "title": "DMA는 어떻게 사용되는가?",
            "fragment": "how-dma-used-for",
            "children": [
              {
                "rank": 3,
                "origin": "DMA 동작 순서::sequence-of-dma",
                "title": "DMA 동작 순서",
                "fragment": "sequence-of-dma",
                "children": []
              },
              {
                "rank": 3,
                "origin": "DMA 동작모드::mode-of-dma",
                "title": "DMA 동작모드",
                "fragment": "mode-of-dma",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "",
    "content": "\n## DMA란 무엇인가?::what-is-dma\n\nDMA는 `IO 장치`와 `메모리`간의 데이터 전송을 위한 기술이다.\n\n정확히는 모든 I/O장치는 아니고, 대용량 데이터 전송을 목적으로 하는 하드웨어와 연결되어있다.  \n저장 장치의 경우 `HDD/SSD`, `CD/DVD` 그리고 멀티미디어의 경우 `그래픽 카드(GPU)`, `사운드 카드` 등이 있다.\n\n[`PIO`](/wiki/programmed-io)방식에서는 [CPU](/wiki/central-processing-unit)가 데이터를 한 워드 또는 바이트마다 전송하기 때문에, 속도가 빠른 **I/O 장치**의 경우 CPU의 실제 프로세스 작업 시간을 줄여 다른 작업을 수행하는데 방해가된다.  \n이를 해결하기위해 등장한 DMA 기술은 `I/O 장치에서 메모리`로 또는 `메모리에서 I/O 장치`로 데이터를 CPU의 개입없이 전송하여 CPU의 부담을 줄여준다.\n\n![메모리와 I/O 장치간의 데이터 전송](/post/computer/data-transfer-between-memory-and-io-device.png)\n:{ \"max-width\": \"400px\", \"align\": \"center\", \"wrapper-class\": \"justify-center\", \"description\": \"메모리와 I/O 장치간의 데이터 전송\" }\n\n## DMA는 어떻게 사용되는가?::how-dma-used-for\n\n**D**irect **M**emory **A**cess **C**ontroller (이하 `DMAC`)는 하드웨어 장치로서, [메모리]() 입출력 장치간의 데이터 전송을 DMA 기술로서 관리하는 장치이다.\n\n\n### DMA 동작 순서::sequence-of-dma\n\n장치 A에서 장치 B로 `DMA` 요청이 들어왔다는 가정하에, 순서를 설명하자면 다음과 같다.\n\n1. 장치 컨트롤러는 `DMAC`과 물리적으로 연결 되어있는 신호선에  DMA Request(`DMA 요청`)을 보낸 후 `DMAC`에서 요청을 받아들이면, 장치 컨트롤러로 DMA Acknowledge(`DMA 승인`) 신호를 보낸다.\n\n   ![DMA 요청](/post/computer/dma-request.png)\n   :{ \"max-width\": \"400px\", \"align\": \"center\", \"description\": \"장치 컨트롤러의 DMA 요청\" }\n\n2. 데이터를 전송하기 전에 각 장치에 명령을 전달한다.\n\n   * 데이터를 읽기위해 디스크 컨트롤러로 `주소 신호`(컨트롤러로 부터 전달받은 읽을 로컬버퍼 주소)와 `제어 신호` (읽기 명령)을 보낸다.  \n   또한 메모리에는 `주소 신호`(전달받은 메모리에 쓰기 주소)와 `제어신호`(쓰기 명령)을 보내면 데이터를 전송할 준비가 완료 된다.\n\n3. `DMAC`는 데이터를 전송할 시스템 버스의 소유권을 얻기위해 CPU에게 제어 버스로 `Bus Request(BR)` 신호를 전송한다. CPU는 `Bus Grant`신호를 전송하여 버스 사용을 허가한다.\n\n   ![시스템버스로 연결되어 있는 각 장치들](/post/computer/cpu-and-io-devices.png)\n   :{ \"max-width\": \"400px\", \"align\": \"center\", \"description\": \"시스템 버스와 연결된 각 장치들\" }\n\n   * 실제로는 I/O 장치의 컨트롤러와 연결되어 있으며, `BR`과 `BG` 모두 제어버스를 통해 전달된다. 각 장치마다 데이터를 준비하는 과정이 다르긴 하지만, 장치 A(HDD)에서 장치 B(RAM)으로 데이터를 전송하는 과정에서 데이터를 준비는 다음과 같다.\n   먼저 `CPU`가 디스크 읽기요청을 하드디스크 [드라이버]()로 전송한다. 이때 디스크의 읽을 섹터번호([LBA]()) 와 읽을 양, 쓰기가 필요한 메모리 주소 등을 전달한다.  \n\n   * 디스크 드라이버는 전달받은 정보를 이용해 데이터를 읽고, 디스크 컨트롤러 로컬버퍼에 데이터를 임시로 저장한다. 그리고 데이터를 읽을준비가 완료되면, `DMAC`으로 `DMA 요청`을 전송한다.\n   `DMAC`은 시스템 제어를 위해 `CPU`에게 `BR`을 보내고, `CPU`는 `BG`를 보낼어 제어 승인을 하며, 타임아웃을 정하여 [타이머](/wiki/interrupt#timer)를 설정한다. \n\n   > 만약 타임아웃이 발생한다면 타이머는 인터럽트를 발생시켜 CPU에게 알린다.\n   :{ \"type\": \"caution\", \"icon\": \"warning-octagon\" }  \n\n   * `BG`를 받는 경우 즉시 회로가 연결되어 시스템버스의 소켓특성으로 데이터가 전달된다.\n\n4. 데이터 전송제어를 모두 마친 `DMAC`은 `CPU`에게 시스템 버스의 소유권을 반환한다.\n   * 이 경우 [인터럽트](/wiki/interrupt)를 발생시켜 CPU에 작업완료를 알려 버스소유권을 반납한다. \n\n### DMA 동작모드::mode-of-dma\n\n**사이클 스틸링(Cycle Stealing)**\n\n`Cycle Stealing(이하 CS)`는 데이터를 Word 단위로 전송한다. 작은 단위의 데이터를 전송할 때 워드단위로 처리되기 때문에, 잦은 인터럽트가 발생된다.\n따라서 DMA에 의한 인터럽트로 CPU `Cycle`을 훔치게 된다. (실제로 옛날의 컴퓨터 구조에서는 DMA 사용시 회로를 막아버림으로써 `Cycle`을 훔쳤다.) \n\n**버스트 모드(Bust mode)**\n\n`Bust Mode`는 더큰 데이터를 DMA 할 때 사용되며 메모리의 Block 단위(`4KB`, `8KB`, `64KB`)로 처리된다.  \n블록단위 전송으로서 인터럽트가 발생되기 때문에, 성능향상에 큰이점을 준다.\n"
  },
  {
    "path": "/wiki/io-manager",
    "header": {
      "layout": "wiki",
      "title": "입출력 관리자",
      "tags": [
        "I/O Manager",
        "I/O"
      ],
      "summary": "I/O Manager",
      "hide": true,
      "date": 1999999999999,
      "breadcrumbs": [
        "문서",
        "컴퓨터",
        "하드웨어"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "I/O Manager란?",
            "title": "I/O Manager란?",
            "fragment": "root-0",
            "children": []
          },
          {
            "rank": 2,
            "origin": "PCI express",
            "title": "PCI express",
            "fragment": "root-1",
            "children": []
          },
          {
            "rank": 2,
            "origin": "Bridge (North Bridge, South Bridge)",
            "title": "Bridge (North Bridge, South Bridge)",
            "fragment": "root-2",
            "children": []
          },
          {
            "rank": 2,
            "origin": "I/O Manager의 역할",
            "title": "I/O Manager의 역할",
            "fragment": "root-3",
            "children": []
          }
        ]
      }
    },
    "description": "",
    "content": "\n## I/O Manager란?\n\n## PCI express\n\n## Bridge (North Bridge, South Bridge)\n\n## I/O Manager의 역할\n"
  },
  {
    "path": "/wiki/programmed-io",
    "header": {
      "layout": "wiki",
      "title": "Programmed Input/Output (PIO)",
      "tags": [
        "Hardware",
        "PIO"
      ],
      "summary": "PIO",
      "hide": true,
      "date": 1999999999999,
      "breadcrumbs": [
        "문서",
        "컴퓨터",
        "하드웨어"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "PIO란?",
            "title": "PIO란?",
            "fragment": "root-0",
            "children": []
          },
          {
            "rank": 2,
            "origin": "PIO의 데이터 전송방식",
            "title": "PIO의 데이터 전송방식",
            "fragment": "root-1",
            "children": []
          }
        ]
      }
    },
    "description": "",
    "content": "\n## PIO란?\n\n`Programmed I/O`(이하 PIO)는 말그대로 프로그램 입출력이다. `PIO` 방식은 [네트워크 어댑터]() 또는 [ATA]() 기억장치 같은 주변기기와 [CPU](/wiki/central-processing-unit) 사이에서 데이터를 주고 받는다.\nCPU의 개입으로 처리되므로 성능에 영향을 주며, 이러한 단점을 극복하기 위해 [인터럽트](/wiki/interrupt)나 [DMA](/wiki/direct-memory-access)같은 방식이 고안되었다.\n\n\n## PIO의 데이터 전송방식\n\n`PIO`는 CPU가 데이터를 읽거나 쓸 장치에대해서 주소신호(대상주소)와 제어신호(IOR, IOW)로 I/O 활성화가 이루어지면 데이터버스를 통해 전송된다. \n"
  },
  {
    "path": "/wiki/system-call",
    "header": {
      "layout": "wiki",
      "title": "시스템 콜 (System Call)",
      "tags": [
        "Operating System",
        "System Call"
      ],
      "summary": "System Call",
      "hide": false,
      "date": 1999999999999,
      "breadcrumbs": [
        "문서",
        "컴퓨터",
        "운영체제"
      ],
      "images": [
        {
          "src": "/post/computer/copy-file.png",
          "alt": "cp 명령으로 파일 복사"
        },
        {
          "src": "/post/computer/system-call-implementation.png",
          "alt": "시스템 콜 호출"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "시스템 콜이란?::what-is-system-call",
            "title": "시스템 콜이란?",
            "fragment": "what-is-system-call",
            "children": []
          },
          {
            "rank": 2,
            "origin": "예제::example",
            "title": "예제",
            "fragment": "example",
            "children": []
          },
          {
            "rank": 2,
            "origin": "시스템콜의 동작 과정::how-system-call-works",
            "title": "시스템콜의 동작 과정",
            "fragment": "how-system-call-works",
            "children": [
              {
                "rank": 3,
                "origin": "시스템콜 인터페이스::system-call-interface",
                "title": "시스템콜 인터페이스",
                "fragment": "system-call-interface",
                "children": []
              }
            ]
          },
          {
            "rank": 2,
            "origin": "시스템 콜의 유형::types-of-system-calls",
            "title": "시스템 콜의 유형",
            "fragment": "types-of-system-calls",
            "children": [
              {
                "rank": 3,
                "origin": "프로세스 제어::process-control",
                "title": "프로세스 제어",
                "fragment": "process-control",
                "children": []
              },
              {
                "rank": 3,
                "origin": "파일 조작::file-manipulation",
                "title": "파일 조작",
                "fragment": "file-manipulation",
                "children": []
              },
              {
                "rank": 3,
                "origin": "장치 관리::device-management",
                "title": "장치 관리",
                "fragment": "device-management",
                "children": []
              },
              {
                "rank": 3,
                "origin": "정보 유지::information-maintenance",
                "title": "정보 유지",
                "fragment": "information-maintenance",
                "children": []
              },
              {
                "rank": 3,
                "origin": "통신과 보호::communication-and-protection",
                "title": "통신과 보호",
                "fragment": "communication-and-protection",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "",
    "content": "\n## 시스템 콜이란?::what-is-system-call\n\n시스템 콜(System Call)은 사용자 프로그램 또는 시스템 프로그램이 시스템 자원을 사용하기 위해 커널에게 요청하는 인터페이스이다.\n우리가 흔히 알고있는 표준 라이브러리(`C의 stdio.h: fopen(), fread(), fwrite()`)도 내부적으로는 시스템 콜(`C로 구현`)을 호출하여 커널에게 요청한다.\n\n시스템 자원은 커널에서 관리하기 때문에 외부에서 직접적으로 사용할 수 없어, 이를 위해 커널에서 제공하는 인터페이스를 사용하여 시스템 콜을 호출할 수 있다.\n이러한 호출은 일반적으로 C/C++로 작성된 함수 형태로 제공된다.\n\n## 예제::example\n\n::text-wrapping\n\n![cp 명령으로 파일 복사](/post/computer/copy-file.png)\n\n예를 들어 한 파일로부터 데이터를 읽어서 다른 파일로 복사하는 간단한 프로그램을 작성한다 가정해 보자.\n\n`UNIX`의 CP 명령(`cp in.txt out.txt`)은 두개의 파일 이름을 인자로 받아서 첫번째 파일로부터 데이터를 읽어서 두번째 파일로 데이터를 쓴다.\n먼저 인자를 받고 나면 파일을 열고, 출력파일을 생성하여 출력 파일도 연다. 각각의 연산은 별개의 시스템콜(`open()`)을 호출한다.\n\n하지만 이와 같은 경우는 파일을 복사하기전 모든 검증과정이 끝났을 때의 상황이다.\n만약 입력 파일(`in.txt`)이 존재하지 않거나, 그 파일에 대한 접근이 금지된 경우 프로그램은 에러 메세지를 출력하고 비정삭적으로 종료(또 다른 시스템콜)를 해야한다.\n\n입력 파일에 대한 검증이 완료되어도, 출력파일을 생성할 때, 동일한 이름을 가진 파일이 이미 존재하면 기존 파일을 삭제(delete)/변경(write) 또는 새로운 파일 이름으로 생성(create)할 수 있다.\n이런 복사라는 과정에서도 다양한 시스템콜이 여러번 호출된다.\n\n::{ \"align\": \"right\" }\n\n**연속된 시스템 콜의 예**\n\n1. 입력파일 이름 획득\n    1. 화면에 프롬프트 출력\n    2. 입력파일 받아들임\n2. 출력파일 이름 획득\n    1. 화면에 프롬프트 출력\n    2. 출력파일 받아들임\n3. 입력파일 열기\n    1. 파일이 존재하지 않을 경우, 비정상적으로 종료\n4. 출력파일 생성\n    1. 파일이 존재할 경우, 비정상적으로 종료\n5. 루프 (읽기가 실패할 때까지 반복)\n    1. 입력파일로 부터 읽어 들임\n    2. 출력파일에 쓰기\n6. 입력파일 닫기\n7. 출력파일 닫기\n8. 화면에 완료 메세지 출력\n9. 종료\n\n## 시스템콜의 동작 과정::how-system-call-works\n\n시스템 콜은 실제 동작이 아니다. 시스템 콜은 커널 수준에서 제공하는 인터페이스이며, 그 구현은 커널함수로 이루어지게 된다.\n따라서 시스템 콜은 c로 만들어지더 라도 커널내에서 제어하려는 자원에 따라 [어셈블리어]() 또는 c로 작성된 함수로 구현된다.\n\nc언어로 작성된 표준 라이브러리(`libc`)에 래핑 API가 제공되는데, 이는 아래와 같다:\n\n1. glibc: GNU C 라이브러리\n    * [저장소](https://sourceware.org/git/glibc.git)\n    * read()함수 정의: [`/include/unistd.h`](https://sourceware.org/git/?p=glibc.git;a=blob;f=include/unistd.h)\n    * read()함수 구현: [\n      `/sysdeps/unix/sysv/linux/read.c`](https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/read.c)\n    * 특징\n        * Linux 배포판의 표준라이브러리\n        * 가장 광범위하게 사용됨\n        * 가장 완전한 POSIX 구현\n    * 사용되는 시스템: Ubuntu, Fedora, CentOS, Debian 등\n2. musl: musl libc\n    * [저장소](https://git.musl-libc.org/cgit/musl)\n    * read()함수 정의: [`/include/unistd.h`](https://git.musl-libc.org/cgit/musl/tree/include/unistd.h)\n    * read()함수 구현: [`/src/unistd/read.c`](https://git.musl-libc.org/cgit/musl/tree/src/unistd/read.c)\n    * 특징\n        * 경량화된 C표준 라이브러리\n        * 임베디드 시스템과 작은 Linux 배포판에 최적화\n        * 최소한의 리소스 사용\n    * 사용되는 시스템: Alpine Linux, Void Linux 등\n4. BSD libc\n    * [저장소](https://github.com/freebsd/freebsd-src)\n    * read()함수 정의: [`/include/unistd.h`](https://github.com/freebsd/freebsd-src/blob/main/include/unistd.h)\n    * read()함수 구현: [`/lib/libc/sys/read.c`](https://github.com/freebsd/freebsd-src/blob/main/lib/libc/sys/read.c)\n    * 특징\n        * BSD(Berkeley Software Distribution) 계열의 표준 라이브러리\n        * POSIX 표준 준수\n        * Unix 시스템 고유의 확장 기능 제공\n    * 사용되는 시스템: FreeBSD, NetBSD, OpenBSD, MacOS/iOS 등\n\n```c\n#include <unistd.h> //unix standard\n\nssize_t read(int fd, void *buf, size_t count) {\n    return syscall_cp(SYS_read, fd, buf, count);\n}\n```\n\n이 코드는 `musl libc`의 read 시스템콜 래핑 API이다. 각 시그니처는 다음을 의미한다:\n\n1. `fd`: 읽으려는 파일 디스크립터\n2. `buf`: 데이터를 읽어들일 버퍼\n3. `count`: 버퍼로 읽어 들일 수 있는 최대 바이트 수\n\n읽기가 성공한 경우 읽어 들인 바이트 수(size_t)를 반환하고, 오류가 발생한 경우 `-1`을 반환한다.\n\n> Unix/Linux 시스템에서는 `man read` 명령어로 man(manual) 페이지에서 시스템의 모든 명령어, 함수, 시스템콜 등에 대한 정보를 확인할 수 있다.\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\" }\n\n![시스템 콜 호출](/post/computer/system-call-implementation.png)\n:{ \"max-width\": \"400px\", \"align\": \"center\", \"description\": \"시스템 콜 호출 과정\" }\n\n시스템 콜 호출은 다음과 같이 처리된다.\n\n1. 사용자 프로그램은 시스템 콜을 호출한다. (syscall_cp()): 운영체제 에서\n   제공하는 [Wrapping API](https://git.musl-libc.org/cgit/musl/tree/src/unistd/read.c) 호출\n2. 시스템 콜인터페이스는 사용자 요청을 검증(인자 유효성, 권한, 리소스 가용성 등)하고 커널에 전달한다.\n3. 커널로 전달 전 CPU는 커널모드로 전환되고, 사용자\n   요청을 [시스템 콜 테이블](https://github.com/torvalds/linux/blob/v5.6/arch/x86/entry/syscalls/syscall_64.tbl)을 통해 시스템 콜 번호로\n   매핑한다.\n4. CPU는 실행전 커널모드로 전환하여 커널 함수를 실행하고, 사용자모드로 전환하고 반환값은 사용자 프로그램으로 전달하며, 제어또한 사용자 프로그램으로 넘어간다.\n\n### 시스템콜 인터페이스::system-call-interface\n\n앞서 시스템 콜 인터페이스는 사용자의 요청을 검증하고 커널 함수로 전달하는 역할을 한다고 했다.\n그렇다면 어떤 방식으로 사용자의 요청을 검증하는 것일까?\n\n시스템에서 제공되는 Wrapping API는 사용자 공간에서 `libc`로 제공된다.  \n사용자가 `read()` API(**glib** 기준)를 사용하는 시점부터 알아보자. \n\n```c::Wrapping API 호출\n// include/unistd.h\nextern ssize_t __libc_read (int __fd, void *__buf, size_t __n);\n\n// sysdeps/unix/sysv/linux/read.c\nssize_t __libc_read (int fd, void *buf, size_t nbytes) {\n  return SYSCALL_CANCEL (read, fd, buf, nbytes);\n}\n```\n\n`__libc_read()` 함수는 시스템콜 인터페이스(`SYSCALL_CANCEL`)로 read 시스템콜을 호출한다.\n이 내부적으로 인자값을 어떻게 전달하고 내부적인 시스템콜 매크로를 어떻게 선택하는지 알 수 있다.\n\n::code-group\n\n```c::1. SYSCALL_CANCEL 매크로\n//1. 연결된 인터페이스 매크로는 내부적으로 INLINE_SYSCALL_CALL() 매크로를 호출한다. \n# define SYSCALL_CANCEL(...) \\\n  __SYSCALL_CANCEL_CALL (__VA_ARGS__) //(__VA_ARGS__는 가변인자)\n```\n\n```c::2. __SYSCALL_CANCEL_CALL 매크로\n#define __SYSCALL_CANCEL_CALL(...) \\\n  __SYSCALL_CANCEL_DISP (__SYSCALL_CANCEL, __VA_ARGS__)\n```\n\n```c::3. __INLINE_SYSCALL_DISP 매크로\n//앞서 전달한 __SYSCALL_CANCEL 값을 b로 받는다.\n//요청 당시 매개변수 (read, fd, buf, nbytes)를 __SYSCALL_CANCEL_NARGS()로 전달한다. \n#define __SYSCALL_CANCEL_DISP(b,...) \\\n  __SYSCALL_CANCEL_CONCAT (b,__SYSCALL_CANCEL_NARGS(__VA_ARGS__))(__VA_ARGS__)\n//여기서 중요한점은 __SYSCALL_CANCEL_CONCAT은 매크로 이름을 만드는 매크로이다.\n//즉 b: __SYSCALL_CANCEL 와 __SYSCALL_CANCEL_NARGS(__VA_ARGS__)의 결과값을 인자로 받는다.\n\n//상위에 작성된 매크로 이름 생성 매크로 \n#define __SYSCALL_CANCEL_CONCAT_X(a,b)     a##b //a와 b를 붙인다.\n#define __SYSCALL_CANCEL_CONCAT(a,b)       __SYSCALL_CANCEL_CONCAT_X (a, b)\n```\n\n```c::4. __SYSCALL_CANCEL_NARGS 매크로\n//NARGS는 \"Number of Arguments\"의 약자로, 가변인자의 개수를 반환한다.\n#define __SYSCALL_CANCEL_NARGS_X(a,b,c,d,e,f,g,h,n,...) n\n#define __SYSCALL_CANCEL_NARGS(...) \\\n  __SYSCALL_CANCEL_NARGS_X (__VA_ARGS__,7,6,5,4,3,2,1,0,)\n//위처럼 되면 __SYSCALL_CANCEL_NARGS(read, fd, buf, nbytes)는 3를 반환한다.\n//a=read, b=fd, c=buf, d=nbytes, e=7, f=6, g=5, h=4, n=3\n```\n\n```c::5. 호출할 매크로 선택\n#define __SYSCALL_CANCEL_DISP(b,...) \\\n  __SYSCALL_CANCEL_CONCAT (b,__SYSCALL_CANCEL_NARGS(__VA_ARGS__))(__VA_ARGS__)\n//해당 코드의 매크로를 치환하면 아래처럼 된다.\n//b: __SYSCALL_CANCEL\n//__SYSCALL_CANCEL_NARGS(read, fd, buf, nbytes): 3\n//__SYSCALL_CONCAT(__SYSCALL_CANCEL, 3)(read, fd, buf, nbytes): __SYSCALL_CANCEL3(read, fd, buf, nbytes)\n\n//결과적으로 __SYSCALL_CANCEL3(read, fd, buf, nbytes) 매크로를 호출한다.\n```\n\n::\n\n위에서는 `__SYSCALL_CANCEL3(read, fd, buf, nbytes)` 매크로를 호출하였다.\n이제 해당 매크로를 시점으로 어떻게 이어지는지 알아 보자\n\n::code-group\n\n```c::1. __SYSCALL_CANCEL3 매크로 호출\n/* sysdeps\\unix\\sysv\\linux\\mips\\mips64\\n32\\syscall_types.h */\ntypedef long long int __syscall_arg_t;\n//Syscall Safe Convert\t\t    \n#define __SSC(__x) ((__syscall_arg_t) (__typeof__ ((__x) - (__x))) (__x))\n\n/* sysdeps\\unix\\sysdep.h */\n# define __SYSCALL_CANCEL7_ARG_DEF\n# define __SYSCALL_CANCEL7_ARCH_ARG_DEF\n# define __SYSCALL_CANCEL7_ARG\n\nlong int __syscall_cancel (__syscall_arg_t arg1, __syscall_arg_t arg2,\n\t\t\t   __syscall_arg_t arg3, __syscall_arg_t arg4,\n\t\t\t   __syscall_arg_t arg5, __syscall_arg_t arg6,\n\t\t\t   __SYSCALL_CANCEL7_ARG_DEF\n\t\t\t   __syscall_arg_t nr) attribute_hidden;\n\t\t\t   \n#define __SYSCALL_CANCEL3(name, a1, a2, a3) \\\n  __syscall_cancel (__SSC (a1), __SSC (a2), __SSC (a3), 0, 0, 0,\t\\\n\t\t    __SYSCALL_CANCEL7_ARG __NR_##name)\n```\n\n```c::2. ntpl/cancellation.c 함수 호출\n//Native POSIX Thread Library (NPTL)의 취소 기능을 위한 코드\nlong int\n__syscall_cancel (__syscall_arg_t a1, __syscall_arg_t a2,\n\t\t  __syscall_arg_t a3, __syscall_arg_t a4,\n\t\t  __syscall_arg_t a5, __syscall_arg_t a6,\n\t\t  __SYSCALL_CANCEL7_ARG_DEF __syscall_arg_t nr)\n{\n  int r = __internal_syscall_cancel (a1, a2, a3, a4, a5, a6,\n\t\t\t\t     __SYSCALL_CANCEL7_ARG nr);\n  return __glibc_unlikely (INTERNAL_SYSCALL_ERROR_P (r))\n\t ? SYSCALL_ERROR_LABEL (INTERNAL_SYSCALL_ERRNO (r))\n\t : r;\n}\n```\n::\n\n`__internal_syscall_cancel`함수에서 결과를 받아서 읽은 바이트수의 결과를 반환한다.\n\n\n## 시스템 콜의 유형::types-of-system-calls\n\n시스템콜은 다섯가지 중요한 유형으로 나눌 수 있다:\n\n1. 프로세스 제어\n2. 파일 조작\n3. 장치 관리\n4. 정보 유지\n5. 통신과 보호\n\n### 프로세스 제어::process-control\n\n* 생성(fork), 중지(abort), 종료(exit)\n* 적재(load), 실행(execute)\n* 프로세스 속성(attributes) 조회, 변경\n* 시간 대기\n* 이벤트 대기(wait event), 알림(signal event)\n* 메모리 할당 및 자유화\n\n### 파일 조작::file-manipulation\n\n* 파일 생성(create file), 삭제(delete file)\n* 열기(open), 닫기(close)\n* 읽기, 쓰기, 위치 변경(reposition)\n* 파일 속성 조회, 변경\n\n### 장치 관리::device-management\n\n* 장치 요청(request devices), 해제(release devices)\n* 읽기, 쓰기, 위치 변경(reposition)\n* 장치 속성(attributes) 조회, 변경\n* 장치의 논리적 부착(attach), 분리(detach)\n\n### 정보 유지::information-maintenance\n\n* 시간, 날짜 조회, 변경\n* 시스템 데이터 조회, 변경\n* 프로세스, 파일, 장치의 속성(attribute) 조회, 변경\n\n### 통신과 보호::communication-and-protection\n* 통신 연결 생성, 제거\n* 메세지 송신, 수신\n* 상태 정보 전달\n* 원격 장치의 부착(attach), 분리(detach)\n* 파일 권한 조회, 변경\n"
  },
  {
    "path": "/docs/life/youth-of-ggomi",
    "header": {
      "layout": "post",
      "title": "꼬미의 젊은 시절",
      "description": "이빨로 무는 노루",
      "categories": [],
      "tags": [
        "Life"
      ],
      "date": 1734591600000,
      "thumbnail": "/post/life/tired-ggomi.png",
      "current-company": "NEOWIZ",
      "current-position": "Software Engineer",
      "summary": "나란 꼬미",
      "excerpt-separator": "<!--more-->",
      "hide": true,
      "breadcrumbs": [
        "문서",
        "일상"
      ],
      "images": [
        {
          "src": "/post/life/first-day-of-ggomi.jpg",
          "alt": "꼬미가 처음 온 날"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": []
      }
    },
    "description": "",
    "content": "\n![꼬미가 처음 온 날](/post/life/first-day-of-ggomi.jpg)\n:{ \"align\": \"center\", \"description\": \"꼬미가 처음 온날\", \"max-width\": \"300px\"}\n\n꼬미는 엄마를 잃고, 죽어 가던 형제들 사이에서 같이 생명을 잃어가고 있었다.  \n꼬미는 태어났을때 다른 강아지들보다 너무 작아서 쪼꼬미라고 지었다. (엄마가 조씨라서 조꼬미)  \n\n집에 데려가던 차안에서 토를 했는데, 몇 백마리의 기생충이 나왔다.\n"
  },
  {
    "path": "/docs/database/mysql-explain",
    "header": {
      "layout": "post",
      "title": "MySQL의 EXPLAIN을 알아보자",
      "categories": [
        "database",
        "mysql"
      ],
      "tags": [
        "Database",
        "MySQL",
        "EXPLAIN"
      ],
      "date": 1724390820000,
      "thumbnail": "/post/database/mysql/mysql-explain-thumbnail.webp",
      "current-company": "NEOWIZ",
      "current-position": "Software Engineer",
      "summary": "MySQL EXPLAIN",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "데이터베이스"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "EXPLAIN 출력 컬럼::explain-output-columns",
            "title": "EXPLAIN 출력 컬럼",
            "fragment": "explain-output-columns",
            "children": [
              {
                "rank": 3,
                "origin": "id (SELECT 순서)::id",
                "title": "id (SELECT 순서)",
                "fragment": "id",
                "children": []
              },
              {
                "rank": 3,
                "origin": "select_type (SELECT 타입)::select-type",
                "title": "select_type (SELECT 타입)",
                "fragment": "select-type",
                "children": []
              },
              {
                "rank": 3,
                "origin": "table (참조 테이블)::table",
                "title": "table (참조 테이블)",
                "fragment": "table",
                "children": []
              },
              {
                "rank": 3,
                "origin": "partition (파티션)::partition",
                "title": "partition (파티션)",
                "fragment": "partition",
                "children": []
              },
              {
                "rank": 3,
                "origin": "type (조인타입)::type",
                "title": "type (조인타입)",
                "fragment": "type",
                "children": []
              },
              {
                "rank": 3,
                "origin": "possible_keys (사용가능한 인덱스)::possible-keys",
                "title": "possible_keys (사용가능한 인덱스)",
                "fragment": "possible-keys",
                "children": []
              },
              {
                "rank": 3,
                "origin": "key (사용할 인덱스)::key",
                "title": "key (사용할 인덱스)",
                "fragment": "key",
                "children": []
              },
              {
                "rank": 3,
                "origin": "key_len (키의 길이)::key-len",
                "title": "key_len (키의 길이)",
                "fragment": "key-len",
                "children": []
              },
              {
                "rank": 3,
                "origin": "ref (참조 값)::ref",
                "title": "ref (참조 값)",
                "fragment": "ref",
                "children": []
              },
              {
                "rank": 3,
                "origin": "rows (검사 행 개수)::rows",
                "title": "rows (검사 행 개수)",
                "fragment": "rows",
                "children": []
              },
              {
                "rank": 3,
                "origin": "filtered (필터된 수치)::filtered",
                "title": "filtered (필터된 수치)",
                "fragment": "filtered",
                "children": []
              },
              {
                "rank": 3,
                "origin": "Extra (추가적인 내용)::extra",
                "title": "Extra (추가적인 내용)",
                "fragment": "extra",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "MySQL의 쿼리실행계획에 대해 알아보자.",
    "content": "\n회사에서는 신규유입되는 쿼리에 한에 검수할 수 있는 툴을 만들었다.\n\n나는 담당하는 서비스에 대해 신규 유입 쿼리를 검수해야하며, 매우 많은 쿼리를 봐야만 했다. \n이는 반복적인 업무(쿼리 복사, 테이블 및 인덱스확인, 검수)로 이어졌으며, 실행계획만으로 분석해야하는 대상인지를 1차적으로 판단할 필요가있었다.\n\n쿼리는 여러 유입 목록중 하나를 상세보기로 전체쿼리를 보아 DB Client(Datagrip)로 가져와서 한개씩 확인 해야했다. \n해당 목록에는 쿼리 실행계획도 포함이 되어있기때문에, 상세보기를 보지않고, 목록에서 실행계획만 본다면 바로 판단이 가능하다고 생각되어, 실행 계획을 공부하기로 했다.  \n\n---\n\n`EXPLAIN`은 MySQL이 statement를 어떻게 실행하는지에 대한 정보를 제공한다.\n`EXPLAIN`은 `SELECT`쿼리 에서 사용되는 각 테이블에 대한 정보를 반환하며, 이는 [Mysql Query Optimizer]() 가 명령문을 처리하면서 읽는 순서대로 테이블을 나열한다. \n이 말은 MySQL이 첫번째 테이블에서 행을 읽고 두번째 테이블에서 매치되는 행을 찾은 다음, 세번째 테이블에서, 그리고 계속 그렇게 진행한다는 의미이다. \n\n\n\n## EXPLAIN 출력 컬럼::explain-output-columns\n\n`EXPLAIN`의 각 출력 행은 하나의 테이블에 대한 정보를 제공한다. 각 행은  아래 `표 1.1 EXPLAIN 출력 컬럼들` 에 요약된 값을 포함한다.\n테이블의 첫번째 컬럼에는 컬럼명, 두번째는 `FORMAT=JSON`이 사용될때 출력에서 보여지는 프로퍼티명을 제공한다.\n\n\n\n*표 1.1 EXPLAIN 출력 컬럼들*\n\n| 컬럼          | JSON 이름     | 의미                             |\n| ------------- | ------------- | -------------------------------- |\n| id            | select_id     | SELECT 식별자                    |\n| select_type   | 없음          | SELECT 타입                      |\n| table         | table_name    | 결과 행에 대한 테이블            |\n| partitions    | partitions    | 매칭되는 파티션                  |\n| type          | access_type   | JOIN 타입                        |\n| possible_keys | possible_keys | 선택에 사용가능한 index들        |\n| key           | key_length    | 선택된 키의 길이                 |\n| ref           | ref           | index에 비교되는 컬럼들          |\n| rows          | rows          | 조사될 예상행                    |\n| filtered      | filtered      | 테이블 조건에서 걸러진 행의 비율 |\n| extra         | 없음          | 추가 정보                        |\n\n\n\n### id (SELECT 순서)::id\n(JSON: selected_id)  \nSELECT 식별자이다. 쿼리 내에서 SELECT의 순서가 있는 숫자이며,  다른 행의 `UNION` 결과를 행이 참조한다면 값은 null일 수 있다. \n이 경우 테이블 컬럼은 id 값들의 M과 N인 행의 `UNION`에 행이 참조하는 행을 나타내기 위해, <union**M**,**N**> 같은 값을 보여준다.\n  \n\n### select_type (SELECT 타입)::select-type   \n(JSON: 없음)  \n아래 보여진 테이블중 어떤 `SELECT`의 타입이다. JSON-formatted EXPLAIN은  `SIMPLE`이나 `PRIMARY`가 아닌 한  `query_block`의 프로퍼티로 SELECT 타입을 노출한다.\n\n| select_type **값**   | JSON 이름                  | Meaning                                                      |\n| -------------------- | -------------------------- | ------------------------------------------------------------ |\n| SIMPLE               | 없음                       | 간단한 SELECT (UNION 또는 서브쿼리 사용 X)                   |\n| PRIMARY              | 없음                       | 가장 바깥쪽 SELECT                                           |\n| UNION                | 없음                       | UNION의 두번째 이상의 SELECT                                 |\n| DEPENDENT UNION      | dependent (true)           | 바깥쪽 쿼리에 의존되는 UNION에서 두번째 이상의 SELECT        |\n| UNION RESULT         | union_result               | UNION의 결과                                                 |\n| SUBQUERY             | 없음                       | 서브쿼리의 첫번째 SELECT                                     |\n| DEPENDENT SUBQUERY   | dependent (true)           | 바깥쪽 쿼리에 의존되는 서브쿼리의 첫번째 SELECT              |\n| DERIVED              | 없음                       | 파생된 테이블 (서브쿼리로 만들어진 임시테이블)               |\n| DEPENDENT DERIVED    | depentent (true)           | 또다른 테이블을 의존하는 파생된 테이블                       |\n| MATERIALIZED         | materialized_from_subquery | 서브쿼리로 물질화                                            |\n| UNCHAHEABLE SUBQUERY | cacheable (false)          | 바깥쪽 쿼리의 각  행에대해 결과가 캐시될수 없고 재 평가 되어아야하는 서브쿼리 |\n| UNCACHEABLE UNION    | cacheable (false)          | 캐시를 할 수 없는 서브쿼리에 속해있는 UNION 내 두번째 이상 SELECT |\n\n> `DEPENDENT`는 일반적으로 [상관관계 서브쿼리](https://dev.mysql.com/doc/refman/8.4/en/correlated-subqueries.html) 사용을 의미한다.\n:{ \"type\": \"note\", \"icon\": \"info\"}\n\n### table (참조 테이블)::table\n(JSON: table_name)    \n출력행이 참조하는 테이블명이며, 다음 값중 하나가 될 수도 있다.\n* <union**M**, **N**>:  행은 **M** 과 **N**의 id 값을 갖는 행의 union을 합집합을 참조한다.\n* <deribed**N**>: 행은 **N**의 값을 갖는 행에 대한 파생된 테이블의 결과를 참조한다.  파생된 테이블은 예를들어 `FROM`절 내 서브쿼리에서 생성될 수도 있다.\n* <subquery**N**>: 행은 **N**의 id값을 갖는 행에대해 구체화된 서브쿼리(Materialized Subquery)의 결과를 참조한다.\n\n### partition (파티션)::partition\n(JSON: partitions)  \n  쿼리로부터 매칭될수 있는 레코드에서의 파티션이다. 파티셔닝 되지않은 테이블에 대해서는 `NULL` 이다.\n\n### type (조인타입)::type\n(JSON: access_type)\n조인 타입이며, 테이블들을 어떻게 조인하는지 설명을 출력한다. JSON-formatted 출력에서는 acess_type의 속성 값으로 나온다. 다음에 목록은 조인타입을 좋은 케이스부터 안좋은케이스 순으로 설명한다.\n* system  \n  테이블이 한개의 로우(= 시스템 테이블)만 가지고있다. `const` 조인타입의 특별한 케이스이다.\n* const  \n테이블에 매칭되는 행이 최대 한개만 있으며, 이는 쿼리의 시작시 읽힌다. 오직 한개의 행만 있기 때문인데, 이 행의 열에 있는 값은 옵티마이저의 나머지 부분에서 상수로 간주될 수 있다. `const` 테이블은 한번만 읽히므로 매우빠르다.\n`const` 는`UNIQUE` 인덱스나 `PRIMARY KEY` 의 모든 부분을 상수값과 비교할때 시용된다.  다음 쿼리는  *tbl_name*이 상수 테이블로 사용될 수 있다.\n```sql\nSELECT * FROM tbl_name WHERE primary_key = 1;\n  \nSELECT * FROM tbl_name\n    WHERE primary_key_part1 = 1 AND primary_key_part2 = 2;\n```\n\n* eq_ref  \n이전 테이블에서 각 행 조합마다 이 테이블에서 한 행씩 읽는다. `system`과 `const` 타입을 제외하면 이게 제일 나은 조인타입이다.  조인에서 인덱스의 모든 부분을 사용하고,  인덱스가 `PRIMARY` 또는 `UNIQUE NOT NULL` 인덱스인 경우에 사용된다.\n`eq_ref`는 `=` 연산자를 사용하여 비교된 컬럼  인덱스에 사용될 수있다. 비교값은 상수가 될수 있고, 이 테이블보다 먼저 읽은 테이블의 열을 사용하는 표현식이 될 수도 있다. 다음의 예제에서 MySQL 은 *ref_table*를 처리하기위해 `eq_ref` 조인을 사용 할 수 있다.\n```sql\nSELECT * FROM ref_table,other_table\n  WHERE ref_table.key_column = other_table.column; //표현식 비교\n  \nSELECT * FROM ref_table, other_table\n  WHERE ref_table.key_column_part1 = other_table.column\n  AND ref_table.key_column_part2 = 1; //상수비교\n```\n\n* ref  \n이전 테이블의 행조합마다 일치하는 인덱스 값이 있는 모든행이 이 테이블에서 읽혀진다. 키의 가장왼쪽 접두어만 조인에 사용되거나 키가 `PRIMARY KEY` 또는 `UNIQUE`인덱스(즉, 키 값을 기준으로 조인이 단일행을 선택할 수 없는 경우)가 아닌경우에 `ref`가 사용된다.\n사용된 키가 몇개의 행에만 일치하는경우, 좋은 조인 타입이다.\n`ref` 는 `<=>`또는 `=` 연산자를 사용하여 비교된 인덱스들에 대해 사용될 수 있다. 다음의 예제에서 MySQL은 *ref_table* 처리에 `ref` 조인을 사용할 수 있다.  \n```sql\nSELECT * FROM ref_table WHERE key_column = expr; //여기서 expr은 다른 테이블에 대한 조건 표현식을 의미한다.\n  \nSELECT * FROM ref_table, other_table\n  WHERE ref_table.key_column = other_table.column;\n  \nSELECT * FROM ref_table,other_table\n  WHERE ref_table.key_column_part1 = other_table.column\n  AND ref_table.key_column_part2 = 1;\n```\n* fulltext  \n`FULLTEXT` 인덱스를 사용하여 수행된 조인이다.\n\n* ref_or_null  \n이 조인 타입은 `ref` 와 유사하지만, MySQL이 `NULL` 값을 포함하는 행들에 대해 추가 검색 수행한다는 점이 다르다. 이 조인 타입 최적화는 서브쿼리를 해결하는데 가장 자주 사용된다. 다음의 예제에서 MySQL은 *ref_table*을 처리에 `ref_or_null` 조인을 사용할 수 있다.\n```sql\nSELECT * FROM ref_table\n  WHERE key_column = expr OR key_column IS NULL;\n```\n* index_merge  \n이 조인 타입은 인덱스 병합 최적화가 사용되었다는 것을 나타 낸다. 이 경우, 출력행의 `key` 컬럼은 사용된 인덱스들의 목록을 포함하며  `key_len` 은 사용된 인덱스에 대한 가장긴 키부분 목록을 포함한다.\n\n* unique_subquery  \n이 타입은 다음 형식의 `IN` 서브쿼리이 대한 `eq_ref`를 대체한다.\n```sql\nvalue IN (SELECT primary_key FROM single_table WHERE some_expr)\n```\n`unique_subquery`는 완전히 더나은 효율성을 위해 서브쿼리를 완전히 대체하는 인덱스 조회 함수일 뿐이다.\n\n* index_subquery  \n이 조인 타입은 `unique_subquery`와 비슷하다. `IN` 서브쿼리를 대체하지만, 다음의 형식의 서브쿼리에서 유니크가 아닌 인덱스에 대해 동작한다.\n```sql\nvalue IN (SELECT key_column FROM single_table WHERE some_expr)\n```\n\n* range  \n주어진 범위에 있는 행들만 조회되며, 행 선택에 인덱스를 사용한다. 출력 행의 `key` 컬럼은 해당 인덱스가 사용됨을 나타낸다. `key_len` 컬럼은 사용된 가장긴 키부분을 포함한다. `ref`컬럼은 이 타입에대해 `NULL` 이다.\n`range`는 `key`컬럼이  `=, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, LIKE` 또는  `IN()` 연산자를 사용하여 비교되는 상수일 때 사용된다.\n\n```sql\nSELECT * FROM tbl_name\n  WHERE key_column = 10;\n  \nSELECT * FROM tbl_name\n  WHERE key_column BETWEEN 10 and 20;\n  \nSELECT * FROM tbl_name\n  WHERE key_column IN (10, 20, 30);\n  \nSELECT * FROM tbl_name\n  WHERE key_part1 = 10 AND key_part2 IN (10, 20, 30);\n```\n\n* index   \n`index` 조인 타입은 인덱스 트리 스캔 빼고 `ALL` 하고 같으며, 두가지 상황에서 발생한다.\n* 인덱스가 쿼리에 대한 커버링 인덱스 이고,  테이블에서 필요한 모든 데이터를 충족하는 데 사용할 수 있는 경우 인덱스 트리만 스캔된다. 이 경우 `Extra` 컬럼은 `Using Index`라고 나온다. 보통 인덱스 전용 스캔은 일반적으로 인덱스 사이즈가 테이블 데이터보다 작기떄문에, `ALL`보다 빠르다.\n* 풀 스캔은 인덱스에서 읽어서 인덱스 순서대로 데이터 행을 조회하여 수행된다.  `Extra` 컬럼이 에는 인덱스 사용이 나오지 않는다.\nMySQL은 쿼리가 단일인덱스의 일부인 컬럼만 사용하는 경우, 이 조인타입을 사용할 수있다.\n\n* ALL  \n풀스캔은 이전 테이블의 행 조합 마다 수행된다. 테이블이 `const`로 표시되지않은 첫번째 테이블인 경우 일반적으로 좋지 않으며, 다른 모든 경우에는 *매우* 나쁘다. 보통은, 이전테이블의 상수값 이나 컬럼값을 기준으로 테이블에서 행을 검색할 수있는 인덱스를 추가하면 `ALL` 타입을 피할 수 있다.\n\n### possible_keys (사용가능한 인덱스)::possible-keys\n(JSON: possible_keys)    \n`possible_keys` 컬럼은 MySQL이 이 테이블에서 행을 찾기위해 선택할 수 있는 인덱스들을 나타낸다. 참고로 이 컬럼은 `EXPLAIN`의 출력에 표시된 테이블들의 순서와 별개입니다. 이 말은 테이블 순서 생성된 실행에서  `possible_keys`에 어떤 키들은 사용될수 없을 수도 있다는 의미이다.\n이 컬럼이 `NULL`이라면, 적절한 인덱스가 없다는 뜻이다. 이 경우 인덱싱에 적합한 컬럼을 참조하는지 확인하기위해 `WHERE` 절을 검사사여 쿼리의 성능을 개선할 수 있다. 적절한 인덱스를 생성하고 `EXPLAIN` 쿼리를 확인해보자.\nSHOW INDEX FROM  *table_name* 으로 테이블 인덱스를 볼수 있다.\n\n### key (사용할 인덱스)::key\n(JSON: key)  \n`key`  컬럼은 MySQL이 사용하기로 정한 키(인덱스)를 나타냅니다. MySQL이 행조회에 `possible_keys` 인덱스들중 중 한개를 사용하기로 정했다면, 인덱스는 키값으로 나열된다.\n`key` 는 `possible_keys` 값에 없는 인덱스를 지정할 수도 있다.  이는 `possible_keys` 인덱스중 어느행도 조회되는데 적합하지 않지만, 쿼리의 선택된 모든 컬럼이 다른 인덱스의 컬럼인경우 발생할 수 있다. 즉, 지정된 인덱스가 선택된 컬럼들을 포함하고 있기때문에, 어느행을 검색할지를 결정하는 데는 사용되지 않더라도 인덱스 스캔은 데이터 행 스캔보다 효율적이다. (*이 내용은 \"커버링 인덱스\"의 효율성에 대한 내용이다.*)\n`InnoDB`의 경우 쿼리에서 기본키를 선택하더라도 보조 인덱스가 선택한 열을 포함할 수 있다. 이는 `InnoDB`가 각 보조인덱스에 기본 키 값을 저장하기 때문이다. `key`컬럼이 `NULL`이라면, `MySQL`은 쿼리를 보다 효율적으로 실행하는데 사용할 인덱스를 찾지 못한다.\n\n`MySQL`이 `possible_keys` 컬럼 내 있는 인덱스를 강제로 사용하거나 무시하게 하려면, 쿼리에서 `FORCE_INDEX`, `USE_INDEX` 또는 `IGNORE_INDEX`를 사용하면 된다.\n\n### key_len (키의 길이)::key-len\n(JSON: key_length)    \n`key_len` 컬럼은 `MySQL`이 사용하기로 결정한 키의 길이를 나타낸다. `key_len`의 값은 MySQL이 실제로 사용하는 복합키의 일부가 얼마나 되는지 확인 할수 있게 해준다. \n실제 표시되는 값은 사용된 키의 바이트 길이를 나타내여 사용하는 유니코드마다 다를수 있다. (*실제로 사용하는 복합키의 일부의 의미는 쿼리에 따라 첫번째 컬럼만 사용할 수도 있고, 두번째 컬럼까지 사용할 수 있다는 의미이다.*)\n키 저장 포맷으로 인해, `NULL`이 될수 있는 컬럼의 키 길이는 `NOT NULL`인 컬럼의 길이보다 1이 크다. (*NULL을 구분할 비트가 추가되기 때문에*)\n\n### ref (참조 값)::ref\n(JSON: ref)\n`ref`컬럼은 테이블에서 `key` 컬럼 내 어떤 컬럼이나 제약이 지정된 인덱스와 비교되었는지 보여줍니다.\n값이 `func`라면, 사용된 값은 어떤 함수의 결과입니다. 어떤 함수인지 확인하려면, 확장된 `EXPLAIN`결과를 보기위해 `EXPLAIN`뒤에 `SHOW WARNINGS`를 사용하면 된다. \n함수는 실제로 산술 연산자 같은 연산자 일 수 있다.\n\n### rows (검사 행 개수)::rows\n(JSON: rows)    \n`rows`  컬럼은 `MySQL`이 쿼리 실행 검사를 해야만 한다고 여기는 행들의 개수를 나타낸다. `InnoDB` 테이블의 경우, 이 값은 예측치이며, 항상 정확하지 않을 수도 있다.\n\n### filtered (필터된 수치)::filtered\n(JSON: filtered)\n`filtered` 컬럼은 테이블 조건으로 필터된 테이블 행들의 예상 백분률을 나타낸다. \n최대 값은 100이며, 이는 행의 필터링이 발생되지않음을 의미한다. 100에서 감소된 값은 필터링 양이 증가함을 나타낸다. \n`rows` 는 검된 행의 예상치를 보여주고`rows` × `filtered`는 다음 테이블로 조인된 행의 갯수를 보여준다. 예를들어, `rows`가 1000이고 `filtered`가 50.00(50%)라면, 다음 테이블로 조인된 행의 개수는 1000 × 50% = 500이다.\n\n### Extra (추가적인 내용)::extra\n(JSON: 없음)\n이컬럼은  `MySQL`이 쿼리를 어떻게 해결하는지에 대한 추가적인 정보를 포함한다. 다른 값의 설명들은 `EXPLAIN` [Extra 정보]()을 보자.\n\n`Extra`컬럼에 해당하는 단일 JSON 속성 값은 따로 없지만, 이 컬럼 내에서 발생될수 있는 값들은 JSON 속성이나 `message` 속성의 텍스트로 노출된다.\n쿼리를 빠르게 만들고 싶다면, `Using filesort`와 `Using temporary`의 `Extra` 컬럼값을 조심하자. JSON 형식에서는 `using_filesort`와 `using_temporary_table` 값이 `true`와 같다.\n\n* Zero limit  \n쿼리에 `LIMIT 0`절이있고 어떤 행도 선택할 수 없는 경우이다.\n\n* Using Where with pushed condition  \n이 항목은 [NDB]() 테이블들에만 적용된다.\n\n* Using Where  \n`WHERE`절은 다음 테이블과 일치시킬 행이나 클라이언트에 보내낼 행을 제한하는데 사용된다.  \n특별하게 테이블의 모든행을 가져오길 의도하거나 검사하려 하지 않는한, `Extra` 값이 `Using Where`이 아니고 테이블 조인 타입이 `ALL` 또는 `index`라면, 쿼리에 문제가 있을수 있다.  \n\n`Using Where`은 직접적으로 대응되는 JSON 속성이 없고 `attached_condition` 속성은 사용되는 모든 `WHERE` 조건을 포함한다.\n\n* Using temporary  \n쿼리를 해결하기위해 `MySQL`은 결과를 보관하기위해 임시테이블을 생성할 필요가 있다. 이는 일반적으로 쿼리가 컬럼을 다르게 나열하는 `GROUP BY`와 `ORDER BY`절을 포함하면 발생한다.  \n\n* Using sort_union(...), Using union(...), Using intersect(...)  \n이런것들은 `index_merge` 조인타입에 대한 인덱스 스캔이 어떻게 병합되는지를 보여주는 특별한 알고리즘을 나타낸다.\n\n* Using MRR  \n테이블은 다중범위 읽기 최적화 전략을 사용하여 읽힌다.  \n\n* Using join buffer (Block Nested Loop), Using join buffer (Batched Key Access), Using join buffer (hash join)  \n이전 조인의 테이블은 조인버퍼로 부분적으로 읽히고, 그 행들은 버퍼에서 현재 테이블과 조인을 수행하는데 사용된다. \n(Block Nested Loop)는 Block Nested-Loop 알고리즘 사용을 나타내고,(Batched Key Access)는 Batched Key Access 알고리즘 사용을 나타내며 (hash join)은 해시조인 사용을 나타낸다.\n즉 `EXPLAIN` 출력의 이전라인에 있는 테이블의 키가 버퍼에 저장되고, 일치하는 행은 `Using join buffter`가 나타나는 줄로 보여진 테이블에서 일괄적으로 가져온다.\n\n* Using index for skip scan  \n스캔 스킵에대한 인덱스를 나타낸다.\n\n* using index for group-by  \n`Using index` 테이블 접근 방법과 유사하며, `Using index for group-by`sms `MySQL`이 실제테이블에 추가적인 어떤 디스크 접근도 없이 `GROUP BY` 또는 `DISTINT` 쿼리의 모든 컬럼을 검색하는데 사용할수 있는 인덱스를 찾았다는 것을 나타낸다.\n게다가, 각 그룹에대해 몇개의 인덱스 항목만 읽도록하는 가장 효융적인 방식으로 인덱스가 사용된다.\n\n* Using index condition  \n테이블은 인덱스 튜블을 접근하여 읽고 전체 테이블 행을 읽을것인지 결정하기위해 먼저 테스트한다. 이 방법의 경우, 인덱스 정보는 필수가 아닌한 전체 테이블 행을 읽는것을 연기(\"푸시다운\")하는 데 사용된다.\n\n* Using index  \n실제 행을 읽기위한 추가적인 탐색 없이 인덱스트리에서 정보만을 사용하여 테이블에서 컬럼 정보를 가져온다. 이 전략은 단일 인덱스의 부분인 컬럼만 사용하는 쿼리일때 사용될 수 있다.\nInnoDB에서 사용자정의 클러스터드 인덱스(기본키)를 가진 테이블인 경우, `Extra` 컬럼에 `Using index`가 없더라도 해당 인덱스가 사용될 수 있다. 이는 `type`이 인덱스와 `key`가 `PRIMARY`인 경우에 해당한다.\n사용된 커버링 인덱스에 대한 정보는 `EXPLAIN FORMAT=TRADITIONAL`과 `EXPLAIN FORMAT=JSON`에 대해 보여진다.\n\n* Using filesort  \n`MySQL`은 정렬된 순서로 행을 검색하는 방법을 찾기위해 한번 더 데이터를 훑어야 한다.\n정렬은 조인타입에 따라 모든 행을 검토하면서 `WHERE`절과 일치하는 모든 행에 대해 행을 가리키는 포인터와 정렬키를 저장하는 방식으로 수행된 다음 키들이 정렬되고 정렬된 순서로 행들을 가져온다.\n"
  },
  {
    "path": "/docs/framework/spring/transaction-manager",
    "header": {
      "layout": "post",
      "title": "스프링의 트랜잭션 관리자",
      "categories": [
        "framework",
        "spring"
      ],
      "tags": [
        "Spring",
        "Spring Boot",
        "Transaction",
        "Transaction Manager"
      ],
      "date": 1717495080000,
      "thumbnail": "/post/framework/spring/spring-transaction-manager.svg",
      "current-company": "NEOWIZ",
      "current-position": "Software Engineer",
      "summary": "Transaction Manager",
      "excerpt_separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "프레임워크",
        "스프링"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "트랜잭션 관리자",
            "title": "트랜잭션 관리자",
            "fragment": "root-0",
            "children": [
              {
                "rank": 3,
                "origin": "설명",
                "title": "설명",
                "fragment": "root-0-0",
                "children": []
              },
              {
                "rank": 3,
                "origin": "필드",
                "title": "필드",
                "fragment": "root-0-1",
                "children": []
              }
            ]
          },
          {
            "rank": 2,
            "origin": "설정기능",
            "title": "설정기능",
            "fragment": "root-1",
            "children": [
              {
                "rank": 3,
                "origin": "final setTransactionSynchronizationName(String constantName)",
                "title": "final setTransactionSynchronizationName(String constantName)",
                "fragment": "root-1-0",
                "children": []
              },
              {
                "rank": 3,
                "origin": "final setTransactionSynchronization( int transactionSynchronization)",
                "title": "final setTransactionSynchronization( int transactionSynchronization)",
                "fragment": "root-1-1",
                "children": []
              },
              {
                "rank": 3,
                "origin": "final setDefaultTimeout(int defaultTimeout)",
                "title": "final setDefaultTimeout(int defaultTimeout)",
                "fragment": "root-1-2",
                "children": []
              },
              {
                "rank": 3,
                "origin": "final setNestedTransactionAllowed(boolean nestedTransactionAllowed)",
                "title": "final setNestedTransactionAllowed(boolean nestedTransactionAllowed)",
                "fragment": "root-1-3",
                "children": []
              },
              {
                "rank": 3,
                "origin": "final setValidateExistingTransaction(boolean validateExistingTransaction)",
                "title": "final setValidateExistingTransaction(boolean validateExistingTransaction)",
                "fragment": "root-1-4",
                "children": []
              },
              {
                "rank": 3,
                "origin": "final setGlobalRollbackOnParticipationFailure(boolean gloabalRollbackOnParticipationFailure)",
                "title": "final setGlobalRollbackOnParticipationFailure(boolean gloabalRollbackOnParticipationFailure)",
                "fragment": "root-1-5",
                "children": []
              },
              {
                "rank": 3,
                "origin": "final setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly)",
                "title": "final setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly)",
                "fragment": "root-1-6",
                "children": []
              },
              {
                "rank": 3,
                "origin": "final setRollbackOnCommitFailure(boolean rollbackOnCommitFailure)",
                "title": "final setRollbackOnCommitFailure(boolean rollbackOnCommitFailure)",
                "fragment": "root-1-7",
                "children": []
              }
            ]
          },
          {
            "rank": 2,
            "origin": "PlatformTransactionManager 구현체",
            "title": "PlatformTransactionManager 구현체",
            "fragment": "root-2",
            "children": [
              {
                "rank": 3,
                "origin": "final getTransaction(TransactionDefinition definition)",
                "title": "final getTransaction(TransactionDefinition definition)",
                "fragment": "root-2-0",
                "children": []
              },
              {
                "rank": 3,
                "origin": "doGetTransaction",
                "title": "doGetTransaction",
                "fragment": "root-2-1",
                "children": []
              },
              {
                "rank": 3,
                "origin": "handleExistingTransaction",
                "title": "handleExistingTransaction",
                "fragment": "root-2-2",
                "children": []
              },
              {
                "rank": 3,
                "origin": "doBegin",
                "title": "doBegin",
                "fragment": "root-2-3",
                "children": []
              },
              {
                "rank": 3,
                "origin": "final commit(TransactionStatus status)",
                "title": "final commit(TransactionStatus status)",
                "fragment": "root-2-4",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "트랜잭션 관리자의 공통 처리사항을 알아보자",
    "content": "\n## 트랜잭션 관리자\n\n스프링은 트랜잭션 관리자를 추상화하여, 다양한 데이터 핸들링 프레임워크를 유연하게 사용할 수 있다.\n`@Transactional` 어노테이션을 사용하더라도, 데이터 핸들링 프레임워크 (JPA, JDBC, Hibernate 등)에 따라 다르게 동작한다.\n\n🔷 트랜잭션 관리자의 구현 목록:\n\n- DataSourceTransactionManager\n- HibernateTransactionManager\n- JdbcTransactionManager\n- JpaTransactionManager\n- JtaTransactionManager\n- KafkaTransactionManager\n- ResourcelessTransactionManager\n\n### 설명\n`org.springframework.transaction.jta.JtaTransactionManager` 같이 실제 플랫폼 트랜잭션매니저의 기반으로 사용되는 Spring의 표준 트랜잭션 작업흐름 구현체, 추상 기본  클래스이다.\n\n이 기본 클래스는 다음의  작업흐름을 처리를 제공한다.\n\n* 트랜잭션이 있는지 판단\n* 적절한 전파 동작을 적용\n* 필요하다면 트랜잭션을 중단하고 재개\n* 커밋 시 rollback-only 표시를 확인\n* 롤백 시 적절한 수정 사항을 적용 (실제 롤백 또는  rollback-only를 설정해서)\n* 등록된 동기화 콜백을 트리거 (트랜잭션 동기화가 활성화 된 경우)\n\n하위클래스는 트랜잭션의 특정 상태에대한 특정 템플릿 메서드를 구현해야 함 (예:  중단, 재개, 커밋, 롤백전). 가장중요한 건 추상화와 실제 구현체로 제공되어야만 하는것이고, 그외에는 기본값이 제공되므로 `overriding` 선택사항.  \n\n트랜잭션 동기화는 트랜잭션 완료시간에 호출되는 콜백을 등록하기위한 일반적인 메커니즘. 이것은 JTA 트랜잭션 내에서 동작할때 JDBC, 하이버네이트, JPA 등등에 대한 데이터 접근클래스로부터 내부적으로 사용. (트랜잭션 완료 시간에 닫히기 위해 트랜잭션 내에서 개방된 리소스를 등록. 예 : 트랜잭션 내 동일한 하이버네이트 세션의 재사용을 위해 )  \n\n이 클래스의 상태는 직렬화 가능하여  트랜잭션 인터셉터를 전달하는 프록시와 마찬가지로 트랜잭션 전략를 직렬화 가능. 이것은 하위클래스에 달려있는데, 상태를 직렬화 되게 만들고 싶다면 진행. 이 경우에 하위클래스는 마커 인터페이스인 `java.io.Seializable` 를 구현해야하며 일시적인 상태를 복원해야하는경우 잠재적으로 `private` readObject()  메소드 (자바 직렬화 규칙에따라 )를 구현해야함.  \n\n\n### 필드\n\n* SYNCHRONIZATION_ALWAYS = 0;\n    * 트랜잭션 동기화를 항상 활성화며 기존 백엔드 트랜잭션이 없는 PROPAGATION_SUPPORTS인 \"비어있는\" 트랜잭션 까지도 적용.\n\n* SYNCHRONIZATION_ON_ACTUAL_TRANSACTION = 1;\n    * 실제 트랜잭션을 위해서만 트랜잭션 동기화를 활성화 하며, 기존 백엔드 트랜잭션이 없는  PROPAGATION_SUPPORTS 인 비어있는 트랜잭션에는 적용되지 않음.\n\n* SYNCHRONIZATION_NEVER = 2;\n    * 실제 트랜잭션까지도 트랜잭션동기화를 활성화하지 않음.\n\n## 설정기능\n`AbstactPlatformTransactionManager`는 트랜잭션 동기화를 등록하고 관리할 수 있음.\n\n### final setTransactionSynchronizationName(String constantName)\n\n* 이 클래스의 해당 상수명으로 트랜잭션 동기화를 설정.\n\n\n\n### final setTransactionSynchronization( int transactionSynchronization)\n\n* 이 트랜잭션 매니저가 Thread-bound 트랜잭션 동기화 지원을 활성화 해야만 할때 설정함. 기본값은 `SYNCHRONIZATION_ALWAYS`.\n* 참고로 트랜잭션 동기화는 다른 트랜잭션 매니저에 의해 다중 동시 트랜잭션을 지원하지 않음. 한개의 트랜잭션 매니저만이 이것을 언제든지 허용할 수 있음.\n\n\n### final setDefaultTimeout(int defaultTimeout)\n\n* 트랜잭션 레벨에 초단위로 명시된 타임아웃이 없는경우 이 트랜잭션 매니저가 적용해야만하는 기본 타임아웃을 명시.\n* 기본값은 근본적인 트랜잭션 인프라 기본 타임아웃(예: 일반적으로, JTA Provider 의 경우 30초)이며, TransactionDefinition.TIMEOUT_DEFAULT 값으로 나타남.\n\n\n\n### final setNestedTransactionAllowed(boolean nestedTransactionAllowed)\n\n* 기본값은 \"false\"이며, 중복 트랜잭을 허용할지 설정.\n* 일반적으로 구체적인 트랜잭션 매니저 하위클래스에 의해 적절한 기본값으로 초기화 됨.\n\n\n### final setValidateExistingTransaction(boolean validateExistingTransaction)\n\n* 기존 트랜잭션에 참여하기 전에 검증돼야 하는지 설정.\n* 기존 트랜잭션(예: PROPAGATION_REQUIRED 또는 PROPAGATION_SUPPORT가 기존 트랜잭션을 만나는 경우)에 참여할때, 이 외부 트랜잭션의 형질은 내부 트랜잭션영역에 까지도 적용.\n* 유효성 검사는 내부 트랜잭션 정의에서 호환되지 않는 고립레벨 및 읽기전용 설정을 감지하고 해당 예외를 throw하여 이에따라 참여를 거부.\n* 기본값은 \"false\"이며, 내부 트랜잭션 설정을 느슨하게 무시하여, 외부 트랜잭션의 형질로 간단히 재정의.\n* \"true\" 플래그로 변경은 엄격한 유효성검사를 강제하도록 명령.\n\n\n### final setGlobalRollbackOnParticipationFailure(boolean gloabalRollbackOnParticipationFailure)\n\n* 참여하는 트랜잭션이 실패한후에 기존 트랜잭션을 `rollback-only`로 전역적으로 표시할지 설정.\n* 기본값은 \"true\"이며, 참여하는 트랜잭션(예: PROPAGATION_REQUIRED 또는 PROPAGATION_SUPPORT가 기존 트랜잭션을 만나는 경우)이 실패한다면, 트랜잭션은 `rollback-only`로 전역적으로 마킹. *이런 트랜잭션에 오직 가능한 결과는 롤백.*  \n* “false”로 변경시: 트랜잭션 발신자가 롤백 결정을 내림. 만약 참여하는 트랜잭션이 예외로 실패한다면, 호출자는 트랜잭션 내 다른경로로 계속하기로 결정할 수 있음. 하지만, 이는 모든 참여 자원이 데이터 액세스 실패 후에도 트랜잭션 커밋을 향해 계속할 수 있는 경우에만 작동. (일반적으로 Hibernate 세션은 해당되지 않는 경우임. 예: JDBC insert/update/delete 동작들의 sequence)  \n* **참고:** 이 플래그는 일반적으로 데이터 접근 작업(TransactionInterceptor가 롤백룰에 따라 PlatformTransactionManager.rollback() 호출을 트리거하는 경우)으로 인해 throw 된 예외가 발생한 하위 트랜잭션에 대한 명시적 롤백시도에만 적용. 플래그가 비활성화라면 호출자는 하위 트랜잭션의 롤백룰과 관계없이 예외를 처리하고 롤백을 결정할 수 있음. 그러나 이 플래그는 하위트랜잭션에 명시적 `setRollbackOnly` 호출을 적용하지 않으므로,이는  항상 최종적인 글로벌 롤백(`rollback-only` 호출후 예외가 발생하지 않을 수 있기 때문에 )을 유발.\n* 하위트랜잭션의 실패처리에 대한 추천드리는 방법은 글로벌 트랜잭션이 하위트랜잭션의 시작시 가져온 세이브포인트로 롤백될 수 있도록 하는 “중복 트랜잭션” 임. `PROPAGATION_NESTED`는 정확히 이러한 의미를 제공함. 그러나, 중복 트랜잭션 지원이 가능할 때만 동작함. `DataSource TransactionManager` 경우지만, `JtaTransactionManager`의 경우는 아님.\n\n\n### final setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly)\n* 트랜잭션이 `rollback-only`로 전역적으로 표시된 경우에 조기 실패할 것 인지 설정.\n* 기본값은 “false” 이며, 가장 바깥쪽의 트랜잭션 바운더리에서만 `UnexpectedRollbackExcetpion`을 발생시킴. 내부 트랜잭션 바운더리 내에서 전역 rollback-only 마커가 처음 감지하여 즉시 `UnexpectedRollbackException`을 발생시키려면 이 값을 변경해야함.\n* 참고로 스프링 2.0부터 전역  rollback-only 표시자에 대한 조기실패 동작이 통합 됨. (모든 트랜잭션 매니져는 기본적으로 가장 바깥쪽의 트랜잭션 바운더리에서만 `UnexpectedRollbackException`을 발생시킴.) 이 허용 예를들어 동작이 실패하고 트랜잭션이 완료되지 않은 후에도 유닛 테스트를 계속할 수 있음. 모든 트랜잭션 매니저는 이 플래그가 명시적으로 \"true\"로 설정됐을 때만 조기실패 시킴.\n\n### final setRollbackOnCommitFailure(boolean rollbackOnCommitFailure)\n*  `doCommit`메소드 호출의 실패에 `doRollback`이 수행 해야만하는지 설정함. 일반적으로 필요하지 않고 후속 롤백 예외로 커밋 예외를 무시할 가능성이 있으며, 따라서 피해야함.\n\n## PlatformTransactionManager 구현체\n\n\n### final getTransaction(TransactionDefinition definition)\n\n```java\n@Override\n\tpublic final TransactionStatus getTransaction(@Nullable TransactionDefinition definition)\n\t\t\tthrows TransactionException {\n\n\t\t// Use defaults if no transaction definition given.\n\t\tTransactionDefinition def = (definition != null ? definition : TransactionDefinition.withDefaults());\n\n\t\tObject transaction = doGetTransaction();\n\t\tboolean debugEnabled = logger.isDebugEnabled();\n\n\t\tif (isExistingTransaction(transaction)) {\n\t\t\t// Existing transaction found -> check propagation behavior to find out how to behave.\n\t\t\treturn handleExistingTransaction(def, transaction, debugEnabled);\n\t\t}\n\n\t\t// Check definition settings for new transaction.\n\t\tif (def.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\tthrow new InvalidTimeoutException(\"Invalid transaction timeout\", def.getTimeout());\n\t\t}\n\n\t\t// No existing transaction found -> check propagation behavior to find out how to proceed.\n\t\tif (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {\n\t\t\tthrow new IllegalTransactionStateException(\n\t\t\t\t\t\"No existing transaction found for transaction marked with propagation 'mandatory'\");\n\t\t}\n\t\telse if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||\n\t\t\t\tdef.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||\n\t\t\t\tdef.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {\n\t\t\tSuspendedResourcesHolder suspendedResources = suspend(null);\n\t\t\tif (debugEnabled) {\n\t\t\t\tlogger.debug(\"Creating new transaction with name [\" + def.getName() + \"]: \" + def);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn startTransaction(def, transaction, debugEnabled, suspendedResources);\n\t\t\t}\n\t\t\tcatch (RuntimeException | Error ex) {\n\t\t\t\tresume(null, suspendedResources);\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Create \"empty\" transaction: no actual transaction, but potentially synchronization.\n\t\t\tif (def.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT && logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Custom isolation level specified but no actual transaction initiated; \" +\n\t\t\t\t\t\t\"isolation level will effectively be ignored: \" + def);\n\t\t\t}\n\t\t\tboolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);\n\t\t\treturn prepareTransactionStatus(def, null, true, newSynchronization, debugEnabled, null);\n\t\t}\n\t}\n```\n\n이 구현체는 전파동작을 처리함. doGetTransaction, isExistingTransaction 및 doBegin 메서드를 위임함.\n설정된 값을 먼저확인하고 없다면 기본값으로 세팅하  트랜잭션을 가져옴. 제일먼저 `TransactionDefinition` 기본값 세팅 후 `doGetTransaction`으로 트랜잭션을 불러옴.\n이 메서드에서는 먼저 살펴봐야할 메서드가 3가지정도로 나눌수 있음. `doGetTransaction`, `handleExistingTransaction`, `doBegin`을 보며 유추함.\n\n\n### doGetTransaction\n\n* 현재 트랜잭션 상태에대한 트랜잭션 객체를 리턴하는 메서드임.\n* 반환된 객체는 일반적으로 변경할수 있는 방식에 해당하는 트랜잭션을 전달하여 구체적인 트랜잭션 매니저 구현체에 명시됨.\n\n\n이 메서드는 추상화되어있고 각 구현체인 Transaction Manager들에 의하여 구현되있음. 일반적으로 `JDBC`를 사용하는 `DataSourceTransactionManager`를 예:\n\n```java\n@Override\nprotected Object doGetTransaction() {\n  DataSourceTransactionObject txObject = new DataSourceTransactionObject();\n  txObject.setSavepointAllowed(isNestedTransactionAllowed());\n  ConnectionHolder conHolder =\n      (ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource());\n  txObject.setConnectionHolder(conHolder, false);\n  return txObject;\n}\n```\n`line 4`에서 세이브포인트를 이 트랜잭션내에서 허용될 것인지를 정하고 매개변수로 중첩트랜잭션의 허용 여부을 보냄. `line 5`에 `ConnnectionHolder`가 컨넥션 및 세이브 포인트를 생성함. 아래 코드를 보시면 세이브포인트의 네이밍을 확인할 수 있음.\n\n```java\npublic Savepoint createSavepoint() throws SQLException {\n\t\tthis.savepointCounter++;\n\t\treturn getConnection().setSavepoint(SAVEPOINT_NAME_PREFIX + this.savepointCounter);\n\t}\n```\n트랜잭션 내에서 `SAVEPOINT_0`, `SAVEPOINT_1` .. 이런식으로 생성되면서 갯수를 체크함. `ConnectionHolder`는 현재 설정된 DataSource로 `Connnection`을 생성하여 할당. 결과적으로 세이브포인트 사용 여부와 컨넥션을 가지고 트랜잭션 객체를 반환함.\n\n### handleExistingTransaction\n트랜잭션이 존재하는지 확인하고 존재한다면 `handleExistingTransaction`으로 보내버림.\n\n```java\nprivate TransactionStatus handleExistingTransaction(\n\t\t\tTransactionDefinition definition, Object transaction, boolean debugEnabled)\n\t\t\tthrows TransactionException {\n\n\t\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {\n\t\t\tthrow new IllegalTransactionStateException(\n\t\t\t\t\t\"Existing transaction found for transaction marked with propagation 'never'\");\n\t\t}\n\n\t\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {\n\t\t\tif (debugEnabled) {\n\t\t\t\tlogger.debug(\"Suspending current transaction\");\n\t\t\t}\n\t\t\tObject suspendedResources = suspend(transaction);\n\t\t\tboolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);\n\t\t\treturn prepareTransactionStatus(\n\t\t\t\t\tdefinition, null, false, newSynchronization, debugEnabled, suspendedResources);\n\t\t}\n\n\t\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {\n\t\t\tif (debugEnabled) {\n\t\t\t\tlogger.debug(\"Suspending current transaction, creating new transaction with name [\" +\n\t\t\t\t\t\tdefinition.getName() + \"]\");\n\t\t\t}\n\t\t\tSuspendedResourcesHolder suspendedResources = suspend(transaction);\n\t\t\ttry {\n\t\t\t\treturn startTransaction(definition, transaction, debugEnabled, suspendedResources);\n\t\t\t}\n\t\t\tcatch (RuntimeException | Error beginEx) {\n\t\t\t\tresumeAfterBeginException(transaction, suspendedResources, beginEx);\n\t\t\t\tthrow beginEx;\n\t\t\t}\n\t\t}\n\n\t\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {\n\t\t\tif (!isNestedTransactionAllowed()) {\n\t\t\t\tthrow new NestedTransactionNotSupportedException(\n\t\t\t\t\t\t\"Transaction manager does not allow nested transactions by default - \" +\n\t\t\t\t\t\t\"specify 'nestedTransactionAllowed' property with value 'true'\");\n\t\t\t}\n\t\t\tif (debugEnabled) {\n\t\t\t\tlogger.debug(\"Creating nested transaction with name [\" + definition.getName() + \"]\");\n\t\t\t}\n\t\t\tif (useSavepointForNestedTransaction()) {\n\t\t\t\t// Create savepoint within existing Spring-managed transaction,\n\t\t\t\t// through the SavepointManager API implemented by TransactionStatus.\n\t\t\t\t// Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.\n\t\t\t\tDefaultTransactionStatus status =\n\t\t\t\t\t\tprepareTransactionStatus(definition, transaction, false, false, debugEnabled, null);\n\t\t\t\tstatus.createAndHoldSavepoint();\n\t\t\t\treturn status;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Nested transaction through nested begin and commit/rollback calls.\n\t\t\t\t// Usually only for JTA: Spring synchronization might get activated here\n\t\t\t\t// in case of a pre-existing JTA transaction.\n\t\t\t\treturn startTransaction(definition, transaction, debugEnabled, null);\n\t\t\t}\n\t\t}\n\n\t\t// Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED.\n\t\tif (debugEnabled) {\n\t\t\tlogger.debug(\"Participating in existing transaction\");\n\t\t}\n\t\tif (isValidateExistingTransaction()) {\n\t\t\tif (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {\n\t\t\t\tInteger currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();\n\t\t\t\tif (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {\n\t\t\t\t\tConstants isoConstants = DefaultTransactionDefinition.constants;\n\t\t\t\t\tthrow new IllegalTransactionStateException(\"Participating transaction with definition [\" +\n\t\t\t\t\t\t\tdefinition + \"] specifies isolation level which is incompatible with existing transaction: \" +\n\t\t\t\t\t\t\t(currentIsolationLevel != null ?\n\t\t\t\t\t\t\t\t\tisoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :\n\t\t\t\t\t\t\t\t\t\"(unknown)\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!definition.isReadOnly()) {\n\t\t\t\tif (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {\n\t\t\t\t\tthrow new IllegalTransactionStateException(\"Participating transaction with definition [\" +\n\t\t\t\t\t\t\tdefinition + \"] is not marked as read-only but existing transaction is\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tboolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);\n\t\treturn prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null);\n\t}\n```\n`PROPAGATION_NEVER`은 현재 트랜잭션이 존재한다면 바로 예외를 throwing 하고,  `PROPAGATION_NOT_SUPPORTED`는 현재 트랜잭션을 중지함.\n`PROPAGATION_REQUIRES_NEW`는 현재 진행중인 트랜잭션을 중단하고 새로운 커넥션으로 트랜잭션을 시작하기 때문에 `startTransaction()`로 보냄.\n이처럼 다는 설명하지 못하지만 각 전파옵션과 현재 진행중인 트랜잭션의 유무를 판단하여 트랜잭션(상태)를 리턴함.\n\n### doBegin\n\n```java\n@Override\nprotected void doBegin(Object transaction, TransactionDefinition definition) {\n  DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;\n  Connection con = null;\n\n  try {\n    if (!txObject.hasConnectionHolder() ||\n        txObject.getConnectionHolder().isSynchronizedWithTransaction()) {\n      Connection newCon = obtainDataSource().getConnection();\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"Acquired Connection [\" + newCon + \"] for JDBC transaction\");\n      }\n      txObject.setConnectionHolder(new ConnectionHolder(newCon), true);\n    }\n\n    txObject.getConnectionHolder().setSynchronizedWithTransaction(true);\n    con = txObject.getConnectionHolder().getConnection();\n\n    Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);\n    txObject.setPreviousIsolationLevel(previousIsolationLevel);\n    txObject.setReadOnly(definition.isReadOnly());\n\n    // Switch to manual commit if necessary. This is very expensive in some JDBC drivers,\n    // so we don't want to do it unnecessarily (for example if we've explicitly\n    // configured the connection pool to set it already).\n    if (con.getAutoCommit()) {\n      txObject.setMustRestoreAutoCommit(true);\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"Switching JDBC Connection [\" + con + \"] to manual commit\");\n      }\n      con.setAutoCommit(false);\n    }\n\n    prepareTransactionalConnection(con, definition);\n    txObject.getConnectionHolder().setTransactionActive(true);\n\n    int timeout = determineTimeout(definition);\n    if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {\n      txObject.getConnectionHolder().setTimeoutInSeconds(timeout);\n    }\n\n    // Bind the connection holder to the thread.\n    if (txObject.isNewConnectionHolder()) {\n      TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());\n    }\n  }\n\n  catch (Throwable ex) {\n    if (txObject.isNewConnectionHolder()) {\n      DataSourceUtils.releaseConnection(con, obtainDataSource());\n      txObject.setConnectionHolder(null, false);\n    }\n    throw new CannotCreateTransactionException(\"Could not open JDBC Connection for transaction\", ex);\n  }\n}\n```\n\n이 메서드는 주어진 트랜잭션 정의에따라 의미하  새로운 트랜잭션을 시작함. 이 추상 트랜잭션 매니저에의해 이미 처리되기 때문에 전파동작을 적용하는것에 대해 걱정할 필요없음.   \n이 메소드는 트랜잭션 매니저가 실제로 새로운 트랜잭션을 시작하기로 결정할때 호출함. 이전 트랜잭션이 없거나, 이전트랜잭션이 중단됐거나 둘중 하나임.\n\n특별한 경우는 세이브 포인트 없이 중첩된 트랜잭션임. `useSavepointForNestedTransaction()`이 \"false\"를 리턴 한다면, 이 메소드는 필요할때 중첩된 트랜잭션을 시작을 호출함. 그런 흐름에, 활성트랜잭션이 있음. (이 메소드의 구현체는 이를 감지하고 적절한 중첩 트랜잭션을 시작해야함).\n\n### final commit(TransactionStatus status)\n이 커밋 구현은 기존 트랜잭션 및 프로그래밍 방식 롤백 요청에 참여하는 것을 처리함. `isRollbackOnly`및 `doCommit`그리고 `rollback`에 위임함.\n\n```java\n@Override\n\tpublic final void commit(TransactionStatus status) throws TransactionException {\n\t\tif (status.isCompleted()) {\n\t\t\tthrow new IllegalTransactionStateException(\n\t\t\t\t\t\"Transaction is already completed - do not call commit or rollback more than once per transaction\");\n\t\t}\n\n\t\tDefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;\n\t\tif (defStatus.isLocalRollbackOnly()) {\n\t\t\tif (defStatus.isDebug()) {\n\t\t\t\tlogger.debug(\"Transactional code has requested rollback\");\n\t\t\t}\n\t\t\tprocessRollback(defStatus, false);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {\n\t\t\tif (defStatus.isDebug()) {\n\t\t\t\tlogger.debug(\"Global transaction is marked as rollback-only but transactional code requested commit\");\n\t\t\t}\n\t\t\tprocessRollback(defStatus, true);\n\t\t\treturn;\n\t\t}\n\n\t\tprocessCommit(defStatus);\n\t}\n```\n"
  },
  {
    "path": "/docs/computer/hard-disk-1",
    "header": {
      "layout": "post",
      "title": "HDD(Hard Drive Disk)는 어떻게 동작하는가",
      "categories": [
        "computer"
      ],
      "tags": [
        "HDD",
        "Hard Drive Disk",
        "하드디스크",
        "Hardware",
        "하드웨어",
        "저장장치",
        "컴퓨터"
      ],
      "date": 1695125760000,
      "thumbnail": "/post/computer/hdd.png",
      "profile-image": "/post/profile/winkkom.png",
      "current-company": "NEOWIZ",
      "current-position": "Software Engineer",
      "summary": "하드디스크란 무엇이고, 어떻게 동작할까?",
      "excerpt-separator": "<!--more-->",
      "hide": true,
      "breadcrumbs": [
        "문서",
        "컴퓨터"
      ],
      "images": [
        {
          "src": "/post/computer/hdd_consist_of.png",
          "alt": "하드디스크 구성요소의 설명"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "하드디스크의 구성",
            "title": "하드디스크의 구성",
            "fragment": "root-0",
            "children": [
              {
                "rank": 3,
                "origin": "Head",
                "title": "Head",
                "fragment": "root-0-0",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "대표적인 저장장치 하드디스크는 어떻게 동작할까?\n하드디스크의 구성과, 동작원리를 파해쳐보자.",
    "content": "\n## 하드디스크의 구성\n\n![하드디스크 구성요소의 설명](/post/computer/hdd_consist_of.png)\n\n먼저 하드디스크가 어떤 구성으로 이루어져있는지를 알기전에, 동작과정을 간단하게 살펴보자.\n고정되어있는 `Platter(플래터)`는 `Spindle(스핀들)`에 의해 돌아가며, 가깝게 붙어있는 `Head(헤드)`가 `플래터`의 저장된 값을 읽는다.\n\n### Head \n\n"
  },
  {
    "path": "/wiki/about-electron",
    "header": {
      "layout": "wiki",
      "title": "전기에너지를 만드는 전자",
      "tags": [
        "원자",
        "전자",
        "원자핵",
        "렙톤"
      ],
      "date": 1694348520000,
      "profile-image": "/post/profile/winkkom.png",
      "current-company": "NEOWIZ",
      "current-position": "Software Engineer",
      "summary": "전자란?",
      "excerpt-separator": "<!--more-->",
      "hide": true,
      "breadcrumbs": [
        "문서",
        "electric"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": []
      }
    },
    "description": "",
    "content": "전자는 대부분의 원자에 모두 존재한다.\n원자가 전기적으로 중성이려면, 음전하를 띄고 있는 전자와, 양전하를 띄고있는 양성자의 개수가 동일해야 한다.\n따라서, 자연에 존재하는 모든 원소는 전자를 갖고있다고 봐도 된다.\n\n전자는 양전하에서 음전하로 이동하게 되는데, 이를 이용해 전기 에너지를 흐르게 할 수 있다.\n`(+)양전하` 에서 `(-)음전하`의 방향으로 전자가 이동하게 되면, 그 반대방향으로 전기장이 만들어진다.\n전기에너지는 그 전기장을 통에 전달이 된다.  \n\n<!--more-->\n"
  },
  {
    "path": "/wiki/about-atom",
    "header": {
      "layout": "wiki",
      "title": "만물을 이루는 원자",
      "tags": [
        "원자",
        "전자",
        "원자핵",
        "양성자",
        "중성자",
        "반도체"
      ],
      "date": 1693486620000,
      "profile-image": "/post/profile/winkkom.png",
      "current-company": "NEOWIZ",
      "current-position": "Software Engineer",
      "summary": "원자란?",
      "excerpt-separator": "<!--more-->",
      "hide": true,
      "breadcrumbs": [
        "문서",
        "electric"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": []
      }
    },
    "description": "",
    "content": "원자는 모든 물질을 이루는 가장 기본적인 입자이다. \n원자핵과 그 주변을 이동하는 전자로 구성되어있다. \n원자핵을 구성하는 핵자는 양성자와 중성자가 있으며, 화학적 또는 물리적 방법으로 분해할 수 없다.\n\n일반적으로 원자핵을 양전하를 띄고, 전자는 음전하를 띈다. \n원자핵에서 양성자가 양전하를 띄게 되는데,  해당 양전하의 개수와 전자의 개수가 같을 때 가장 안정적으로 전기적인 중성 상태가 된다. \n즉, 전하를 띄지 않는다. 양성자는 바꿀 수 없지만, 전자는 다른 원자로 이동시킬 수 있기 때문에 양전하와 음전하의 개수가 달라지게 된다.\n\n이때, 양전하의 개수보다 음전하(전자)의 개수가 많으면 음이온, 적으면 양이온이라고 칭하기도 한다. \n전자는 원자핵 주변을 돌게 되는데 이때 이동 속도는 약 30만 km (진공 상태의 빛의 속도)이다. \n전자가 이동하는 궤도는 양자 역학으로 인해 일정하지 않다고 한다. \n전자의 수(또는 양성자의 수)에 따라 원자번호가 결정되기 때문에 우리가 과학적으로 정의하는 원소가 고유성을 가질 수 있는 이유이기도 하다. \n양성자를 비롯한 핵자의 수가 바뀌는건 핵융합과 핵분열이 대표적이다.\n\n전자는 원자핵 주위를 돌며 , 원자의 가장 안쪽 핵자의 주변부터 원자의 밖의 방향으로 껍질처럼 배치된 위치에서 운동한다. \n또한 최대로 배치될 수 있는 이 개수는 (양성자의 개수와 같아야 하기 때문에) 정해져 있다.  \n전자는 외부로부터 에너지를 가하면, 가장자리부터 떨어져 나가며, 모든 전자가 떨어져 나가, 원자핵만 남은 경우 플라즈마라고 한다.\n<!--more-->\n\n"
  },
  {
    "path": "/docs/tool/customize-markdown-it",
    "header": {
      "layout": "post",
      "title": "markdown-it의 Renderer Rule",
      "categories": [
        "tool"
      ],
      "tags": [
        "markdown-it",
        "typescript"
      ],
      "date": 1689329820000,
      "thumbnail": "/post/tool/customize-markdown-it.webp",
      "current-company": "Herit Corporation",
      "current-position": "Backend Server Developer",
      "summary": "Markdown it 규칙 파헤치기",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "도구"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "개요::overview",
            "title": "개요",
            "fragment": "overview",
            "children": [
              {
                "rank": 3,
                "origin": "적용 전::before-customize",
                "title": "적용 전",
                "fragment": "before-customize",
                "children": []
              },
              {
                "rank": 3,
                "origin": "적용 후::after-customize",
                "title": "적용 후",
                "fragment": "after-customize",
                "children": []
              }
            ]
          },
          {
            "rank": 2,
            "origin": "분석::analysis",
            "title": "분석",
            "fragment": "analysis",
            "children": [
              {
                "rank": 3,
                "origin": "Render Rule (규칙)::renderer-rule",
                "title": "Render Rule (규칙)",
                "fragment": "renderer-rule",
                "children": []
              }
            ]
          },
          {
            "rank": 2,
            "origin": "템플릿 규칙 적용::apply-template-rule",
            "title": "템플릿 규칙 적용",
            "fragment": "apply-template-rule",
            "children": [
              {
                "rank": 3,
                "origin": "규칙 수정::modify-rule",
                "title": "규칙 수정",
                "fragment": "modify-rule",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "javascript의 마크다운 파서인 markdown-it 라이브러리를 커스텀해서 사용해보자.",
    "content": "\n## 개요::overview\n\n`markdown-it`은 대중적으로 많이 알려진 javascript markdown parser library이다.\n\n이글은 마크다운이 무엇 인지에 대해서는 설명하지 않는다. 그저 개인 블로그를 직접 만드는 입장에서 골치덩이인 마크다운 파서를 어떻게하면 조금더 유용하게 쓸수 있을까 고민해보며 만들면서 작성하였다.\n\n예를 들어 `> BlockQuote`를 작성한다고 가정했을때. 단순히 블럭으로 묶는 것보다 `> BlockQuote {{ \"type\": \"warning\" }}`과 같이 추가적인 템플릿 구문을 추가하여, 경고 스타일의 블럭으로 보여 줄 수도 있을 것이다. 이를 하기 위해서는 기존 `markdown` 해석 형식에서 더 나아가 새로운 템플릿 해석 로직을 추가해야한다. 아래 코드를 보고 좀 더 쉽게 이해해보자.\n\n\n\n### 적용 전::before-customize\n\n*Markdown*\n\n```markdown\n> 준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다.\n```\n\n*HTML*\n\n```html\n<blockquote>\n  준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다.\n</blockquote>\n```\n\n\n\n### 적용 후::after-customize\n\n*Markdown*\n\n```markdown\n> 준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다.\n:{ \"type\": \"warning\" }\n```\n\n*HTML*\n\n```html\n<blockquote class=\"warning\">\n  <p>준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다.</p>\n</blockquote>\n```\n\n이는 더 많은 정보를 담을수 있으며, 동시에 추가적인 스타일로 시각적인 효과를 주어, 더 나은 가독성을 만들 수 있다.\n\n물론 이렇게 만드려면 사용하려는 markdown 구문마다 모두 규칙을 만들어 줘야한다.\n\n`Markdown-it` 같은 경우 많은 사람들이 블로그 제작시 사용하지만, 실제로 커스텀할 수 있는 `Renderer Rule(랜더링을 하기 위한 규칙)` 같은 기능은 사용하지 않는다. 사실 잘 알려져 있지도 않기 때문에, 많이 사용하지 않는것 일 수 있다.  자신의 블로그를 대충 꾸미고 싶은 사람은 없을테니 이런 방식을 알려 조금이라도 쉽게 이해를 돕고, 나 또한 정리를 하며 다시한번 정립하고 싶다.\n\n\n\n## 분석::analysis\n\n### Render Rule (규칙)::renderer-rule\n\n`Renderer Rule(이하 *규칙)` 같은 경우는 `Markdown-it`에서 제공하는 내부적인 규칙의 흐름이다.\n\n```typescript\nimport MarkdownIt from 'mardown-it';\n\nconst markdown = new MarkdownIt();\nconsole.log('rules: ', Object.keys(markdown.renderer.rules));\n// Output\n// rules: ['code_inline', 'code_block', 'fence', 'image', 'hardbreak', 'softbreak', 'text', 'html_block', 'html_inline']\n```\n\n위는 기본적으로 제공하는 규칙이며, 대략적으로 9개로 볼 수 있다. 이 배열에 명시적으로 있지 않은 요소는 기본규칙이 적용 된다. 예를 들어 `bullet_list_opend` 규칙이 정의 되어 있지 않았으므로, `markdown-it`은 `HTML`로 해석을 시도할 때, `Renderer.prototype.renderToken`이라는 일반 렌더러가 사용된다.\n\n\n\n새로운 마크다운 문법을 창시하지 않는한, 아마 기존 문법에서 조금 수정하는 정도 일 것이다.\n\n따라서 만약 `blockquote_open`이라는 규칙을 수정한다고하면 아래와 같이 할수 있다.\n\n```typescript\nimport MarkdownIt from \"markdown-it\";\nimport Token from \"markdown-it/lib/token\";\nimport Renderer from \"markdown-it/lib/renderer\";\n\nconst md = new MarkdownIt();\nmd.renderer.rules.blockquote_open = (tokens: Array<Token>, index: number, options: MarkdownIt.Options, env: any, self: Renderer): string => {\n\n  return '';\n}\n```\n\n위에서 받아오는 규칙 함수같은 경우 아래와 같이 타입으로 정의 되어있다.\n\n```typescript\ndeclare namespace Renderer {\n    type RenderRule = (tokens: Token[], idx: number, options: MarkdownIt.Options, env: any, self: Renderer) => string;\n\n    interface RenderRuleRecord {\n        [type: string]: RenderRule | undefined;\n        code_inline?: RenderRule | undefined;\n        code_block?: RenderRule | undefined;\n        fence?: RenderRule | undefined;\n        image?: RenderRule | undefined;\n        hardbreak?: RenderRule | undefined;\n        softbreak?: RenderRule | undefined;\n        text?: RenderRule | undefined;\n        html_block?: RenderRule | undefined;\n        html_inline?: RenderRule | undefined;\n    }\n}\n```\n\n| 인자      | 의미                                         |\n| --------- | -------------------------------------------- |\n| *tokens*  | 해석되는 모든 토큰 목록 (각 태그에대한 토큰) |\n| *index*   | 현재 토큰의 키에 해당하는 인덱스             |\n| *options* | `markdown-it`객체가 생성될 때, 정의된 옵션   |\n| *env*     | ???                                          |\n| *self*    | 렌더러 자체에대한 참조                       |\n\n규칙을 수정할 때, 실패한다면 기존 규칙으로 `fallback` 시켜줄수 있는 로직도 추가한다면 아래와 같다.\n\n```typescript\nimport MarkdownIt from \"markdown-it\";\nimport Token from \"markdown-it/lib/token\";\nimport Renderer from \"markdown-it/lib/renderer\";\n\nconst md = new MarkdownIt();\nconst proxy = (tokens: Array<Token>, index: number, options: MarkdownIt.Options, env: any, self: Renderer) => self.renderToken(tokens, index, options);\n//기본 fallback 규칙\nconst defaultBlockquoteOpenRule = md.renderer.rules.blockquote_open || proxy;\n\nmd.renderer.rules.blockquote_open = (tokens: Array<Token>, index: number, options: MarkdownIt.Options, env: any, self: Renderer): string => {\n  return defaultBlockquoteOpenRule(tokens, index, options, env, self);\n}\n\nconst markdownText = '뜨거운 태양아래 시원한 계곡물에 잠수!\\n> 준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다.';\n//HTML 렌더링\nconst html = md.render(markdownText);\n/* html \n<p>뜨거운 태양아래 시원한 계곡물에 잠수!</p>\n<blockquote>\n\t<p>준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다.</p>\n</blockquote>\n*/\n```\n\n*tokens*  인자를 출력해보면 다음과 같다.\n\n```\n[\n\t{ \"type\": \"paragraph_open\", \"tag\": \"p\" ...},\n\t{ \"type\": \"inline\" \"tag\": '' ...},\n\t{ \"type\": \"paragraph_close\", \"tag\": \"p\" ...},\n\t{ \"type\": \"blockquote_open\", \"tag\": \"blockquote\" ...},\n\t{ \"type\": \"paragraph_open\", \"tag\": \"p\" ...},\n\t{ \"type\": \"inline\", \"tag\": '' ...},\n\t{ \"type\": \"paragragh_close\", \"tag\": 'p' ...},\n\t{ \"type\": \"blockquote_close\", \"tag\": \"blockquote\" ...}\n]\n```\n\n어떤 패턴이 보인다. 그렇다. `tokens`는 위에서부터 순서대로 html 을 랜더링할 정보를 가지고 있다.\n\n랜더링 된 `HTML`과 비교하면 직관적으로 알 수 있다.\n\n```html\n<!-- paragraph_open, inline, paragraph_close -->\n<p>뜨거운 태양아래 시원한 계곡물에 잠수!</p>\n<!-- blockquote_open, paragraph_open, inline, paragragh_close, blockquote_close -->\n<blockquote>\n\t<p>준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다.</p>\n</blockquote>\n```\n\n\n\n위와 같이 규칙은 랜더링 되어야할 순서대로 생성되기 때문에, 이미 랜더링 된 토큰을 수정할수 없다.\n\n```html\n<blockquote>\n\t<p>준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다.</p>\n</blockquote>\n```\n\n이런 코드를 보면 순서로 봤을 때 [`blockquote_open` ,`paragraph_open`, `inline`, `paragragh_close`, `blockquote_close`] 로 진행된다.\n\n만약 내가 `blockquote` 태그에 `class=\"waring\"` 이라는 속성을 추가 해주고 싶다면. 이 정보를 전달해야한다.\n\n```markdown\n> 준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다.\n> 또는 심장마비가 올수도 있다.\n:{ \"type\": \"warning\" }\n```\n\n이런 마크다운이 있을때 별다른 처리가 없다면 아래와 같이 전달하는 속성정보가 그대로 전달되어 출력될 것이다.\n\n```markdown\n<blockquote>\n\t<p>준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다. 또는 심장마비가 올수도 있다. :{ \"type\": \"warning\" }</p>\n</blockquote>\n```\n\n따라서 `inline` 토큰에서 \"warning\" 값을 추출해서 `blockquote` 토큰에 `class` 속성으로 추가해줘야한다. 또한 `inline` 토큰에는 실제 노출이 필요한 문자열인 `준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다. 또는 심장마비가 올수도 있다.`만 아래와 같이 남아야한다.\n\n```markdown\n<blockquote class=\"warning\">\n\t<p>준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다. 또는 심장마비가 올수도 있다.<p>\n</bloackquote>\n```\n\n\n\n위에서 이미 랜더링된 토큰은 수정할 수 없다고 했다. 그 말은 현재 상황에서 보면 [`blockquote_open` ,`paragraph_open`, `inline`, `paragragh_close`, `blockquote_close`]  순서로 진행될때 `inline`토큰에서 `blockquote_open` 토큰에 `class` 속성을 주입해도 이미 랜더링된 `blockquote_open` 토큰에는 적용이 안된다는 말이다. 따라서 `blockquote_open` 에서 뒤에 랜더링될 `inline` 토큰을 수정해야 정상적으로 노출될 수 있다.\n\n## 템플릿 규칙 적용::apply-template-rule\n\n\n\n### 규칙 수정::modify-rule\n\n```typescript\nimport MarkdownIt from \"markdown-it\";\nimport Token from \"markdown-it/lib/token\";\nimport Renderer from \"markdown-it/lib/renderer\";\n\nconst md = new MarkdownIt();\nconst proxy = (tokens: Array<Token>, index: number, options: MarkdownIt.Options, env: any, self: Renderer) => self.renderToken(tokens, index, options);\n//기본 fallback 규칙\nconst defaultBlockquoteOpenRule = md.renderer.rules.blockquote_open || proxy;\n\nmd.renderer.rules.blockquote_open = (tokens: Array<Token>, index: number, options: MarkdownIt.Options, env: any, self: Renderer): string => {\n  try {\n    const templateRE = /^([\\s\\S]*?)\\s*:\\s*(\\{[\\s\\S]*\\})\\s*$/mg;\n    const inlineIndex = index +2;\n\n    if (inlineIndex >= tokens.length) throw new Error(`Index out of range from tokens: ${inlineIndex}`);\n    const inline = tokens[inlineIndex];\n    const content = inline.content;\n    const noneMatch = !templateRE.test(content);\n    templateRE.lastIndex = 0;\n    if (!inline.map || noneMatch) {\n      return defaultBlockquoteOpen(tokens, index, options, env, self);\n    }\n    /*\n    * 준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다. 두번째 줄이지! - executed[1]\n    * :{ \"type\": \"warning\" } - executed[2]\n    */\n    const executed = templateRE.exec(content);\n    const text = executed?.[1] ?? '';\n    const attributesStr = executed?.[2];\n    const attributes = JSON.parse(attributesStr ?? '{}');\n    //type = \"warning\"\n    const type = attributes['type'];\n\n\t\t//children은 inline내부에서 랜더링될 자식 토큰들의 목록이다.\n    //여기서 slice는 text값 뒤에 템플릿은 필요없기 때문에 제거해주기 위함이다.\n    const lfCount = countNewline(text);\n    const lineCount = lfCount +1;\n    inline.children = inline.children?.slice(0, lfCount + lineCount) ?? inline.children;\n    inline.content = text ?? inline.content;\n\n    //현재 토큰에 class 속성을 부여한다.\n    const blockquoteOpen = tokens[index];\n    if (type) {\n      blockquoteOpen.attrJoin('class', type);\n    }\n\n    return defaultBlockquoteOpen(tokens, index, options, env, self);\n  } catch (e: Error) {\n    console.error(`Error occurred at parsing token: \"${e.message}\"`);\n    return '';\n  }\n}\n```\n\n---\n\n`:{ \"type\" : \"warning\" }` 템플릿은 뭔가 급조해서 만들어서 만들었기 때문에 자신만의 템플릿을 만들어 더 나은 parser를 구현할 수 있을듯 하다.\n\n사실 기존에도 `chirpy` 같은 Jekyll 테마 같은 경우에는 커스텀 템플릿을 만들어 공유되고 있었다.\n\n"
  },
  {
    "path": "/docs/language/typescript/typescript-getting-start",
    "header": {
      "layout": "post",
      "title": "타입스크립트 시작하기 1 (소개)",
      "categories": [
        "language",
        "typescript"
      ],
      "tags": [
        "Typescript",
        "Javascript",
        "Type"
      ],
      "date": 1681552860000,
      "current-company": "NEOWIZ",
      "current-position": "Software Engineer",
      "profile-image": "/post/profile/profile1.jpg",
      "thumbnail": "/post/typescript/typescript_getting_start.png",
      "summary": "타입스크립트 소개",
      "excerpt-separator": "<!--more-->",
      "hide": true,
      "breadcrumbs": [
        "문서",
        "언어",
        "타입스크립트"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "우리가 아는 자바스크립트",
            "title": "우리가 아는 자바스크립트",
            "fragment": "root-0",
            "children": []
          },
          {
            "rank": 2,
            "origin": "타입스크립트는 무엇인가?",
            "title": "타입스크립트는 무엇인가?",
            "fragment": "root-1",
            "children": []
          },
          {
            "rank": 2,
            "origin": "타입스크립트를 배우기전 ES5 또는 ESNext의 주요 문법을 알아보자",
            "title": "타입스크립트를 배우기전 ES5 또는 ESNext의 주요 문법을 알아보자",
            "fragment": "root-2",
            "children": [
              {
                "rank": 3,
                "origin": "비구조화 할당",
                "title": "비구조화 할당",
                "fragment": "root-2-0",
                "children": []
              },
              {
                "rank": 3,
                "origin": "화살표 함수 (arrow function)",
                "title": "화살표 함수 (arrow function)",
                "fragment": "root-2-1",
                "children": []
              },
              {
                "rank": 3,
                "origin": "클래스 (class)",
                "title": "클래스 (class)",
                "fragment": "root-2-2",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "타입스크립트 시작하기.\n도대체 왜 사용하는거고, 뭐가 좋은걸까?",
    "content": "\n## 우리가 아는 자바스크립트\n\n사실 나도 타입스크립트를 처음 배우는 거고, 잘 알지 못한다. 하지만, 자바스크립트와 같이 **동적타입**의 언어는 결국 많은 문제를 유발 시킬수 있는걸 알고 있다.\n일반 자바스크립트에는 타입이 없기 때문에 코드대로 그냥 변수로 받아야한다. 따라서 아래와 같은 일반 자바스크립트에서는 해괴한 연산도 가능하다.\n\n```javascript\n//일반 자바스크립트 함수의 선언\nfunction getNow() {\n    return new Date()\n}\n\nvar now = getNow();\nvar plus1Day = now + '1Day';\nconsole.log('plusDay:', plus1Day) \n//출력결과 -> plusDay: Sat Apr 15 2023 19:12:32 GMT+0900 (한국 표준시)1Day\n```\n\n3번라인에서 보면 `getNow()` 함수는 `Date` 타입의 현재시간 값을 리턴한다. 근데, 7번라인에서 다시보면 `Date` 타입과 `string` 연산을 한다.\n하지만, 어떠한 에러도 발생되지 않는다. 결과적으로 연산된 `plus1Day` 변수의 타입은 `string`이다.\n`Date` 함수와 `string`의 덧셈에 결과타입이 `string`인 내용은, 타입스크립트를 알아보는 과정에서 별로 중요하지 않기에 넘어간다.\n\n이 처럼 타입이 존재는 하지만, 변수가 타입에 연연하지않은 언어를 `동적타입 언어`라고 한다. \n우리가 일반적으로 알고있는 객체지향 언어는 모두 정적타입 언어 이다. 각 변수의 타입이 정해져있고, 정해진대로 연산을 하기 때문이다.\n게다가 `javascript`는 ECMA Script(ES)라는 표준 스크립트 버전이 있는데, 현재 우리가 사용중인 브라우저는 ES5 버전만 해석할 수 있다.\n\n`ES5`버전은 2009년에 공개된 버전이며, 현재까지 브라우저는 해당 버전이상의 자바스크립트는 해석할 수 없다.\n이 이상의 버전을 사용하려면, Babel(Javascript Compiler)같은 특정도구를 이용해 브라우저가 해석할 수 있는 자바스크립트의 버전으로 컴파일 해줘야 한다.\n이 외에도 `ES5`이상에서 지원되는 javascript 버전에는 여러가지 기능 및 문법들을 사용할수 있었다.\n\n```javascript\n//ES6 문법 const\nconst sum = (a, b) => {\n    return a + b\n}\n```\n위의 설명대로 브라우저는 `const`를 알 수 없다. 하지만 브라우저 내부에있는 js 엔진이 해석할 수 있기에 우리는 `ES`버전은 딱히 몰라도 상관없다.\n타입스크립트를 배우기위해선, 위의 내용들을 알고있어야한다. `ES5`의 문법은 당연히 `ESNext(6, 7..)`에서 포함하고 있고, 이또한 `Typescript`에서 포함하고있다.\n`타입스크립트`또한, `ESNext`와 동일하게 ES5로 `Transpile`을 해줘야 하는건 예외 없다. \n\n그럼 우리가 아는 자바스크립트를 그냥 사용해도 되는데, 왜 굳이 타입스크립트를 사용하는 걸까?\n\n## 타입스크립트는 무엇인가?\n\n간단하게 설명하면, 동적타입의 언어와 같이 모든 객체는 타입을 가지며, `Null-Sefe`한 연산을 할 수 있는 등 여러 장점이 있다.\n예를 들어 다음과 같은 `Javascript` 코드에서 문제가 발생 했을 때, 쉽게 문제를 알수 없다.\n\n```javascript\nfunction makePerson(name, age) {\n    return {\n        name: name,\n        age: age\n    }\n}\n\nconst person = makePerson(30, 'Kim')\n```\n\n하지만, 위와 같은 코드에 각 변수에대한 타입이 생긴다면, 작성할 때부터 문제를 알 수 있다.\n만약 위에 코드에서 타입이 추가된다면 어떻게 달라질까?\n\n```typescript\nclass Person {\n    name: string\n    age: number\n\n    constructor(name: string, _age_: number) {\n        this.name = name\n        this.age = age\n    }\n}\n\nfunction makePerson(name: string, age: number): Person {\n    return new Person(name, age)\n}\n\nconst person: Person = makePerson('Kim', 4)\n```\n\n좀 더 많은 코드가 작성되었다. 하지만, 각 변수는 타입을 가지며, 좀 더 견고한 어플리케이션을 만들수 있는 타입이 생겼다.\n클래스 생성을 통해, 의도한 값을 가지는 타입의 객체가 생성되었다. 이는 정말 중요한 내용이다.\n기존에 자바스크립트에서 할 수 없었던, 그리고 걱정하지 않아도 되었던, 코드를 작성할 수 있게된다.\n\n## 타입스크립트를 배우기전 ES5 또는 ESNext의 주요 문법을 알아보자\n\n앞서 말한것처럼 `Typescript`는 `ESNext`, `ES5`모두 포괄하고 있는 상위 집합이기에, 두가지 문법을 모두 사용할 수 있다.\n타입스크립몇가지 간단한 문법을 \n\n### 비구조화 할당\n\n`비구조화 할당(destructuring assignment)`는 객체와 배열에 적용할 수 있으며, 말그대로 구조화 하지않은 채 값을 특정 변수로 할당 하는 것 이다.\n이는 `ESNext`에서 제공되며,  \n\n```javascript{6}\nlet person = {\n    first_name: 'John',\n    age: 30\n}\n\nlet { first_name, age } = person\n\nconsole.log(typeof age) // \"number\"\nconsole.log(age)        // 30\nconsole.log(first_name) // \"John\"\n```\n\nperson을 이용하여, 비구조화 할당을 통해 `first_name` field와 `age`필드를 할당 할 수 있다.\n그럼 이 할당을 통해, `let { first_name, age }`의 값 중 `first_name`의 값을 바꾸면 어떻게 될까?\n\n```javascript\nlet person = {\n    first_name: 'John',\n    age: 30\n}\n\nlet { first_name, age } = person\n\nfirst_name = 'Micheal'\nconsole.log('person:', person)\n/*\n    person: {\n        \"first_name\": \"John\",\n        \"age\": 30\n    }\n */\nperson.first_name = 'Smith'\nconsole.log('first_name:', first_name)\n/*\n    first_name: Micheal\n */\n```\n\n첫번째로 할당된 `first_name`의 값을 변경했지만, 변경 되지 않았다.\n또한, 반대로 `person.first_name`의 값을 변경 했지만, 역시나 `first_name`의 값이 변경 되지 않았다.\n여기서 `비구조화 할당`은 얕은복사를 하는걸 알 수 있다.\n배열의 비구조화 할 당은 어떻게 사용할 수 있을까?\n\n```javascript{2}\nlet array = [1, 7, 54, 66, 90]\nlet [first, ...mod] = array\n\nconsole.log(array) // [1, 7, 54, 66, 90]\nconsole.log(first) // 1\nconsole.log(mod)   // [7, 54, 66, 90]\n```\n\n>2번 라인의 `...mod`는 `스프레드 연산자`이며, 내부 요소를 한번에 가져온다.\n> 스프레드 연산자는 인자의 마지막에만 사용할 수 있다.\n:{ \"type\": \"note\", \"icon\": \"info\" }\n\n`first`와 `mod`로 나누어 할당 했고 출력 결과는 위 처럼 배열의 순서에 맞는 값들로 나뉘어졌다.\n`객체`또는 `배열`의 구조를 분해해서 할당하기 때문에 `구조분해 할당`(`또는 \"비구조화 할당\"`)이라고 칭한다.\n\n\n### 화살표 함수 (arrow function)\n\n```javascript\n// 일반 함수형\nfunction toUpperCase(str) {\n    return str.toUpperCase()\n}\n\n// 화살표 함수형\nconst toUpperCase = () => str.toUpperCase()\n```\n\n자바스크립트에서는 함수또한 객체로 취급되며, 위와 같은 표현식으로 선언할 수 있다.\n이 화살표 함수(`arrow function`)은 내부로직이 한줄로 표현이 된다면, `{}`괄호와 `return`을 생략할 수있다.\n중요한 부분은 `=`다음으로 오는 `() => {}`구문이다. `()`에는 일반함수처럼 매개변수를 받을 수 있고, `{}` 내부 또한 함수와 동일하게 작성할 수 있다.\n*주의할 점*은 `화살표 함수` 내에서 `this` 키워드는 함수 `자신`을 의미한다는 점을 알고 있어야 한다. \n이는 `javascript`객체와 관련된 부분인데, `javascript`에서 `this`는 객체의 참조를 의미한다. \n`class` 또는 모듈에서 사용한다면, 현재 속해있는 객체(`브라우저`일반적으로 `window: DOM tree`로 바인딩) 에대해 바인딩 하기때문에, \n객체 자체인 `arrow`함수는 `this`에 대해 자기 자신이 바인드 되는 것이다.\n\n### 클래스 (class)\n\n일반적으로 객체지향 언어에서 지원 하는 `class`의 개념은 어떤 객체에 대해 정적인 관점에서 서술 할 때 사용 된다.\n아래의 예제를 통해 `알람시계`가 갖고있는 정적인 관점의 상태와 책임에 대해 좀더 객체지향적으로 이해하기 위해 `typescript`를 통해 알아보자.\n\n```typescript\n\nclass Speaker {\n    ringing() {\n        //저장된 음악으로, 스피커 동작 로직    \n    }\n}\n\ninterface Alarm {\n    alert(message: string): never\n}\n\nclass Clock implements Alarm {\n\n    private readonly _speaker: Speaker\n\n    constructor(speaker: Speaker) {\n        this._speaker = speaker\n    }\n    \n    setTimeOfRinging(milis: number, message: string): never {\n        setTimeout(() => {\n            this._speaker.ringing()\n            alert()\n        }, milis)\n    }\n    \n    alert(message: string): never {\n        console.log(message)\n    }\n}\n\nconst clock: Clock = new Clock(new Speaker())\nclock.setTimeOfRinging(1000, '1초가 지났습니다.')\n```\n\n기존에 `javascript`에서는 할 수 없던, 객체의 상속, 추상화가 가능 하므로서, 간단한 알람시계 클래스지만,각 객체들의 `책임`을 부여하므로써,\n좀 더 견고한 `어플리케이션`을 만들 수 있다.\n"
  },
  {
    "path": "/docs/tool/asdf",
    "header": {
      "layout": "post",
      "title": "다중모듈 관리툴 asdf",
      "categories": [
        "tool"
      ],
      "tags": [
        "Module",
        "Multi Module"
      ],
      "date": 1676380440000,
      "thumbnail": "/post/tool/asdf.png",
      "current-company": "Herit Corporation",
      "current-position": "Backend Server Developer",
      "summary": "asdf",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "도구"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "설치",
            "title": "설치",
            "fragment": "root-0",
            "children": []
          },
          {
            "rank": 2,
            "origin": "명령어",
            "title": "명령어",
            "fragment": "root-1",
            "children": [
              {
                "rank": 3,
                "origin": "플러그인",
                "title": "플러그인",
                "fragment": "root-1-0",
                "children": []
              },
              {
                "rank": 3,
                "origin": "모듈",
                "title": "모듈",
                "fragment": "root-1-1",
                "children": []
              }
            ]
          },
          {
            "rank": 2,
            "origin": "설치 순서",
            "title": "설치 순서",
            "fragment": "root-2",
            "children": []
          }
        ]
      }
    },
    "description": "다양한 모듈의 버전을 한번에 관리할 수 있는 asdf",
    "content": "\nasdf 는 다중 모듈 버전 관리 도구이다.\n`nvm`이 node에 대한 버전을 관리할 수 있듯이, `asdf`는 java, node, go 등 다양한 모듈의 버전을 관리할 수 있다.\n먼저 모듈 버전 관리를 하려면 사용할 모듈의 플러그인을 설치해야 한다. 설치할 수 있는 플러그인이 뭐가 있는지 확인하고, 플러그인을 설치해서 버전 관리를 하면 되는 구조다.\n\n## 설치\n\n1. `git clone https://github.com/asdf-vm/asdf.git ~/.asdf --branch v0.15.0`\n2. [OS 별 참조](https://asdf-vm.com/guide/getting-started.html#_3-install-asdf)\n\n\n## 명령어\n\n### 플러그인\n\n```shell\n$ asdf plugin list all # 전체 플러그인 조회\n$ asdf plugin list all | grep <plugin-name> # 검색 (윈도우는 findStr)\n$ asdf plugin add <plugin-name> # 플러그인 설치 \n```\n\n### 모듈\n\n```shell\n$ asdf list-all <plugin-name> #플러그인 모듈 조회\n$ asdf list-all <plugin-name> | grep <module-name> # 검색 (윈도우는 findStr)\n$ asdf latest <plugin-name> <version> #최신 버전 확인\n$ asdf install <module-name> <version> #모듈 설치\n$ asdf local <module-name> <version> #현재 디렉토리에서 참조할 모듈 버전 지정(선행 설치 필요)\n$ asdf global <module-name <version> #전체 디렉토리에서 참조할 모듈 버전 지정 (선행 설치 필요)\n```\n\n[다른 명령어](https://asdf-vm.com/manage/commands.html);\n\n\n## 설치 순서\n\n1. 플러그인\n2. 모듈-버전\n"
  },
  {
    "path": "/docs/algorithm/heap-sort",
    "header": {
      "layout": "post",
      "title": "우선순위 컬렉션 HEAP",
      "categories": [
        "algorithm"
      ],
      "tags": [
        "Java",
        "Algorithm",
        "Sort",
        "Heap Sort",
        "Heap"
      ],
      "date": 1651837980000,
      "profile-image": "/post/profile/profile4.jpg",
      "thumbnail": "/post/algorithm/heap/heap-sort-intro.svg",
      "current-company": "Herit Corporation",
      "current-position": "Backend Server Developer",
      "summary": "HEAP 자료구조",
      "expose-images": true,
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "알고리즘"
      ],
      "images": [
        {
          "src": "/post/algorithm/heap/tree_images.svg",
          "alt": "위 트리중 어떤것이 힙일까?"
        },
        {
          "src": "/post/algorithm/heap/first_iteration.svg",
          "alt": "힙을 만드려면 완전 이진트리가 있어야 한다."
        },
        {
          "src": "/post/algorithm/heap/other_iteration.svg",
          "alt": "만약 마지막 내부노드부터 순회할 때, 쵀대힙을 만드려면 위와 같이 만들수 있어요."
        },
        {
          "src": "/post/algorithm/heap/last_iteration.svg",
          "alt": "최대힙을 만들어 이런 형태로 노드를 나눌수 있어요."
        },
        {
          "src": "/post/algorithm/heap/add_new_17.svg",
          "alt": "만약 다음의 힙에서 17이라는 값이 추가 된다면"
        },
        {
          "src": "/post/algorithm/heap/add_new_17_2.svg",
          "alt": "이런식으로 부모노드와 바꿔가며, 다시 힙을 유지할 수 있어요."
        },
        {
          "src": "/post/algorithm/heap/heap_sort_1_1.svg",
          "alt": "가장 우선순위가 높은 값을 뒤로 이동시키고 다시 루트노드부터 힙을 만든다. 이 때 노드의 범위에서 정렬된 개수 만큼만 제외한다."
        },
        {
          "src": "/post/algorithm/heap/heap_sort_1_2.svg",
          "alt": "두번째도 동일하게 루트를 뒤로 보내고 다시 힙을 만든다."
        },
        {
          "src": "/post/algorithm/heap/heap_sort_1_3.svg",
          "alt": "이 과정에서 제외된 범위는 오름차순으로 점점 정렬되는 것을 볼 수 있다."
        },
        {
          "src": "/post/algorithm/heap/heap_sort_1_4.svg",
          "alt": "정렬되는 요소가 많을 수 록 힙을 만드들기 위해 탐색하는 시간 또한 줄어든다."
        },
        {
          "src": "/post/algorithm/heap/heap_sort_1_5.svg",
          "alt": "각 요소마다 정렬되는 시간이 logN이기 때문이다."
        },
        {
          "src": "/post/algorithm/heap/heap_sort_1_6.svg",
          "alt": ""
        },
        {
          "src": "/post/algorithm/heap/heap_sort_1_7.svg",
          "alt": ""
        },
        {
          "src": "/post/algorithm/heap/heap_sort_1_8.svg",
          "alt": "마지막 요소까지 정렬"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "설명::intro",
            "title": "설명",
            "fragment": "intro",
            "children": [
              {
                "rank": 3,
                "origin": "Heap의 속성 (성질)::temper",
                "title": "Heap의 속성 (성질)",
                "fragment": "temper",
                "children": []
              },
              {
                "rank": 3,
                "origin": "Heap을 만드는 방법::how-to-make-heap",
                "title": "Heap을 만드는 방법",
                "fragment": "how-to-make-heap",
                "children": []
              },
              {
                "rank": 3,
                "origin": "Heap이 우선 값을 유지하는 방법::how-to-keeping-priority-value",
                "title": "Heap이 우선 값을 유지하는 방법",
                "fragment": "how-to-keeping-priority-value",
                "children": []
              },
              {
                "rank": 3,
                "origin": "Heap을 이용해 정렬을 하는 방법::how-to-sort-by-heap",
                "title": "Heap을 이용해 정렬을 하는 방법",
                "fragment": "how-to-sort-by-heap",
                "children": []
              }
            ]
          },
          {
            "rank": 2,
            "origin": "구현 코드 (Java)::implementation-code",
            "title": "구현 코드 (Java)",
            "fragment": "implementation-code",
            "children": []
          }
        ]
      }
    },
    "description": "\"heap\"이라는 단어는 원래 영어에서 \"쌓아올린 더미\"또는 \"무질서하게 쌓아올린 것\"을 의미한다.\n\n데이터 구조로서 Heap이라는 이름이 붙게 된 것은 1964년 J.W.J. Williams가 발표한 논문에서 처음 사용되었다.\n\n윌리엄즈는 이진트리를 배열로 표현하면서 부모-자식 관계가 마치 더미(heap)처럼 쌓여 있는 모양이라고 표현하였다.",
    "content": "\n## 설명::intro\n\n간단하게 말하여, 힙은 우선순위 큐 입니다. `JAVA`에서는 `PriorityQueue`라는 구현체를 통해 Heap 자료구조를 사용할 수 있어요.\n힙은 두 종류가 있는데 `최대 힙`과 `최소 힙`이 있어요. \n최대 Heap(최소 Heap)은 단어와 같이 최대 값(최소 값)을 우선순위로 판단하여, 어떠한 값이 들어와도, 항상 같은 순서의\n트리를 유지하며, 언제든지 최고 우선순위의 값을 적은 비용으로 쉽게 얻을수 있는 자료구조 입니다.\n\n### Heap의 속성 (성질)::temper\n\n* 최대 힙(**또는 최소 힙**)은 `잎(leaf)`의 계층을 제외한 모든 노드는 자식의 노드 보다 큰(**또는 작은**) 값을 가지고 있어야합니다.\n* 왼쪽부터 차례대로 채워져있는 `완전 이진 트리(Complete binary tree)`이어야 합니다.\n* 같은 계층의 노드들과는 정렬하지 않습니다.\n* 루트(뿌리)노드로 부터 내려오는 위치의 노드들 오름차순(**또는 내림차순**)입니다\n\n![위 트리중 어떤것이 힙일까?](/post/algorithm/heap/tree_images.svg)\n\n* 트리 A: 잎을 제외한 노드는 모두 정렬되었지만, 왼쪽부터 채워지지않아 Heap이 아닙니다.\n* 트리 B: 왼쪽부터 채워졌지만, 2번노드의 값은 그 자식에값보다 작습니다. 따라서 Heap이 아닙니다.\n* 트리 C: 잎을 제외한 모든 노드가 자식 또는 부모와 정렬 되어있고, 왼쪽부터 채워져있으므로 `Heap`입니다.\n\n> 이를 정리하면 아래와 같습니다.   \n> 1.`𝑛개`의 노드를 가진 힙은 정확히 하나만 있고 그 힙(트리)의 높이(height)는 `⎣log₂𝑛⎦`이다. 트리의 전체 노드의 개수가 `8`일경우 트리(힙)의 높이는 `3`이다. 즉 힢의 높이는 힙의 성질(속성)에 부합되는 노드들만 인정이 된다는 의미이다.  \n> 2.힙의 루트 노드는 항상 최댓값(**또는 최솟값**)을 저장한다. 최대 힙(**또는 최소 힙**)은 쵀댓값(**또는 최솟값**)을 효율적으로 관리하기 위한 자료구조이며, 루트에는 항상 가장 큰(**또는 작은**)값을 유지한다.  \n> 3.힙의 한 노드와 그 노드의 자손 노드들로 이루어진 부분 트리(subtree)도 힙이다. 힙은 힙으로 이루어져있으며 자식노드도 힙이 될수있지만, 노드의 자식이없다면 힙이될 수없다. 따라서 위 C 트리의 `4, 5, 6`번 노드는 힙이 아니다.  \n:{ \"type\": \"note\", \"icon\": \"info\" }\n\n### Heap을 만드는 방법::how-to-make-heap\n\n힙을 구성 하기 위해서는 다음의 순서대로 진행됩니다.\n\n1. 순회를 시작할 힙이되는 마지막 노드`⎣𝑛/₂⎦`를 찾는다.\n2. 마지막 노드 i를 이용해 자식노드가 있는지, 또한 있다면 그 중 자신 보다 큰값을 자신과 찾는다.\n3. 찾은 값과 자신을 바꾸고 바꾼 자신의 위치는 그값의 자식이 되며, 자신보다 큰값이 나오지 않을때까지 반복한다.\n4. 다음 노드(i -1)에서 다시 `3.`을 반복한다.\n\n> 자식 노드의 위치를 찾을때는 왼쪽`arr[2i]`값과 오른쪽`arr[2i + 1]`로 구할 수 있습니다.\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\" }\n\n위 의 내용을 정리하면 아래와 같습니다.\n\n\n![힙을 만드려면 완전 이진트리가 있어야 한다.](/post/algorithm/heap/first_iteration.svg)\n\n> 위의 트리는 *완전 이진트리* 입니다. 힙은 완전이진트리에서 만들수 있으므로, 일반 이진트리는 Compact하게 완전이진트리로 바꿔야 힙을 만들수 있습니다.\n> 왼쪽 트리의 마지막 힙의 값은 `15` 이며, 이는 자식(`6, 4`) 어느것 보다도 큰값입니다. 따라서 다음 순회로 넘어갑니다.\n> 순회는 내부 노드의 마지막 힙의 위치에서 부터 1까지 이어집니다. 따라서 다음 인덱스인 3번 노드(9)로 넘어갑니다.\n> 3번노드는 자신의 자식들 중 6번째, 7번째 (7, 12)와 비교하여 더 큰값을 가지는 12와 바꿉니다.\n:{ \"type\": \"note\", \"icon\": \"info\" }\n\n![만약 마지막 내부노드부터 순회할 때, 쵀대힙을 만드려면 위와 같이 만들수 있어요.](/post/algorithm/heap/other_iteration.svg)\n\n> 이후 과정은 위와 같이 반복됩니다. 내부노드를 순회하며 자신의 자식노드가 있는지 확인하고 있다면, 자신과 비교하여 더큰 값으로 바꿉니다. 이는 바꾼이후에도 `3.`이 반복되게 됩니다. 순회되는 노드가 최상위노드가 되고 모든 내부노드가 힙이 될때, 전체 트리는 힙이 됩니다.   \n> 마지막까지 바꾼 최종트리는 아래와 같습니다.\n:{ \"type\": \"note\", \"icon\": \"info\" }\n\n![최대힙을 만들어 이런 형태로 노드를 나눌수 있어요.](/post/algorithm/heap/last_iteration.svg)\n\n* 최상위 노드(루트)가 가장 큰값이 되며, 위는 최대힙을 만드는 단계였습니다.\n* 부모노드와 자식노드끼리는 순서의 값을 가지며, 항상 최대의 값을 가집니다.  \n\n### Heap이 우선 값을 유지하는 방법::how-to-keeping-priority-value\n\n위에서는 완전이진트리로 힙을 어떻게 만드는지에 대해 알아봤습니다.\n하지만, 힙은 언제나 새로운값이 들어와도 항상 우선 순위로 값을 관리합니다. 만약 저기서 더큰값이 추가된다면,\n저 힙트리는 어떻게 바뀔까요? 새로운 값들을 추가해서 힙이 다시 어떻게 유지되는지 배워봅니다.\n\n#### 값 추가::add-new-value\n\n힙트리에서 값을 추가 할때는 마지막 노드로 붙여주고 위에서 했던것과 동일하게 힙을 만들어 줍니다.\n만약 새로운 값 17이 힙에 들어온다면 순서는 아래와 같이 바뀝니다.\n\n::image-group\n\n![만약 다음의 힙에서 17이라는 값이 추가 된다면](/post/algorithm/heap/add_new_17.svg)\n\n![이런식으로 부모노드와 바꿔가며, 다시 힙을 유지할 수 있어요.](/post/algorithm/heap/add_new_17_2.svg)\n\n::\n\n\n> A: 새로 들어온 값 17은 트리의 맨뒤인 10번노드로 들어갑니다.     \n> 또한 마지막 내부노드이자 자신의 부모인 5번 노드(4)부터 다시 순회를 시작하며,  \n> 자신보다 큰 값은 가진 자식 10번 노드(17)과 값을 바꿉니다. \n> B: 값이 바뀐 10번 노드(4)는 자식을 가지고있지 않으므로 다음 순회로 넘어갑니다.  \n> C: 다음 순회인 4번 노드(6)은 자식들보다 큰값이므로 다음 3번 노드(12)로 이동합니다. 하지만 이또한 자식들보다 값이 크므로, 2번 노드(8)로 이동합니다. 자신보다 큰값을 가지는 5번 자식노드(17)과 바꿉니다.  \n> D: 값이 바뀐 5번 노드(8)은 자식들 보다 값이 커, 바꿀 필요가 없으므로 다음 순회인 1번 노드(15)로 이동합니다.  \n> E: 현재 순회인 1번 노드(15)는 자신의 2번 노드(17)보다 값이 작으므로 바꿉니다.  \n> F: 최종적으로 힙이 완성되었습니다.\n:{ \"type\": \"tip\", \"icon\": \"check-circle\" }\n\n\n### Heap을 이용해 정렬을 하는 방법::how-to-sort-by-heap\n\n힙 정렬을 위해서는 사전에 완전 이진 트리를 힙으로 만들고, 정렬을 수행할 수 있습니다.\n위에서 만든 힙을 통해 정렬을 하는 방법을 구현합니다.  \n힙 정렬은 간단하게, 아래의 정렬하는 순서를 가지고있습니다.\n\n1. 최상위 노드 `A`와 가장 끝의 노드 `B`를 바꾼다.\n2. 바꿔진 A는 맨뒤로 가며,힙에서 제외한다. \n3. 바꾼 값 `B`는, 자신의 자식이 있다면, 두개를 비교하여 가장 큰 값과 맞 바꾼다.\n4. `3.`의 내용을 힙이될때까지 반복한다.\n\n정렬을 할 때는 Heap의 우선값을 이용해 진행하기 때문에 `최대 힙` 으로는 오름차순 정렬, `최소 힙`으로는 내림차순 정렬을 할 수 있다.\n\n::image-group\n\n![가장 우선순위가 높은 값을 뒤로 이동시키고 다시 루트노드부터 힙을 만든다. 이 때 노드의 범위에서 정렬된 개수 만큼만 제외한다.](/post/algorithm/heap/heap_sort_1_1.svg)\n\n![두번째도 동일하게 루트를 뒤로 보내고 다시 힙을 만든다.](/post/algorithm/heap/heap_sort_1_2.svg)\n\n![이 과정에서 제외된 범위는 오름차순으로 점점 정렬되는 것을 볼 수 있다.](/post/algorithm/heap/heap_sort_1_3.svg)\n\n![정렬되는 요소가 많을 수 록 힙을 만드들기 위해 탐색하는 시간 또한 줄어든다.](/post/algorithm/heap/heap_sort_1_4.svg)\n\n![각 요소마다 정렬되는 시간이 logN이기 때문이다.](/post/algorithm/heap/heap_sort_1_5.svg)\n\n![](/post/algorithm/heap/heap_sort_1_6.svg)\n\n![](/post/algorithm/heap/heap_sort_1_7.svg)\n\n![마지막 요소까지 정렬](/post/algorithm/heap/heap_sort_1_8.svg)\n\n::\n:{ \"description\": \"최대 힙을 이용한 오름차순 정렬\" }\n\n\n## 구현 코드 (Java)::implementation-code\n\n::code-group\n\n```java::힙 만들기\n//== 힙(Heap) 을 만드는 메소드 ==//\npublic static void makeHeap(int arr[]) {\n    // last heap\n    int lh = arr.length / 2;\n    System.out.println(\"Normal Array = \" + Arrays.toString(arr));\n    int eh = arr.length;\n    while (lh-- > 0) {\n\n        System.out.println(\"i: \" + lh);\n        pushDown(arr, lh, eh);\n    }\n\n    System.out.println(\"Array as Max Heap = \" + Arrays.toString(arr));\n}\n```\n\n```java::노드 비교\n//== 노드와 그 자식중에서 더큰(또는 작은) 위치를 찾는 메소드 ==//\npublic static int findLargest(int arr[], int node, int eh) {\n    // first child\n    int fc = (2 * (node + 1)) - 1;\n\n    if (fc + 1 < eh) {\n        if (arr[fc] <= arr[fc + 1]) {\n            return arr[fc + 1] <= arr[node] ? node : fc + 1;\n        } else {\n            return arr[fc] <= arr[node] ? node : fc;\n        }\n    }\n    if (fc < eh && arr[node] < arr[fc]) {\n        return fc;\n    } else {\n        return node;\n    }\n}\n```\n\n```java::값 교환\n//== 값을 아래로 내리는 메소드 ==//\n/**\n * 간단하게 보면 트리에서 마지막 힙의 위치를 구하고,\n * 루트 노드까지 역순으로 힙을 만들어갑니다.\n * \n * 최대 힙(또는 최소 힙)의 조건에 따라 더큰(또는 더 작은)값을 기준으로,\n * 해당 노드를 위로올리고 변경된 대상은 아래로 내려가며 계속 바꿉니다.\n */\npublic static void pushDown(int arr[], int node, int eh) {\n    do {\n        System.out.println(\"j: \" + node);\n        int temp = arr[node];\n        int large = findLargest(arr, node, eh);\n        System.out.println(drawBinaryTree(arr));\n\n        if (large == node)\n            break;\n\n        arr[node] = arr[large];\n        arr[large] = temp;\n\n        node = large;\n    } while (node <= eh);\n}\n```\n\n```java::정렬\npublic static void sort(int arr[]) {\n    int last = arr.length;\n    makeHeap(arr);\n\n    while (--last >= 0) {\n\n        int temp = arr[0];\n        arr[0] = arr[last];\n        arr[last] = temp;\n\n        System.out.println(\"last: \" + last);\n        pushDown(arr, 0, last);\n    }\n    ;\n}\n```\n\n```java::출력 메소드\npublic static String drawBinaryTree(int arr[]) {\n    StringBuilder builder = new StringBuilder();\n\n    int nol = (int) (Math.log(arr.length) / Math.log(2)) + 1;\n    int max = (int) Math.pow(2, nol - 1);\n\n    int printed = 0;\n    for (int i = 0; i < nol; i++) {\n        int perFloor = (int) Math.pow(2, i);\n        int tab = (max - perFloor) / 2 + (max - perFloor) % 2;\n        int last = printed + perFloor;\n\n        for (int j = 0; j < tab; j++) {\n            builder.append(\"  \");\n        }\n        for (int j = printed; (j < arr.length && j < last); j++) {\n            builder.append(String.format(\"(%d)\", arr[j]));\n        }\n        builder.append(\"\\n\");\n        printed += perFloor;\n    }\n\n    return builder.toString();\n}\n```\n\n::\n\n```java::메인 함수\npublic static void main(String args []) throws Exception {\n    //== 힙 으로 만들기==//\n    int arrForMake [] = {1, 5, 8, 2, 74, 9, 12, 104, 87, 43};\n    Heap.makeHeap();\n    \n    //== 힙 + 정렬 ==//\n    int arrForSort [] = {1, 8, 9, 15, 4, 7, 12, 6, 4, 17};\n    Heap.sort(arr);\n    \n}\n```\n\n\n\n\n"
  },
  {
    "path": "/docs/computer/os/operating-system",
    "header": {
      "layout": "post",
      "title": "Operating System (OS)",
      "categories": [
        "os"
      ],
      "tags": [
        "Operating System",
        "OS"
      ],
      "date": 1611141570000,
      "thumbnail": "/post/computer/operating-system.webp",
      "current-company": "Cubic INC",
      "current-position": "SI Researcher",
      "profile-image": "/post/profile/profile1.jpg",
      "summary": "컴퓨터와 운영체제",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "컴퓨터",
        "운영체제"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "컴퓨터의 구성::computer-structure",
            "title": "컴퓨터의 구성",
            "fragment": "computer-structure",
            "children": []
          },
          {
            "rank": 2,
            "origin": "운영체제의 동작 순서::sequence-of-os",
            "title": "운영체제의 동작 순서",
            "fragment": "sequence-of-os",
            "children": []
          },
          {
            "rank": 2,
            "origin": "운영체제의 역할::role-of-os",
            "title": "운영체제의 역할",
            "fragment": "role-of-os",
            "children": [
              {
                "rank": 3,
                "origin": "메모리 관리::memory-management",
                "title": "메모리 관리",
                "fragment": "memory-management",
                "children": []
              },
              {
                "rank": 3,
                "origin": "프로세스 관리::process-management",
                "title": "프로세스 관리",
                "fragment": "process-management",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "운영체제가 어떤일을 하는지를 알려면, 컴퓨터가 어떤 요소들로 구성되어 있는지를 이해 해야한다.\n각 요소의 구성과 이해관계 그리고 역할을 알아보자.",
    "content": "\n## 컴퓨터의 구성::computer-structure\n\n컴퓨터는 크게 응용프로그램, 운영체제, 하드웨어 계층으로 분류된다.\n이 문서에서는 응용프로그램을 제외하고 운영체제와 하드웨어에 대해 논한다.\n\n[CPU](/wiki/central-processing-unit)와 [입출력 장치]() 그리고 [메모리]()는 [시스템 버스]()를 통해 서로 연결되어 있으며, 버스의 종류에 따라 단방향 또는 양방향으로 신호를 보낸다.\n입출력 장치의 경우 메인보드 위에 사전에 만들어진 장치 컨트롤러를 운영체제의 장치 드라이버가 제어하며, 장치드라이버는 운영체제에 일관된 인터페이스를 제공한다.\nCPU와 장치컨트롤러는 병렬로 실행되기 떄문에 메모리에 접근하기위해 메모리 사이클을 두고 경쟁한다. 이 메모리에 순차적으로 접근하기 위해 메모리 컨트롤러는 메모리에 대한 액세스를 동기화한다.\n\n\n위에서 간단히 설명한 내용은 OS 내부의 커널과 시스템 프로그램에 의해 제어되며, 하드웨어의 경우 사전에 설계된 회로의 동작을 수행한다.\n\n## 운영체제의 동작 순서::sequence-of-os\n\n컴퓨터의 전원을 켤 때 실행되는 부트스트랩 프로그램은 펌웨어이다.  \n부트스트랩 프로그램은 하드웨어 위에서 동작하며 `CPU`, `메모리` `저장장치` 등을 초기화 한다. 또한 운영체제를 로드하기 위해 부트로더를 실행하며, 이는 저장장치에서 메모리로 [Kernel]()(`커널`)을 적재한다.\n\n부트로더는 커널 실행에 필요한 초기설정(예: 커맨드라인 인자 전달 등)을 한뒤, 커널에 제어를 넘긴다. 이후에 커널은 시스템을 초기화하고 사용자 공간(user space)을 준비한다.\n각 시스템에서 사용 되는 부트로더는 여러종류가 있다.\n\n* GRUB (GNU GRUB):\n  * 리눅스/유닉스 시스템에서 사용되는 부트로더\n* LILO(Linux Loader)\n  * 과거 리눅스 시스템에서 사용되는 부트로더\n* Windows Boot Manager\n  * 윈도우 시스템에서 사용하는 부트로더\n* Android Bootloader\n  * 안드로이드 기기에서 사용되는 부트로더로, 리커버리모드와 운영체제를 실행한다.\n\n## 운영체제의 역할::role-of-os\n\n운영체제는 사용자 또는 시스템 프로그램이 올바르게 실행되기 위해 커널에서 다양한 관리를 아래와 같이 제공한다.\n\n* 메모리 관리\n* 프로세스 관리\n* 장치 드라이버\n* 파일 시스템\n* 네트워크 관리\n\n### 메모리 관리::memory-management\n\n### 프로세스 관리::process-management\n\n운영체제는 자원을 관리하지만, 아마 그중에서도 가장 중요한건 [프로세스]()에 대한 관리이다. 대표적으로 아래와 같다.\n\n* 사용자 프로세스와 시스템프로세스의 생성과 제거\n* `CPU`에 프로세스와 스레드 스케줄링\n* 프로세스의 일시중지(suspend) 와 재수행(resume)\n* 프로세스 동기화 기법 제공\n* 프로세스 간 통신(IPC) 제공\n\n위와 같은 처리를 위해 운영체제는 프로세스의 상태를 관리하며, 프로세스의 상태(process stats)는 `생성`, `준비`, `실행`, `대기`, `종료`로 나뉜다.\n이러한 상태는 아래처럼 나타낼 수 있다.\n```\n New\n  ↓\nReady ←→ Running → Terminated\n  ↑        ┆\nWaiting ←--╯\n```\n"
  },
  {
    "path": "/docs/computer/computer-organization",
    "header": {
      "layout": "post",
      "title": "컴퓨터는 어떤 구조로 설계되었을까?",
      "categories": [
        "computer"
      ],
      "tags": [
        "Computer"
      ],
      "date": 1608610620000,
      "current-company": "Cubic INC",
      "current-position": "SI Researcher",
      "summary": "컴퓨터의 구성요소",
      "excerpt-separator": "<!--more-->",
      "hide": true,
      "breadcrumbs": [
        "문서",
        "컴퓨터"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": []
      }
    },
    "description": "",
    "content": ""
  },
  {
    "path": "/docs/language/java/install-zulu-in-mac",
    "header": {
      "layout": "post",
      "title": "Azul System의 OpenJDK Zulu 설치하기",
      "categories": [
        "language"
      ],
      "tags": [
        "OpenJDK",
        "Azul System",
        "Zulu"
      ],
      "date": 1606890300000,
      "thumbnail": "/post/java/azul-java.webp",
      "profile-image": "/post/profile/profile1.jpg",
      "current-company": "Cubic INC",
      "current-position": "SI Researcher",
      "summary": "OpenJDK Zulu 설치",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "언어",
        "자바"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "macOS에서 Open JDK 설치",
            "title": "macOS에서 Open JDK 설치",
            "fragment": "root-0",
            "children": [
              {
                "rank": 3,
                "origin": "DMG Installer를 이용한 설치",
                "title": "DMG Installer를 이용한 설치",
                "fragment": "root-0-0",
                "children": []
              },
              {
                "rank": 3,
                "origin": "ZIP 또는 TAR.GZ로 설치",
                "title": "ZIP 또는 TAR.GZ로 설치",
                "fragment": "root-0-1",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "Zulu는 Azul System에서 제공하는 OpenJDK의 빌드이다.\nmacOS에서 설치하는 방법을 요약했다.",
    "content": "\n## macOS에서 Open JDK 설치\n\nMacOS는 일반적으로 `/Library/Java/JavaVirtualMachines` 하위 경로에 jdk를 저장하고 사용한다.\n\n\n### DMG Installer를 이용한 설치\n\n1. [Azul 다운로드](https://www.azul.com/downloads/?os=macos&_gl=1*dkdl9*_ga*MTQ0NjY0MDg1OS4xNjg4NjM4NTAz*_ga_42DEGWGYD5*MTcwNjc5MTg0NC40LjEuMTcwNjc5MjMwNy4yOC4wLjA.#zulu)에서 Azul Zulu를 위한 DMG Installer 다운로드\n2. 설치를 시작하기위해 파일 더블클릭하고, 설치 마법사 명령을 따르기\n\n기본 설치폴더는 다음과같다.\n\n```\n/Library/Java/JavaVirtualMachines/<zulu_folder>/Contents/Home\n```\n\n`<zulu_folder>` 플레이스 홀더는 그 버전과 Azul Zulu 패키지(JDK or JRE)의 타입을 말한다. \n\n| 패키지 |      Azul Zulu 폴더명      |     예시      |\n| :----: | :------------------------: | :-----------: |\n|  JDK   | `zulu-<major_version>.jdk` | `zulu-11.jdk` |\n|  JRE   | `zulu-<major_version>.jdk` | `zulu-11.jre` |\n:{ \"wrapper-class\": \"items-center\" }\n\n예를 들어, Azul Zulu JDK11을 위한 기본설치 폴더인경우:\n\n```\n/Library/Java/JavaVirtualMachines/zulu-11.jdk/Contents/Home\n```\n\n3. Azul zulu 설치를 확인하기위해 터미널 창에서 `java` 명령어를 실행한다.\n\n```bash\n$ java -version\n```\n\n다음과 같이 출력돼야 한다.  \n\n```\nopenjdk version \"11.0.11\" 2021-04-20 LTS\nOpenJDK Runtime Environment Zulu11.48+21-CA (build 11.0.11+9-LTS)\nOpenJDK 64-Bit Server VM Zulu11.48+21-CA (build 11.0.11+9-LTS, mixed mode)\n```\n\n### ZIP 또는 TAR.GZ로 설치\n\n1. [Azul 다운로드](https://www.azul.com/downloads/?os=macos)에서 TAR.GZ 또는 ZIP으로 Azul Zulu 다운로드\n\n2. **Finder** 실행 후 다운로드 폴더로 이동. 압축을 해제하기위해 더블클릭 한다. **사파리**에서 받았다면 자동으로 압축해제 된다.\n\n하지만, 압축해제하기 위해 아래처럼 한번의 명령어를 사용할 수도 있다.\n\nZIP 인 경우\n\n```bash\nunzip <zulu_package>.zip\n```\n\n   TAR.GZ 인 경우\n\n```\ntar -zxvf <zulu_package>.tar.gz\n```\n\n압축 해제한 폴더가 Zulu Azul 설치 폴더 이다.\n\n3. Azul Zulu 설치를 확인하기 위해, 터미널 창에서 다음의 커맨드를 실행한다.\n\n```bash\n$ <installation_folder>/bin/java -version\n```\n\n4. (선택사항) `<installation_folder>/bin/java` 을 `PATH` 환경변수에 추가하면, 특정한 전체 경로 없이 어디서는 `java` 를 실행할 수 있다.\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "path": "/docs/software-design/bridge-pattern",
    "header": {
      "layout": "post",
      "title": "브릿지 패턴 (Bridge Pattern)",
      "categories": [
        "software-design"
      ],
      "tags": [
        "Bridge Pattern",
        "Design Pattern",
        "Software Design",
        "OCP",
        "SRP"
      ],
      "date": 1592191020000,
      "thumbnail": "/post/software-design/bridge-pattern-intro.svg",
      "profile-image": "/post/profile/profile0.jpg",
      "current-company": "Cubic INC",
      "current-position": "SI Researcher",
      "summary": "Bridge Pattern",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "소프트웨어 설계"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "핵심 구성요소::key-components",
            "title": "핵심 구성요소",
            "fragment": "key-components",
            "children": []
          },
          {
            "rank": 2,
            "origin": "예제::example",
            "title": "예제",
            "fragment": "example",
            "children": [
              {
                "rank": 3,
                "origin": "멀티 미디어 플레이어::-player-example",
                "title": "멀티 미디어 플레이어",
                "fragment": "-player-example",
                "children": []
              },
              {
                "rank": 3,
                "origin": "메세지 발송 시스템::message-sender-example",
                "title": "메세지 발송 시스템",
                "fragment": "message-sender-example",
                "children": []
              }
            ]
          },
          {
            "rank": 2,
            "origin": "적용::applicability",
            "title": "적용",
            "fragment": "applicability",
            "children": []
          },
          {
            "rank": 2,
            "origin": "장단점::pros-and-cons",
            "title": "장단점",
            "fragment": "pros-and-cons",
            "children": []
          }
        ]
      }
    },
    "description": "브릿지 패턴은 구현부와 추상부를 분리하여 각각 독립적으로 변형할 수 있도록 하는 패턴이다.\n이 패턴은 각각의 독립된 클래스로 구성하여 서로 연결하여 사용할 수 있도록 한다.",
    "content": "## 핵심 구성요소::key-components\n\n- **Abstraction**: 기능의 구현을 위한 인터페이스를 정의한다.\n- **RefinedAbstraction**: Abstraction 인터페이스를 구현하여 기능을 확장한다.\n- **Implementor**: 실제 동작의 구현부를 정의한다.\n- **ConcreteImplementor**: Implementor 인터페이스를 구현하여 실제 동작을 수행한다.\n- **Client**: Bridge 패턴을 사용하는 클래스이다.\n\n먼저 Bridge 패턴을 사용하기 위해 선언한 핵심 구성요소는 아래와 같은 관계로 구성된다.\n\n```mermaid\nclassDiagram\n    class Abstraction {\n        <<abstract>>\n        -Implementor implementor\n        +changeImplementor(Implementor implementor)\n        +feature1()\n        +feature2()\n    }\n    class RefineAbstraction {\n        +feature1()\n        +feature2()\n    }\n    class Implementor {\n        <<interface>>\n        +method1()\n        +method2()\n        +method3()\n    }\n    class ConcreteImplementorA {\n        +method1()\n        +method2()\n        +method3()\n    }\n    class ConcreteImplementorB {\n        +method1()\n        +method2()\n        +method3()\n    }\n    RefineAbstraction --|> Abstraction\n    ConcreteImplementorA ..|> Implementor\n    ConcreteImplementorB ..|> Implementor\n    Abstraction --> Implementor\n```\n\n각각의 구현부(Implementor)와 추상부(Abstraction)라는 Bridge 통해 연결되어 사용자에게 제공 된다.  \n**또한 구현부는 런타임에 언제든지 변경할 수 있기 때문에 추상부만 참조하는 유연한 구조를 가지고 있다.**\n위의 다이어그램을 보면 추상부를 추가하고 싶다면 정제된 추상부(RefineAbstraction)를 추가하여 구현하면 되며, 구현부를 추가하고 싶다면, 실제 구현부(ConcreteImplementor)를 추가하여 구현하면 된다.\n\n## 예제::example\n\n`Bridge Pattern`을 알아보기 위해 다음과 같은 예제를 살펴보자.\n\n### 멀티 미디어 플레이어::-player-example\n\n다양한 장치의 미디어 플레이어를 구현하려 한다.\n또한 각각의 장치에서는 미디어 플레이어의 기능을 확장하여 동영상 플레이어와 음악 플레이어를 구현하려 한다.\n\n이들 간에 공통적인 기능을 추상화하여 구현하고, 각각의 플레이어들은 이를 구현하여 사용한다.\n\n\n**Implementor**\n\n공통적인 기능을 추상화하여 구현한다.\n\n::code-group\n\n```java::PlayerImplementor.java\npublic interface PlayerImplementor {\n\n    //파일명을 받아 플레이 한다.\n    void playFile(String filename);\n\n    //일시정지\n    void stopPlayback();\n\n    //코덱을 로드한다.\n    void loadCodec(String codec);\n}\n```\n\n```java::WindowsPlayer.java\npublic class WindowsPlayer implements PlayerImplementor {\n\n    @Override\n    public void playFile(String filename) {\n        loadCodec(\"Windows DirectShow\");\n        System.out.println(\"Playing \" + filename + \" using Windows media player\");\n    }\n\n    @Override\n    public void stopPlayback() {\n        System.out.println(\"Stopping playback on Windows\");\n    }\n\n    @Override\n    public void loadCodec(String codec) {\n        System.out.println(\"Loading \" + codec + \" codec on Windows\");\n    }\n}\n```\n\n```java::MacPlayer.java\npublic class MacPlayer implements PlayerImplementor {\n    @Override\n    public void playFile(String filename) {\n        loadCodec(\"Apple QuickTime\");\n        System.out.println(\"Playing \"+ filename + \" using QuickTime Player\");\n    }\n\n    @Override\n    public void stopPlayback() {\n        System.out.println(\"Stopping playback on MacOS\");\n    }\n\n    @Override\n    public void loadCodec(String codec) {\n        System.out.println(\"Loading \" + codec + \" codec on MacOS\");\n    }\n}\n```\n\n::\n\n**Abstraction**\n\nImplementor 인터페이스를 참조하여 기능을 확장한다.\n\n::code-group\n\n```java::MediaPlayer.java\npublic abstract class MediaPlayer {\n\n    protected PlayerImplementor implementor;\n\n    public MediaPlayer(PlayerImplementor implementor) {\n        this.implementor = implementor;\n    }\n\n    public abstract void play(String filename);\n    public abstract void stop();\n}\n```\n\n```java::VideoPlayer.java\npublic class VideoPlayer extends MediaPlayer {\n\n    public VideoPlayer(PlayerImplementor implementor) {\n        super(implementor);\n    }\n\n    @Override\n    public void play(String filename) {\n        System.out.println(\"Video Player:\");\n        implementor.playFile(filename);\n    }\n\n    @Override\n    public void stop() {\n        System.out.println(\"Video Player:\");\n        implementor.stopPlayback();\n    }\n}\n```\n\n```java::MusicPlayer.java\npublic class MusicPlayer extends MediaPlayer {\n\n    public MusicPlayer(PlayerImplementor implementor) {\n        super(implementor);\n    }\n\n    @Override\n    public void play(String filename) {\n        System.out.println(\"Music Player:\");\n        implementor.playFile(filename);\n    }\n\n    @Override\n    public void stop() {\n        System.out.println(\"Music Player:\");\n        implementor.stopPlayback();\n    }\n}\n```\n\n::\n\n\n**Client**\n\n클라이언트에서는 실제로 각각의 독립된 컴포넌트를 이용해, 다양한 기능으로 확장하여 사용할 수 있다.\n\n::code-group\n\n```java::MacOS의 음악 플레이어 예제\nPlayerImplementor macPlayer = new MacPlayer();\nMediaPlayer macMusicPlayer = new MusicPlayer(macPlayer);\n\nmacMusicPlayer.play(\"music.mp3\");\nmacMusicPlayer.stop();\n```\n\n```java::Windows의 동영상 플레이어 예제\nPlayerImplementor windowsPlayer = new WindowsPlayer();\nMediaPlayer windowsVideoPlayer = new VideoPlayer(windowsPlayer);\n\nwindowsVideoPlayer.play(\"video.mp4\");\nwindowsVideoPlayer.stop();\n```\n\n::\n\n\n#### 추가적인 요구사항::additional-requirements\n\n위의 기능이 경우 추상부와 구현부는 명백하게 독립적으로 동작한다.\n만약 현재의 상황에서 AppPlayer 가 추가된다면 어떨까? BlueStack 앱에 대해 확장할 수있는 코드를 아래와 같이 추가할 수있다.\n\n\n::code-group\n\n```java::AndroidAppPlayer.java\npublic abstract class AndroidAppPlayer extends MediaPlayer {\n\n    public AndroidAppPlayer(PlayerImplementor implementor) {\n        super(implementor);\n    }\n    \n    protected void emulateVirtualMachine() {\n        System.out.println(\"Emulating Android Virtual Machine\");\n    }\n}\n```\n\n```java::BlueStackAppPlayer.java\npublic class BlueStackAppPlayer extends AndroidAppPlayer {\n\n    public BlueStackAppPlayer(PlayerImplementor implementor) {\n        super(implementor);\n    }\n\n    @Override\n    public void play(String filename) {\n        super.emulateVirtualMachine();\n        System.out.println(\"App Player:\");\n        implementor.playFile(filename);\n    }\n\n    @Override\n    public void stop() {\n        System.out.println(\"App Player:\");\n        implementor.stopPlayback();\n    }\n}\n```\n\n```java::Windows의 BlueStack 앱 플레이어 예제\n\nPlayerImplementor windowsPlayer = new WindowsPlayer();\nMediaPlayer windowsBlueStackPlayer = new BlueStackAppPlayer(windowsPlayer);\n\nwindowsBlueStackPlayer.play(\"app.apk\");\nwindowsBlueStackPlayer.stop();\n```\n\n::\n\n\n### 메세지 발송 시스템::message-sender-example\n\n공통 구현부로는 메세징 플랫폼이 존재한다.\n이 구현부를 확장하여 메세지 전송에 대한 추상적인 부분을 확장한다.\n\n**Implementor**\n\n구현부로서 다음의 기능을 공통화한다.\n\n1. 실제 메세지 전송\n2. 수신인 검증\n3. 메세지 설정 세팅\n\n::code-group\n\n```java::MessageSenderImplementor.java\npublic interface MessageSenderImplementor {\n\n    void sendMessage(String message, String recipient);\n    boolean validateRecipient(String recipient);\n    void configureSettings(Map<String, String> settings);\n}\n```\n\n```java::EmailPlatform.java\npublic class EmailPlatform implements MessageSenderImplementor {\n\n    @Override\n    public void sendMessage(String message, String recipient) {\n        if (validateRecipient(recipient)) {\n            System.out.println(\"Sending email to \" + recipient);\n            System.out.println(\"Email content: \" + message);\n        }\n    }\n\n    @Override\n    public boolean validateRecipient(String recipient) {\n        return recipient.matches(\"^[A-Za-z0-9+_.-]+@(.+)$\");\n    }\n\n    @Override\n    public void configureSettings(Map<String, String> settings) {\n        System.out.println(\"Configuring email settings: \" + settings);\n    }\n}\n```\n\n```java::SMSPlatform.java\npublic class SMSPlatform implements MessageSenderImplementor {\n\n    @Override\n    public void sendMessage(String message, String recipient) {\n        if (validateRecipient(recipient)) {\n            System.out.println(\"Sending SMS to \" + recipient);\n            System.out.println(\"SMS content: \" + message);\n        }\n    }\n\n    @Override\n    public boolean validateRecipient(String recipient) {\n        return recipient.matches(\"^\\\\d{10}$\");\n    }\n\n    @Override\n    public void configureSettings(Map<String, String> settings) {\n        System.out.println(\"Configuring SMS settings: \" + settings);\n    }\n}\n```\n\n::\n\n**Abstraction**\n\n추상부로서 구현부의 기능을 확장하여 긴급 메세지, 일반 메세지 등을 처리할 수 있는 메세지 전송자를 구현한다.\n\n\n::code-group\n\n```java::MessageSender.java\npublic abstract class MessageSender {\n    protected MessageSenderImplementor implementor;\n\n    protected MessageSender(MessageSenderImplementor implementor) {\n        this.implementor = implementor;\n    }\n\n    protected void changeImplementor(MessageSenderImplementor implementor) {\n        this.implementor = implementor;\n    }\n\n    public abstract void send(String message, String recipient);\n}\n```\n\n```java::UrgentMessageSender.java\npublic class UrgentMessageSender extends MessageSender {\n\n    public UrgentMessageSender(MessageSenderImplementor implementor) {\n        super(implementor);\n    }\n\n    @Override\n    public void send(String message, String recipient) {\n        message = \"[URGENT] \" + message;\n        implementor.sendMessage(message, recipient);\n    }\n}\n```\n\n```java::RegalarMessageSender.java\npublic class RegularMessageSender extends MessageSender {\n\n    public RegularMessageSender(MessageSenderImplementor implementor) {\n        super(implementor);\n    }\n\n    @Override\n    public void send(String message, String recipient) {\n        implementor.sendMessage(message, recipient);\n    }\n}\n```\n\n::\n\n**Client**\n\n클라이언트에서는 실제로 각각의 독립된 컴포넌트를 이용해, 다양한 기능으로 확장하여 사용할 수 있다.\n\n```java::메세지 발송 예제\nMap<String, String> emailSettings = new HashMap<>();\nemailSettings.put(\"smtp\", \"smtp.gmail.com\");\nemailSettings.put(\"port\", \"587\");\n\nMap<String, String> smsSettings = new HashMap<>();\nsmsSettings.put(\"api_key\", \"your_api_key\");\nsmsSettings.put(\"provider\", \"twilio\");\n\n\nMessageSenderImplementor emailPlatform = new EmailPlatform();\nMessageSenderImplementor smsPlatform = new EmailPlatform();\n\nemailPlatform.configureSettings(emailSettings);\nsmsPlatform.configureSettings(smsSettings);\n\nMessageSender urgentEmailSender = new UrgentMessageSender(emailPlatform);\nMessageSender regularSMSSender = new RegularMessageSender(smsPlatform);\n\nurgentEmailSender.send(\"Server is down!\", \"admin@company.com\");\nregularSMSSender.send(\"Hello, how are you?\", \"+1234567890\");\n```\n\n## 적용::applicability\n\n> 브릿지 패턴은 여러 변형을 가진 모놀리식 클래스를 분리하여 각각의 독립적인 클래스로 나누고 다양한 확장 기능을 구조화하여 연결하기 위해 사용한다.\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\" }\n\n어떤 기능 정의하는 클래스가 거대해질 수록 작동 방식이 복잡해지고, 유지보수 및 확장이 어려워진다.\n한곳에 있는 코드는 다른 코드에 영향을 미치기 쉽기 때문에, 이를 분리하여 독립적으로 관리할 수 있도록 하는것이 좋다.\n\n브릿지 패턴을 사용하면, 모놀리식 클래스를 여러 클래스 계층구조로 나눌수있다. 그런 다음 각 계층구조의 클래스들을 다른 계층구조들에 있는 클래스들과는 독립적으로 변경할 수 있다.\n이 접근 방식은 코드의 유지관리를 단순화하고 기존코 드가 손상될 위험을 최소화한다.\n\n\n## 장단점::pros-and-cons\n\n**장점**\n\n* 플랫폼 독립적인 클래스들과 앱들을 만들 수 있다.\n* 클라이언트 코드는 상위 수준의 추상화를 통해 작동하며, 플랫폼 세부 정보에 노출 되지 않는다.\n* [개방/폐쇄 원칙](). 새로운 추상화 들과 구현들을 상호 독립적으로 도입할 수 있다.\n* [단일 책임 원칙](). 추상화의 상위수준 논리와 구현의 플랫폼 세부 정보에 집중할 수 있다.\n\n**단점**\n\n* 결합도가 높은 클래스에 패턴을 적용하면 코드를 더 복잡하게 만들 수 있다.\n"
  },
  {
    "path": "/docs/software-design/adapter-pattern",
    "header": {
      "layout": "post",
      "title": "어댑터 패턴 (Adapter Pattern)",
      "categories": [
        "software-design"
      ],
      "tags": [
        "Adapter Pattern",
        "Design Pattern"
      ],
      "date": 1591960620000,
      "thumbnail": "/post/software-design/adapter-pattern-intro.svg",
      "profile-image": "/post/profile/profile0.jpg",
      "current-company": "Cubic INC",
      "current-position": "SI Researcher",
      "summary": "Adapter Pattern",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "소프트웨어 설계"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "구성요소",
            "title": "구성요소",
            "fragment": "root-0",
            "children": []
          },
          {
            "rank": 2,
            "origin": "예제",
            "title": "예제",
            "fragment": "root-1",
            "children": [
              {
                "rank": 3,
                "origin": "상황",
                "title": "상황",
                "fragment": "root-1-0",
                "children": []
              },
              {
                "rank": 3,
                "origin": "구성요소 정의",
                "title": "구성요소 정의",
                "fragment": "root-1-1",
                "children": []
              },
              {
                "rank": 3,
                "origin": "사용",
                "title": "사용",
                "fragment": "root-1-2",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "어댑터 패턴은 직접적으로 바로 사용이 불가능한 클래스를 사용할 수 있도록 하는 패턴이다.\n이 패턴은 기존의 클래스를 수정하지 않고, 새로운 클래스를 생성하여 기존의 클래스를 사용할 수 있도록 한다.",
    "content": "## 구성요소\n\n- Target: 어댑터 패턴을 사용하기 위한 인터페이스를 정의한다.\n- Adapter: Target 인터페이스를 구현하여 기존의 클래스를 사용할 수 있도록 한다.\n- Adaptee: 어댑터 패턴을 사용하기 위한 기존의 클래스이다.\n- Client: Adapter 패턴을 사용하는 클래스이다.\n\n## 예제\n\n먼저 Adapter 패턴을 사용하기 위해 선언한 핵심 구성요소는 아래와 같은 클래스들로 구성된다.\n\n### 상황\n\n기존에 사용하던 결제 시스템이 있다고 가정하자. 이 결제 시스템은 `Payment` 인터페이스를 구현하고 있다.\n하지만, 새로운 결제수단으로 PayPal을 사용하고자 한다. PayPal은 `PayPalAPI` 클래스를 사용하여 결제를 처리한다.\n이를 위해 추가적인 코드의 작성이 필요한 상황이다.\n\n\n### 구성요소 정의 \n\n::code-group\n\n```Payment.java\npublic interface Payment {\n\n    void processPayment(double amount);\n\n    PaymentStatus checkStatus(String paymentId);\n}\n\n```\n```PayPalAPI.java\npublic class PayPalAPI {\n\n    public void makePayment(PayPalPaymentRequest request) {\n        System.out.println(\"Making PayPal payment of \" + request.getAmount());\n    }\n\n    public PayPalPaymentStatus getPaymentStatus(PaypalTransactionId txId) {\n        return PayPalPaymentStatus.SUCCESS;\n    }\n}\n```\n```PayPalAdapter.java\npublic class PaypalAdapter implements Payment {\n\n    private final PayPalAPI payPalAPI;\n\n    public PaypalAdapter(PayPalAPI payPalAPI) {\n        this.payPalAPI = payPalAPI;\n    }\n\n    @Override\n    public void processPayment(double amount) {\n        PayPalPaymentRequest request = new PayPalPaymentRequest(amount);\n        payPalAPI.makePayment(request);\n    }\n\n    @Override\n    public PaymentStatus checkStatus(String paymentId) {\n        PaypalTransactionId txId = new PaypalTransactionId(paymentId);\n        PayPalPaymentStatus paymentStatus = payPalAPI.getPaymentStatus(txId);\n\n        return convertPayPalStatus(paymentStatus);\n    }\n    ...\n}\n```\n```PaymentProcessor.java\npublic class PaymentProcessor {\n\n    private final Payment paymentSystem;\n\n    public PaymentProcessor(Payment paymentSystem) {\n        this.paymentSystem = paymentSystem;\n    }\n\n    public void process(Order order) {\n        paymentSystem.processPayment(order.getTotal());\n        //결제상태 확인\n        PaymentStatus paymentStatus = paymentSystem.checkStatus(\"AE2D123-12\");\n        System.out.println(\"Payment status: \" + paymentStatus);\n\n    }\n}\n```\n\n::\n\n위의 코드로 어댑터 패턴의 핵심 구성요소를 설명하면 다음과 같다.\n\n* Target: Payment.java\n* Adapter: PaypalAdapter.java\n* Adaptee: PayPalAPI.java\n* Client: PaymentProcessor.java\n\n그리고 예시를 위해 추가적인 데이터가 아래와 같이 있다고 가정 한다.\n\n::code-group\n```PayPalPaymentRequest.java\n//페이팔 결제 요청정보\npublic class PayPalPaymentRequest {\n\n    private final double amount;\n\n    public PayPalPaymentRequest(double amount) {\n        this.amount = amount;\n    }\n\n    public double getAmount() {\n        return amount;\n    }\n}\n```\n\n```PaypalTransactionId.java\n//페이팔 결제 ID\npublic class PaypalTransactionId {\n\n    private final String txId;\n\n    public PaypalTransactionId(String txId) {\n        this.txId = txId;\n    }\n\n    public String getTxId() {\n        return txId;\n    }\n}\n```\n\n```Order.java\n//주문 정보\npublic class Order {\n\n    private final double total;\n\n    public Order(double total) {\n        this.total = total;\n    }\n\n    public double getTotal() {\n        return total;\n    }\n}\n```\n::\n\n위 정보를 조합하면 각 클래스간 역할 및 관계는 다음과 같다.\n\n```mermaid\n---\ntitle: 새로운 페이팔 결제수단에 대해 대응 가능한 어댑터 패턴\nconfig:\n    class:\n        hideEmptyMembersBox: true\n---\nclassDiagram\n    class Payment {\n        +processPayment(double amount): void\n        +checkStatus(String paymentId): PaymentStatus\n    }\n    class LegacyPayment {\n        +processPayment(double amount): void\n        +checkStatus(String paymentId): PaymentStatus\n    }\n    class PayPalAPI {\n        +makePayment(PayPalPaymentRequest request): void\n        +getPaymentStatus(PaypalTransactionId txId): PayPalPaymentStatus\n    }\n    class PaypalAdapter {\n        -payPalAPI: PayPalAPI\n        +processPayment(double amount): void\n        +checkStatus(String paymentId): PaymentStatus\n    }\n    class PaymentProcessor {\n        +process(Order order): void\n    }\n    class PayPalPaymentRequest {\n        -amount: double\n        +getAmount(): double\n    }\n    class PaypalTransactionId {\n        -value: String\n        +getTxId(): String\n    }\n    class PayPalPaymentStatus {\n        SUCCESS\n        PENDING\n        FAILED\n        REFUND_SUCCESS\n        CANCELLED\n    }\n    class PaymentStatus {\n        PENDING\n        COMPLETED\n        FAILED\n        REFUNDED\n        CANCELLED\n    }\n    class Order {\n        +getTotal(): double\n    }\n    Payment <|-- PaypalAdapter\n    Payment <|-- LegacyPayment\n    PaypalAdapter --> PayPalAPI\n    PaymentProcessor --> Payment\n    PaymentProcessor --> Order\n    PayPalAPI --> PayPalPaymentRequest\n    PayPalAPI --> PaypalTransactionId\n```\n\nAdapter 패턴의 사용으로 새로운 결제수단이 추가되어도 기존의 결제처리 로직을 변경하지 않고 사용할 수 있다.\n* PayPalAdapter는 Payment 인터페이스를 구현하여 내부적으로 PayPalAPI를 사용하며, 기존 결제에 대한 행동에는 변화가 없다.\n* Payment 역할을 그대로 수행하며 내부적으로 실제 처리과정만 다를 뿐이다.\n\n### 사용\n\n```java\nOrder order = new Order(100.0);\n\nPaymentProcessor processor = LocalDate.now().isBefore(LocalDate.of(2021, 4, 13))\n        ? new PaymentProcessor(new LegacyPayment())\n        : new PaymentProcessor(new PaypalAdapter(new PayPalAPI()));\n\nprocessor.process(order);\n```\n\n> 예를들어 `2021-04-13` 부터 PayPal 결제로만 서비스를 제공한다고 가정하면, 위와 같이 사용할 수 있다.\n:{ \"type\": \"tip\", \"icon\": \"info\" }\n"
  },
  {
    "path": "/docs/algorithm/insertion-sort",
    "header": {
      "layout": "post",
      "title": "Insertion Sort (삽입 정렬)",
      "categories": [
        "algorithm"
      ],
      "tags": [
        "Java",
        "Algorithm",
        "Sort",
        "Insertion Sort"
      ],
      "date": 1572945900000,
      "thumbnail": "/post/algorithm/insertion-sort-intro.png",
      "current-company": "Computer Academy",
      "current-position": "Student",
      "summary": "삽입 정렬",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "알고리즘"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "소개::intro",
            "title": "소개",
            "fragment": "intro",
            "children": []
          },
          {
            "rank": 2,
            "origin": "설명::how-to-make-insertion-sort",
            "title": "설명",
            "fragment": "how-to-make-insertion-sort",
            "children": []
          },
          {
            "rank": 2,
            "origin": "예제코드::example-code",
            "title": "예제코드",
            "fragment": "example-code",
            "children": []
          }
        ]
      }
    },
    "description": "정렬 방식중 하나인, 삽입 정렬에 대해 알아보자.",
    "content": "\n## 소개::intro\n\n🌸 삽입정렬은 배열을 순회하며, 삽입할 위치를 찾고 요소들을 **한단계씩 밀어** 해당 위치에 삽입하며 정렬하는 알고리즘 이다.\n삽입정렬 또한 선택정렬과 마찬가지로 정렬된 부분과 정렬되지 않은 부분으로 나뉜다.\n\n> **한단계씩 밀어** 라는 말은 `[ 1 ][ 3 ][ 2 ]` 에서 2라는 요소를 임시로 빼고 1 과 3사이에 들어갈공간을 만들기 위해 뺀 2의 자리로 3을 한 단계밀어,\n> `[ 1 ][    ][ 3 ]` 처럼 빈 공간을 만든 다는 의미이다.\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\"}\n\n---\n\n## 설명::how-to-make-insertion-sort\n\n순회 인덱스 i: 3 (0, 1, 2는 요소가 1, 4, 7이므로 정렬이되어 있으므로, 넘어간다.)\n\n[1, 4, `7`, 3, 2, 5] → [1, 4, **3**, `7`, 2, 5]\n\n> 삽입정렬은 지나온 요소들과 비교하여 밀면서 정렬해 나간다. 위 배열에서 1, 4, 7 요소는 정렬 되있기 때문에,\n> `j`는 (j = i - 1, 현재 3) 0이 될때까지 계속 순회하며 이전값과 비교하여 정렬 대상인지 아닌지를 판단한다.\n:{ \"type\": \"note\", \"icon\": \"info\"}\n\n순회 인덱스 i: 3\n\n> 한번의 정렬이 끝났으니 `j`를 감소시켜 또다시 이전 요소 (3과 4)를 비교하여 정렬대상이 되었다.\n> i는 현재 3이지만 `i` 이전의 인덱스를 가진 요소들은 정렬되지 않았기 때문에 `j`를 감소시켜가며 끝까지 정렬한다.\n:{ \"type\": \"note\", \"icon\": \"info\"}\n\n* 순회 인덱스 i: 3\n* 내부 순회 인덱스 j: 2 → 내부 순회 인덱스 j: 1\n\n[1, `4`, 3, 7, 2, 5] → [1, **3**, `4`, 7, 2, 5]\n\n> 내부 순회 인덱스를 줄여가며 정렬을 하였고 현재 내부 순회 인덱스(`j`)인 1에대한 요소(3)가 비교할 인덱스 0에대한 요소(1)과 정렬되어있다고 판단 하기에,\n> j는 더이상 감소시키지 않는다. 따라서 `i`를 다시 증가시키며 이과정을 반복하여 정렬한다.\n> 이후의 과정은 아래와 같다.\n:{ \"type\": \"note\", \"icon\": \"info\"}\n\n* 순회 인덱스 i: 4\n* 내부 순회 인덱스 j: 3 (i - 1)\n\n[1, 3, 4, `7`, **2**, 5] -> [1, 3, 4, **2**, `7`, 5]  \n\n* 순회 인덱스 i: 4\n* 내부 순회 인덱스 j: 2 (j--)\n\n[1, 3, `4`, **2**, 7, 5] -> [1, 3, **2**, `4`, 7, 5]\n\n* 순회 인덱스 i: 4\n* 내부 순회 인덱스 j: 1 (j--)\n\n[1, `3`, **2**, 4, 7, 5] -> [1, **2**, `3`, 4, 7, 5]  \n\n* 순회 인덱스 i: 5\n* 내부 순회 인덱스 j: 4 (j - 1)\n\n[1, 2, 3, 4, `7`, **5**] -> [1, 2, 3, 4, **5**, `7`]  \n\n* 정렬 결과\n\n[1, 2, 3, 4, 5, 7]\n\n> 모든 정렬을 수행했으므로 정렬이 완료되었다.\n:{ \"type\": \"tip\", \"icon\": \"check-circle\"}\n\n## 예제코드::example-code\n\n* 예제코드는 생각 보다 단순하다. 아래와 같이 배열을 순회하는 i가 있고, `array[1..i]`에서 정렬을 하는 방식이다.\n\n```java::InsertionSort.java\npublic class InsertionSort {\n    \n    public static void sort(int [] array) {\n\n        for (int i = 1; i < array.length; i++) {\n            int current = array[i];\n            int j = i - 1;\n\n            while(array[j + 1] < array[j]) {\n                array[j + 1] = array[j];\n                array[j--] = current;\n            }\n        }\n    }\n}\n```\n"
  },
  {
    "path": "/docs/software-design/class-diagram",
    "header": {
      "layout": "post",
      "title": "클래스 다이어그램",
      "categories": [
        "software-design"
      ],
      "tags": [
        "UML",
        "Class Diagram"
      ],
      "date": 1571376300000,
      "thumbnail": "/post/software-design/uml/class-diagram-intro.png",
      "profile-image": "/post/profile/profile0.jpg",
      "current-company": "Computer Academy",
      "current-position": "Student",
      "summary": "Class Diagram",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "소프트웨어 설계"
      ],
      "images": [
        {
          "src": "/post/software-design/uml/relationship-line.png",
          "alt": "클래스 다이어그램의 관계 선"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "관계를 나타내는 화살표::relationship-line",
            "title": "관계를 나타내는 화살표",
            "fragment": "relationship-line",
            "children": [
              {
                "rank": 3,
                "origin": "Associations (연관)::associations",
                "title": "Associations (연관)",
                "fragment": "associations",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "소프트 웨어에서는 각 객체와 객체 간의 관계를 표현하기 위해 클래스 다이어그램을 사용한다. \n\n클래스 다이어그램은 클래스의 속성과 메서드를 표현하고, 클래스 간의 관계를 표현한다. \n클래스 다이어그램은 객체 지향 프로그래밍에서 가장 많이 사용되는 다이어그램 중 하나이다.\n\n클래스 다이어그램의 구성요소를 알아보자.",
    "content": "\n## 관계를 나타내는 화살표::relationship-line\n\n![클래스 다이어그램의 관계 선](/post/software-design/uml/relationship-line.png)\n:{ \"align\": \"center\", \"max-width\": \"400px\", \"description\": \"클래스간의 관계를 나타내는 Relationship Line\" }\n\n클래스 다이어그램에서는 클래스간 관계를 나타내는 화살표를 사용한다.\n각 관계를 나타내는 의미를 알아보자.\n\n### Associations (연관)::associations\n\n*한 모델 요소의 인스턴스들이 다른 모델 요소의 인스턴스들과 연결되었다는 것을 나타낸다.*\n\n**단방향 연관 관계**\n\n```mermaid\nclassDiagram\n    direction LR\n    class Student {\n        -name: String\n    }\n    class Teacher {\n        -name: String\n        -children: List~Student~\n        +check(Student student): void\n    }\n    Teacher --> Student\n```\n\n**양방향 연관관계**\n\n```mermaid\nclassDiagram\n    direction LR\n    class Child {\n        -name: String\n        -parent: Parent\n    }\n    class Parent {\n        -name: String\n        -child: Child\n    }\n    Child <--> Parent\n```\n\n이 다이어 그램은 학생과 선생님의 관계를 나타낸다. 선생님은 학생들을 관리하기 위해 항상 참조한다.\n하지만, 학생은 선생님이 관심 없기 때문에 신경을 안쓰므로 학생은 선생님을 참조하지 않는다.\n이는 단방향 관계이다.\n\n하지만 반대로 자식과 부모의 관계는 양방향 관계이다. 부모는 자식과, 자식은 부모와 가족이기 때문에 서로를 참조한다.\n\n> 이처럼 단방향 또는 양방향으로 어떤 모델의 인스턴스를 참조하는 관계를 `연관관계`라고 한다.\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\" }\n\n"
  }
]