[
  {
    "path": "/docs/computer-science/computer-structure/io-manager",
    "header": {
      "layout": "wiki",
      "title": "입출력 관리자",
      "tags": [
        "I/O Manager",
        "I/O"
      ],
      "summary": "I/O Manager",
      "hide": true,
      "date": 1999999999999,
      "breadcrumbs": [
        "문서",
        "컴퓨터",
        "하드웨어"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "I/O Manager란?",
            "title": "I/O Manager란?",
            "fragment": "root-0",
            "children": []
          },
          {
            "rank": 2,
            "origin": "PCI express",
            "title": "PCI express",
            "fragment": "root-1",
            "children": []
          },
          {
            "rank": 2,
            "origin": "Bridge (North Bridge, South Bridge)",
            "title": "Bridge (North Bridge, South Bridge)",
            "fragment": "root-2",
            "children": []
          },
          {
            "rank": 2,
            "origin": "I/O Manager의 역할",
            "title": "I/O Manager의 역할",
            "fragment": "root-3",
            "children": []
          }
        ]
      }
    },
    "description": "",
    "content": "\r\n## I/O Manager란?\r\n\r\n## PCI express\r\n\r\n## Bridge (North Bridge, South Bridge)\r\n\r\n## I/O Manager의 역할\r\n"
  },
  {
    "path": "/docs/computer-science/computer-structure/programmed-io",
    "header": {
      "layout": "wiki",
      "title": "Programmed Input/Output (PIO)",
      "tags": [
        "Hardware",
        "PIO"
      ],
      "summary": "PIO",
      "hide": true,
      "date": 1999999999999,
      "breadcrumbs": [
        "문서",
        "컴퓨터",
        "하드웨어"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "PIO란?",
            "title": "PIO란?",
            "fragment": "root-0",
            "children": []
          },
          {
            "rank": 2,
            "origin": "PIO의 데이터 전송방식",
            "title": "PIO의 데이터 전송방식",
            "fragment": "root-1",
            "children": []
          }
        ]
      }
    },
    "description": "",
    "content": "\r\n## PIO란?\r\n\r\n`Programmed I/O`(이하 PIO)는 말그대로 프로그램 입출력이다. `PIO` 방식은 [네트워크 어댑터]() 또는 [ATA]() 기억장치 같은 주변기기와 [CPU](/wiki/central-processing-unit) 사이에서 데이터를 주고 받는다.\r\nCPU의 개입으로 처리되므로 성능에 영향을 주며, 이러한 단점을 극복하기 위해 [인터럽트](/wiki/interrupt)나 [DMA](/wiki/direct-memory-access)같은 방식이 고안되었다.\r\n\r\n\r\n## PIO의 데이터 전송방식\r\n\r\n`PIO`는 CPU가 데이터를 읽거나 쓸 장치에대해서 주소신호(대상주소)와 제어신호(IOR, IOW)로 I/O 활성화가 이루어지면 데이터버스를 통해 전송된다. \r\n"
  },
  {
    "path": "/docs/infrastructure/kubernetes/update-istio",
    "header": {
      "layout": "post",
      "title": "istio 업데이트 (1.22.1 -> 1.25.0)",
      "tags": [
        "Spring",
        "Spring Boot",
        "Spring Security"
      ],
      "date": 1743479880000,
      "thumbnail": "/post/infrastructure/kubernetes/update-istio.webp",
      "current-company": "NEOWIZ",
      "current-position": "Software Engineer",
      "summary": "istio 업데이트",
      "excerpt_separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "인프라",
        "쿠버네티스"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "선행 지식::prerequisites",
            "title": "선행 지식",
            "fragment": "prerequisites",
            "children": []
          },
          {
            "rank": 2,
            "origin": "설치::install-istio",
            "title": "설치",
            "fragment": "install-istio",
            "children": []
          },
          {
            "rank": 2,
            "origin": "버전 업데이트",
            "title": "버전 업데이트",
            "fragment": "root-2",
            "children": []
          },
          {
            "rank": 2,
            "origin": "레이블 적용 및 사이드카 주입::labeling-and-inject-sidecar",
            "title": "레이블 적용 및 사이드카 주입",
            "fragment": "labeling-and-inject-sidecar",
            "children": []
          },
          {
            "rank": 2,
            "origin": "TL;DR::too-long-did-not-read",
            "title": "TL;DR",
            "fragment": "too-long-did-not-read",
            "children": []
          }
        ]
      }
    },
    "description": "관리하는 K8s 버전이 올라가면서, 필요한 istio 업데이트 진행을 간단히 정리해보자.",
    "content": "\r\n\r\n## 선행 지식::prerequisites\r\n\r\n1. 핵심 컴포넌트\r\n   * istiod: 컨트롤 플레인 (istio-system namespace에 위치하며 워커 노드에 배포)\r\n   * istio-proxy: 사이드카 프록시 (각 어플리케이션 Pod에 주입되며 istiod와 통신)\r\n   * istio-ingressgateway: 인바운드 트래픽 처리\r\n   * istio-egressgateway: 아웃바운드 트래픽 처리 (선택적)\r\n2. 관리도구\r\n   * istioctl: istio CLI 도구 (클라이언트)\r\n   * kubectl: k8s CLI 도구 (클라이언트)\r\n3. 리소스\r\n   * Namespace: istio-system\r\n   * Pod: 컨테이너 실행단위\r\n   * Service: 서비스 디스커버리와 로드밸런싱\r\n   * Deployment: Pod 관리 및 배포\r\n4. 아키텍쳐 용어\r\n   * Control Plane: 중앙 제어/관리 부분\r\n   * Data Plane: 실제 트래픽을 처리하는 부분\r\n   * Sidecar: 메인 컨테이너와 함께 실행되는 보조 컨테이너\r\n\r\n## 설치::install-istio\r\n\r\n먼저 istio를 설치하기전에 [kubectl](https://kubernetes.io/ko/docs/tasks/tools/install-kubectl-linux/)과 [istioctl](https://github.com/istio/istio/releases)을 설치해야한다. \r\n\r\n> kubectl을 설치하고 클러스터 설정이 되지않았다면, `aws eks update-kubeconfig --name 클러스터이름 --region 리전이름 --profile 프로필이름` 명령으로 설정할 수 있다.\r\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\" }\r\n\r\n`istioctl`이 설치되었다면 다음의 명령으로 `kubectl context`에 설정된 클러스터의 검사를 진행한다.\r\n\r\n```\r\n> istioctl x precheck\r\n✔ No issues found when checking the cluster. Istio is safe to install or upgrade!\r\n  To get started, check out https://istio.io/latest/docs/setup/getting-started/.\r\n```\r\n\r\n위와 같이 나온다면, 정상적으로 설치가 가능한 상태이다.\r\n\r\n```\r\n> ./istioctl install --set revision=1-25-0\r\n        |\\\r\n        | \\\r\n        |  \\\r\n        |   \\\r\n      /||    \\\r\n     / ||     \\\r\n    /  ||      \\\r\n   /   ||       \\\r\n  /    ||        \\\r\n /     ||         \\\r\n/______||__________\\\r\n____________________\r\n  \\__       _____/\r\n     \\_____/\r\n\r\nThis will install the Istio 1.25.0 profile \"default\" into the cluster. Proceed? (y/N) y\r\n✔ Istio core installed ⛵️\r\n✔ Istiod installed 🧠\r\n✔ Ingress gateways installed 🛬\r\n✔ Installation complete\r\n```\r\n\r\n위 처럼 설치가 완료되었다면, service, pod, configmap을 모두 확인해보자.\r\n\r\n```\r\n> kubectl get svc -n istio-system\r\nNAME                   TYPE           CLUSTER-IP       EXTERNAL-IP\r\nistio-ingressgateway   LoadBalancer   {Clister IP}     {AWS ELB DNS Address}\r\nistiod-1-22-1          ClusterIP      {Clister IP}     <none>\r\nistiod-1-25-0          ClusterIP      {Clister IP}     <none>\r\n\r\n> kubectl get pods -n istio-system\r\nNAME                                   READY   STATUS    RESTARTS   AGE\r\nistio-ingressgateway-655dc875b-sgsgm   1/1     Running   0          6m31s\r\nistiod-1-22-1-94f886767-lxjdh          1/1     Running   0          77d\r\nistiod-1-22-1-94f886767-qrccf          1/1     Running   0          77d\r\nistiod-1-25-0-85c49d99c6-x8cv5         1/1     Running   0          6m43s\r\n\r\n> kubectl get configmap -n istio-system\r\nNAME                                  DATA   AGE\r\nistio-1-22-1                          2      188d\r\nistio-1-25-0                          2      7m54s\r\nistio-ca-root-cert                    1      ...\r\nistio-gateway-deployment-leader       0      ...\r\nistio-gateway-status-leader           0      ...\r\nistio-ip-autoallocate                 0      7m43s\r\nistio-leader                          0      ...\r\nistio-namespace-controller-election   0      ...\r\nistio-sidecar-injector-1-22-1         2      188d\r\nistio-sidecar-injector-1-25-0         2      7m54s\r\nkube-root-ca.crt                      1      ...\r\n```\r\n\r\n설치가 정상적으로 된것으로 보인다. \r\n\r\n\r\n## 버전 업데이트\r\n\r\n안전한 업그레이드를 위해 현재 사용중인 Sidecar Injector ConfigMap을 백업 해두자.\r\n\r\n```\r\nk get configmap -n istio-system istio-sidecar-injector-1-25-0 -o yaml > istio-sidecar-injector-1.25.0.yaml\r\n```\r\n\r\ncanary(신규 버전)와 stable(현재 버전) 태그로 안정적인 배포전략을 사용중이기 때문에, 태그설정이 필요하다.\r\n\r\n```shell::태그 확인\r\n> istioctl tag list\r\nTAG    REVISION NAMESPACES\r\ncanary 1-22-1\r\nstable 1-22-1   some-qa,some-staging\r\n       1-25-0\r\n```\r\n현재는 `qa`와 `staging` namespace모두 stable로 적용되어있기 때문에 새로 변경할 1.25.0 revision을 canary로 바꿔줘야한다.\r\n\r\n```shell::새로운 버전을 canary로 변경\r\n> istioctl tag set canary --revision 1-25-0 --overwrite\r\nRevision tag \"canary\" created, referencing control plane revision \"1-25-0\". To enable injection using this\r\nrevision tag, use 'kubectl label namespace <NAMESPACE> istio.io/rev=canary'\r\n> istioctl tag show\r\nTAG    REVISION NAMESPACES\r\nstable 1-22-1   some-qa, some-staging\r\ncanary 1-25-0\r\n```\r\n\r\n## 레이블 적용 및 사이드카 주입::labeling-and-inject-sidecar\r\n\r\n리비전 태그를 생성했다면, 이제 가이드 대로 레이블을 namespace에 적용할 수 있다.\r\n\r\n```shell::레이블 적용 및 확인\r\n> kubectl label namespace some-qa istio.io/rev=canary --overwrite\r\nnamespace/some-qa labeled\r\n> k get ns -L istio.io/rev\r\nNAME                     STATUS   AGE    REV\r\n...\r\nistio-operator           Active   188d\r\nistio-system             Active   ...\r\n...\r\nsome-qa                  Active   ....   canary\r\nsome-staging             Active   ....   stable\r\n> k get ns --show-labels\r\nNAME                     STATUS   AGE    LABELS\r\n...\r\nsome-qa                  Active   509d   ...,istio.io/rev=canary,...\r\nsome-staging             Active   509d   ...,istio.io/rev=stable,...\r\n```\r\n\r\n레이블이 정상적으로 namespace에 적용된걸 확인 할 수 있다. 이제 배포를 하여, 사이드카가 정상적으로 들어가는지 확인이 필요하다.\r\n\r\n::code-group\r\n\r\n```shell::배포 전(1.22.1) 확인\r\n> kubectl describe pod foo-pod -n some-qa | grep -A 10 \"Init Containers:\"\r\nInit Containers:\r\n  istio-init:\r\n    Container ID:  containerd://...\r\n    Image:         .../istio/proxyv2:1.22.1\r\n    Image ID:      .../istio/proxyv2@sha256:...\r\n    Port:          <none>\r\n    Host Port:     <none>\r\n    Args:\r\n      istio-iptables\r\n      -p\r\n      15001\r\n```\r\n\r\n```shell::어플리케이션 재배포\r\n> kubectl -n some-qa rollout restart deploy foo-pod\r\ndeployment.apps/foo-pod restarted\r\n```\r\n\r\n```shell::배포 후(1.25.0)\r\n> kubectl describe pod foo-pod -n some-qa | grep -A 10 \"Init Containers:\"\r\nInit Containers:\r\n  istio-init:\r\n    Container ID:  containerd://...\r\n    Image:         .../istio/proxyv2:1.25.0\r\n    Image ID:      .../istio/proxyv2@sha256:...\r\n    Port:          <none>\r\n    Host Port:     <none>\r\n    Args:\r\n      istio-iptables\r\n      -p\r\n      15001\r\n```\r\n::\r\n\r\nnamespace에 있는 `foo-pod` deployment의 모든 pod을 재시작 했다면, 위와 같이 sidecar injection이 정상적으로 되었을 것이다.\r\n(`istioctl proxy-status`로 컨텍스트에 배포된 상태를 확인 할 수 있다.)\r\n\r\n테스트가 완료되었다면, stable 태그를 새로운 버전으로 변경해주고, 나머지 운영 namespace를 다시 업데이트 해줘야한다.\r\n```shell::태그 변경 및 레이블링\r\n> istioctl tag set stable --revision 1-25-0 --overwrite\r\nRevision tag \"stable\" created, referencing control plane revision \"1-25-0\". To enable injection using this\r\nrevision tag, use 'kubectl label namespace <NAMESPACE> istio.io/rev=stable'\r\n\r\n> istioctl tag show\r\nTAG    REVISION NAMESPACES\r\n       1-22-1\r\ncanary 1-25-0   some-qa,some-staging\r\nstable 1-25-0\r\n\r\n> kubectl label namespace some-qa istio.io/rev=stable --overwrite\r\nnamespace/some-qa labeled\r\n> kubectl label namespace some-staging istio.io/rev=stable --overwrite\r\nnamespace/some-staging labeled\r\n```\r\n\r\n```shell::Pod 재배포\r\n> kubectl rollout restart -n some-qa foo-pod\r\n> kubectl rollout restart -n some-staging foo-pod\r\n```\r\n\r\n배포가 정상적으로 되었고, 기존 버전을 사용하는 namespace가 없다면 제거해도 좋다.\r\n```shell::기존버전 확인 및 삭제\r\n# 1.25.0이외 버전을 사용하는지 확인\r\n> istioctl proxy-status\r\nNAME                                                  CLUSTER        CDS                LDS                EDS                RDS                ECDS        ISTIOD                             VERSION\r\n...\r\nfoo-pod-6566b68d8f-8l7c6.some-qa                      Kubernetes     SYNCED (4m5s)      SYNCED (4m5s)      SYNCED (2m15s)     SYNCED (4m5s)      IGNORED     istiod-1-25-0-85c49d99c6-x8cv5     1.25.0\r\nfoo-pod-b649ff85-rz68n.some-staging                   Kubernetes     SYNCED (4m5s)      SYNCED (4m5s)      SYNCED (2m15s)     SYNCED (4m5s)      IGNORED     istiod-1-25-0-85c49d99c6-x8cv5     1.25.0\r\n\r\n# 삭제\r\n> istioctl uninstall --revision 1-22-1\r\nNo resources will be pruned from the cluster. Please double check the input configs\r\n\r\n✔ Uninstall complete\r\n```\r\n\r\n## TL;DR::too-long-did-not-read\r\n\r\n1. 설치전 클러스터 확인\r\n   * `> istioctl x precheck`\r\n2. istio 설치 (istiod Depoloyment, ConfigMap, Service 생성)\r\n   * `> istioctl install --set revision=1-25-0`\r\n3. 설치 확인\r\n   * `kubectl get svc -n istio-system`\r\n   * `kubectl get pods -n istio-sytem`\r\n   * `kubectl get configmap -n istiosystem`\r\n4. 필요한 ConfigMap 백업 (선택)\r\n   * `kubectl get configmap -n istio-system istio-sidecar-1-25-0 -o yaml > istio-sidecar-injector-1.25.0.yaml`\r\n5. 태그 설정 및 레이블 적용 (태그 확인: `istioctl tag show`)\r\n   1. `istioctl tag set canary --revision 1-25-0 --overwrite`\r\n   2. canary(테스트용): `kubectl label namepsace 네임스페이스명 istio.io/rev=canary`\r\n      * canary는 배포 테스트를 위해 적용하는 임시적인 레이블\r\n   3. stable(서비스용): `kubectl lable namespace 네임스페이스명 istio.io/rev=stable`\r\n6. 서비스 배포 (배포 전 레이블 확인: `kubectl get ns --show-labels`)\r\n   * `kubectl rollout restart deploy -n 네임스페이스명 파드명`\r\n   * 서비스 배포후 정상적으로 동작한다면, 5-3 진행\r\n7. 프록시 상태 확인 및 삭제\r\n   * `istioctl proxy-status`\r\n   * 삭제: `istioctl uninstall --revision 1-22-1`"
  },
  {
    "path": "/docs/back-end/spring/spring-security",
    "header": {
      "layout": "post",
      "title": "스프링 시큐리티 프로젝트 구성",
      "tags": [
        "Spring",
        "Spring Boot",
        "Spring Security"
      ],
      "date": 1742961480000,
      "thumbnail": "/post/back-end/spring/spring-security.svg",
      "current-company": "NEOWIZ",
      "current-position": "Software Engineer",
      "summary": "트랜잭션 관리자",
      "excerpt_separator": "<!--more-->",
      "hide": true,
      "breadcrumbs": [
        "문서",
        "서버/백엔드",
        "스프링"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "임시 비밀번호::temporary-password",
            "title": "임시 비밀번호",
            "fragment": "temporary-password",
            "children": []
          },
          {
            "rank": 2,
            "origin": "보안 설정::configure-security",
            "title": "보안 설정",
            "fragment": "configure-security",
            "children": [
              {
                "rank": 3,
                "origin": "폼 로그인::form-login",
                "title": "폼 로그인",
                "fragment": "form-login",
                "children": []
              },
              {
                "rank": 3,
                "origin": "HTTP 기본인증::http-basic-authentication-scheme",
                "title": "HTTP 기본인증",
                "fragment": "http-basic-authentication-scheme",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "스프링 시큐리티 프로젝트 구성시, 필요한 기능을 정리한다.",
    "content": "\r\n\r\n## 임시 비밀번호::temporary-password\r\n\r\n```\r\nUsing generated security password: c76d7851-5e89-4ef3-bc5d-cb04d5d5e365\r\n```\r\n\r\n스프링 시큐리티 의존성이 있는 프로젝트를 실행하면 위와 같이 UUID와 같은 임시 비밀번호를 부여 받는다.\r\n스프링 시큐리티는 기본적으로 모든 엔드 포인트를 보호한다. 이말은 즉, 설정으로 특정 API의 자격증명을 요구하도록 하지않는 한 모든 엔드포인트는 자격증명을 요구한다는 말이다.\r\n\r\n따라서 자격 증명을 준비할 수 없느 상황에 대비하여 임시 비밀번호로 자격증명을 사용하게 해주는 기능이다.\r\n\r\n> 당연히 자격 증명을 대신하므로, 개발환경(또는 로컬)에서 만 사용하는것을 권장한다. 이 값은 서버를 다시 시작하면 새로 발급된다.\r\n:{ \"type\": \"caution\", \"icon\": \"info\" }\r\n\r\n## 보안 설정::configure-security\r\n\r\n```java\r\n@Configuration\r\n@EnableWebSecurity\r\npublic class SecurityConfiguration {\r\n    ...\r\n}\r\n```\r\n\r\n`Spring Security`는 간단한 설정으로 강력한 보안을 지원한다.\r\n위와 같이 `@EnableWebSecurity` 어노테이션 추가시, 내부적으로 웹 보안과 관련된 여러 설정들을 가져온다.\r\n\r\n```javascript\r\n@Import({\r\n    WebSecurityConfiguration.class, SpringWebMvcImportSelector.class, OAuth2ImportSelector.class,\r\n    HttpSecurityConfiguration.class, ObservationImportSelector.class\r\n})\r\n```\r\n\r\n어쨋든 기본 설정을 사용자화 하려면 `SecurityFilterChain`을 Bean으로 등록해주면 된다.\r\n\r\n```java\r\n@Bean\r\npublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\r\n    return http.build();\r\n}\r\n```\r\n\r\n기본적으로 등록을하고, HttpSecurity 객체로 변경할 수 있다.\r\n\r\n### 폼 로그인::form-login\r\n\r\n임시 비밀번호로 받은 임의의 문자열은 `/login` 페이지에서 사용가능하다. 필터체인을 Bean으로 등록하지않는 이상 기본적으로 폼로그인은 활성화 된다.\r\n\r\n먼저 폼 로그인은 Username에 `user` 그리고 Password에 [임시 비밀번호](#임시-비밀번호temporary-password)로 로그인이 가능하다.\r\n폼 로그인은 다음과 같이 처리된다.\r\n\r\n```java::비활성화 (다른 인증방법을 사용해야함)\r\nhttp.formLogin(form -> form.disable());\r\n```\r\n\r\n```java::활성화 (폼로그인으로 사용)\r\nhttp.formLogin(form -> form.permitAll());\r\n```\r\n\r\n만약 @Bean만 등록하고 폼 로그인에대해 설정하지 않는다면 비활성화이다 (Bean 자체가 빈 설정으로 등록됨).\r\n\r\n### HTTP 기본인증::http-basic-authentication-scheme\r\n\r\nHTTP 기본인증은 [RFC 2617](https://datatracker.ietf.org/doc/html/rfc2617) 사양의 `HTTP Basic Authentication Scheme`이다.\r\n\r\n```java\r\nhttp.httpBasic(basic -> basic.disable());\r\n```\r\n\r\nHTTP 기본 인증 스킴(`Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==`) 비활성화는 위와 같이 할 수있다.\r\n\r\n"
  },
  {
    "path": "/docs/life/youth-of-ggomi",
    "header": {
      "layout": "post",
      "title": "꼬미의 젊은 시절",
      "description": "이빨로 무는 노루",
      "tags": [
        "Life"
      ],
      "date": 1734591600000,
      "thumbnail": "/post/life/tired-ggomi.png",
      "current-company": "NEOWIZ",
      "current-position": "Software Engineer",
      "summary": "나란 꼬미",
      "excerpt-separator": "<!--more-->",
      "hide": true,
      "breadcrumbs": [
        "문서",
        "일상"
      ],
      "images": [
        {
          "src": "/post/life/first-day-of-ggomi.jpg",
          "alt": "꼬미가 처음 온 날"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": []
      }
    },
    "description": "",
    "content": "\r\n\r\n![꼬미가 처음 온 날](/post/life/first-day-of-ggomi.jpg)\r\n:{ \"align\": \"center\", \"description\": \"꼬미가 처음 온날\", \"max-width\": \"300px\"}\r\n\r\n꼬미는 엄마를 잃고, 죽어 가던 형제들 사이에서 같이 생명을 잃어가고 있었다.  \r\n꼬미는 태어났을때 다른 강아지들보다 너무 작아서 쪼꼬미라고 지었다. (엄마가 조씨라서 조꼬미)  \r\n\r\n집에 데려가던 차안에서 토를 했는데, 몇 백마리의 기생충이 나왔다.\r\n"
  },
  {
    "path": "/docs/database/mysql-explain",
    "header": {
      "layout": "post",
      "title": "MySQL의 EXPLAIN을 알아보자",
      "tags": [
        "Database",
        "MySQL",
        "EXPLAIN"
      ],
      "date": 1724390820000,
      "thumbnail": "/post/database/mysql/mysql-explain-thumbnail.webp",
      "current-company": "NEOWIZ",
      "current-position": "Software Engineer",
      "summary": "MySQL 실행계획",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "데이터베이스"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "EXPLAIN 출력 컬럼::explain-output-columns",
            "title": "EXPLAIN 출력 컬럼",
            "fragment": "explain-output-columns",
            "children": [
              {
                "rank": 3,
                "origin": "id (SELECT 순서)::id",
                "title": "id (SELECT 순서)",
                "fragment": "id",
                "children": []
              },
              {
                "rank": 3,
                "origin": "select_type (SELECT 타입)::select-type",
                "title": "select_type (SELECT 타입)",
                "fragment": "select-type",
                "children": []
              },
              {
                "rank": 3,
                "origin": "table (참조 테이블)::table",
                "title": "table (참조 테이블)",
                "fragment": "table",
                "children": []
              },
              {
                "rank": 3,
                "origin": "partition (파티션)::partition",
                "title": "partition (파티션)",
                "fragment": "partition",
                "children": []
              },
              {
                "rank": 3,
                "origin": "type (조인타입)::type",
                "title": "type (조인타입)",
                "fragment": "type",
                "children": []
              },
              {
                "rank": 3,
                "origin": "possible_keys (사용가능한 인덱스)::possible-keys",
                "title": "possible_keys (사용가능한 인덱스)",
                "fragment": "possible-keys",
                "children": []
              },
              {
                "rank": 3,
                "origin": "key (사용할 인덱스)::key",
                "title": "key (사용할 인덱스)",
                "fragment": "key",
                "children": []
              },
              {
                "rank": 3,
                "origin": "key_len (키의 길이)::key-len",
                "title": "key_len (키의 길이)",
                "fragment": "key-len",
                "children": []
              },
              {
                "rank": 3,
                "origin": "ref (참조 값)::ref",
                "title": "ref (참조 값)",
                "fragment": "ref",
                "children": []
              },
              {
                "rank": 3,
                "origin": "rows (검사 행 개수)::rows",
                "title": "rows (검사 행 개수)",
                "fragment": "rows",
                "children": []
              },
              {
                "rank": 3,
                "origin": "filtered (필터된 수치)::filtered",
                "title": "filtered (필터된 수치)",
                "fragment": "filtered",
                "children": []
              },
              {
                "rank": 3,
                "origin": "Extra (추가적인 내용)::extra",
                "title": "Extra (추가적인 내용)",
                "fragment": "extra",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "MySQL의 쿼리실행계획에 대해 알아보자.",
    "content": "\r\n\r\n회사에서는 신규유입되는 쿼리에 한에 검수할 수 있는 툴을 만들었다.\r\n\r\n나는 담당하는 서비스에 대해 신규 유입 쿼리를 검수해야하며, 매우 많은 쿼리를 봐야만 했다. \r\n이는 반복적인 업무(쿼리 복사, 테이블 및 인덱스확인, 검수)로 이어졌으며, 실행계획만으로 분석해야하는 대상인지를 1차적으로 판단할 필요가있었다.\r\n\r\n쿼리는 여러 유입 목록중 하나를 상세보기로 전체쿼리를 보아 DB Client(Datagrip)로 가져와서 한개씩 확인 해야했다. \r\n해당 목록에는 쿼리 실행계획도 포함이 되어있기때문에, 상세보기를 보지않고, 목록에서 실행계획만 본다면 바로 판단이 가능하다고 생각되어, 실행 계획을 공부하기로 했다.  \r\n\r\n---\r\n\r\n`EXPLAIN`은 MySQL이 statement를 어떻게 실행하는지에 대한 정보를 제공한다.\r\n`EXPLAIN`은 `SELECT`쿼리 에서 사용되는 각 테이블에 대한 정보를 반환하며, 이는 [Mysql Query Optimizer]() 가 명령문을 처리하면서 읽는 순서대로 테이블을 나열한다. \r\n이 말은 MySQL이 첫번째 테이블에서 행을 읽고 두번째 테이블에서 매치되는 행을 찾은 다음, 세번째 테이블에서, 그리고 계속 그렇게 진행한다는 의미이다. \r\n\r\n\r\n\r\n## EXPLAIN 출력 컬럼::explain-output-columns\r\n\r\n`EXPLAIN`의 각 출력 행은 하나의 테이블에 대한 정보를 제공한다. 각 행은  아래 `표 1.1 EXPLAIN 출력 컬럼들` 에 요약된 값을 포함한다.\r\n테이블의 첫번째 컬럼에는 컬럼명, 두번째는 `FORMAT=JSON`이 사용될때 출력에서 보여지는 프로퍼티명을 제공한다.\r\n\r\n\r\n\r\n*표 1.1 EXPLAIN 출력 컬럼들*\r\n\r\n| 컬럼          | JSON 이름     | 의미                             |\r\n| ------------- | ------------- | -------------------------------- |\r\n| id            | select_id     | SELECT 식별자                    |\r\n| select_type   | 없음          | SELECT 타입                      |\r\n| table         | table_name    | 결과 행에 대한 테이블            |\r\n| partitions    | partitions    | 매칭되는 파티션                  |\r\n| type          | access_type   | JOIN 타입                        |\r\n| possible_keys | possible_keys | 선택에 사용가능한 index들        |\r\n| key           | key_length    | 선택된 키의 길이                 |\r\n| ref           | ref           | index에 비교되는 컬럼들          |\r\n| rows          | rows          | 조사될 예상행                    |\r\n| filtered      | filtered      | 테이블 조건에서 걸러진 행의 비율 |\r\n| extra         | 없음          | 추가 정보                        |\r\n\r\n\r\n\r\n### id (SELECT 순서)::id\r\n(JSON: selected_id)  \r\nSELECT 식별자이다. 쿼리 내에서 SELECT의 순서가 있는 숫자이며,  다른 행의 `UNION` 결과를 행이 참조한다면 값은 null일 수 있다. \r\n이 경우 테이블 컬럼은 id 값들의 M과 N인 행의 `UNION`에 행이 참조하는 행을 나타내기 위해, <union**M**,**N**> 같은 값을 보여준다.\r\n  \r\n\r\n### select_type (SELECT 타입)::select-type   \r\n(JSON: 없음)  \r\n아래 보여진 테이블중 어떤 `SELECT`의 타입이다. JSON-formatted EXPLAIN은  `SIMPLE`이나 `PRIMARY`가 아닌 한  `query_block`의 프로퍼티로 SELECT 타입을 노출한다.\r\n\r\n| select_type **값**   | JSON 이름                  | Meaning                                                      |\r\n| -------------------- | -------------------------- | ------------------------------------------------------------ |\r\n| SIMPLE               | 없음                       | 간단한 SELECT (UNION 또는 서브쿼리 사용 X)                   |\r\n| PRIMARY              | 없음                       | 가장 바깥쪽 SELECT                                           |\r\n| UNION                | 없음                       | UNION의 두번째 이상의 SELECT                                 |\r\n| DEPENDENT UNION      | dependent (true)           | 바깥쪽 쿼리에 의존되는 UNION에서 두번째 이상의 SELECT        |\r\n| UNION RESULT         | union_result               | UNION의 결과                                                 |\r\n| SUBQUERY             | 없음                       | 서브쿼리의 첫번째 SELECT                                     |\r\n| DEPENDENT SUBQUERY   | dependent (true)           | 바깥쪽 쿼리에 의존되는 서브쿼리의 첫번째 SELECT              |\r\n| DERIVED              | 없음                       | 파생된 테이블 (서브쿼리로 만들어진 임시테이블)               |\r\n| DEPENDENT DERIVED    | depentent (true)           | 또다른 테이블을 의존하는 파생된 테이블                       |\r\n| MATERIALIZED         | materialized_from_subquery | 서브쿼리로 물질화                                            |\r\n| UNCHAHEABLE SUBQUERY | cacheable (false)          | 바깥쪽 쿼리의 각  행에대해 결과가 캐시될수 없고 재 평가 되어아야하는 서브쿼리 |\r\n| UNCACHEABLE UNION    | cacheable (false)          | 캐시를 할 수 없는 서브쿼리에 속해있는 UNION 내 두번째 이상 SELECT |\r\n\r\n> `DEPENDENT`는 일반적으로 [상관관계 서브쿼리](https://dev.mysql.com/doc/refman/8.4/en/correlated-subqueries.html) 사용을 의미한다.\r\n:{ \"type\": \"note\", \"icon\": \"info\"}\r\n\r\n### table (참조 테이블)::table\r\n(JSON: table_name)    \r\n출력행이 참조하는 테이블명이며, 다음 값중 하나가 될 수도 있다.\r\n* <union**M**, **N**>:  행은 **M** 과 **N**의 id 값을 갖는 행의 union을 합집합을 참조한다.\r\n* <deribed**N**>: 행은 **N**의 값을 갖는 행에 대한 파생된 테이블의 결과를 참조한다.  파생된 테이블은 예를들어 `FROM`절 내 서브쿼리에서 생성될 수도 있다.\r\n* <subquery**N**>: 행은 **N**의 id값을 갖는 행에대해 구체화된 서브쿼리(Materialized Subquery)의 결과를 참조한다.\r\n\r\n### partition (파티션)::partition\r\n(JSON: partitions)  \r\n  쿼리로부터 매칭될수 있는 레코드에서의 파티션이다. 파티셔닝 되지않은 테이블에 대해서는 `NULL` 이다.\r\n\r\n### type (조인타입)::type\r\n(JSON: access_type)\r\n조인 타입이며, 테이블들을 어떻게 조인하는지 설명을 출력한다. JSON-formatted 출력에서는 acess_type의 속성 값으로 나온다. 다음에 목록은 조인타입을 좋은 케이스부터 안좋은케이스 순으로 설명한다.\r\n* system  \r\n  테이블이 한개의 로우(= 시스템 테이블)만 가지고있다. `const` 조인타입의 특별한 케이스이다.\r\n* const  \r\n테이블에 매칭되는 행이 최대 한개만 있으며, 이는 쿼리의 시작시 읽힌다. 오직 한개의 행만 있기 때문인데, 이 행의 열에 있는 값은 옵티마이저의 나머지 부분에서 상수로 간주될 수 있다. `const` 테이블은 한번만 읽히므로 매우빠르다.\r\n`const` 는`UNIQUE` 인덱스나 `PRIMARY KEY` 의 모든 부분을 상수값과 비교할때 시용된다.  다음 쿼리는  *tbl_name*이 상수 테이블로 사용될 수 있다.\r\n```sql\r\nSELECT * FROM tbl_name WHERE primary_key = 1;\r\n  \r\nSELECT * FROM tbl_name\r\n    WHERE primary_key_part1 = 1 AND primary_key_part2 = 2;\r\n```\r\n\r\n* eq_ref  \r\n이전 테이블에서 각 행 조합마다 이 테이블에서 한 행씩 읽는다. `system`과 `const` 타입을 제외하면 이게 제일 나은 조인타입이다.  조인에서 인덱스의 모든 부분을 사용하고,  인덱스가 `PRIMARY` 또는 `UNIQUE NOT NULL` 인덱스인 경우에 사용된다.\r\n`eq_ref`는 `=` 연산자를 사용하여 비교된 컬럼  인덱스에 사용될 수있다. 비교값은 상수가 될수 있고, 이 테이블보다 먼저 읽은 테이블의 열을 사용하는 표현식이 될 수도 있다. 다음의 예제에서 MySQL 은 *ref_table*를 처리하기위해 `eq_ref` 조인을 사용 할 수 있다.\r\n```sql\r\nSELECT * FROM ref_table,other_table\r\n  WHERE ref_table.key_column = other_table.column; //표현식 비교\r\n  \r\nSELECT * FROM ref_table, other_table\r\n  WHERE ref_table.key_column_part1 = other_table.column\r\n  AND ref_table.key_column_part2 = 1; //상수비교\r\n```\r\n\r\n* ref  \r\n이전 테이블의 행조합마다 일치하는 인덱스 값이 있는 모든행이 이 테이블에서 읽혀진다. 키의 가장왼쪽 접두어만 조인에 사용되거나 키가 `PRIMARY KEY` 또는 `UNIQUE`인덱스(즉, 키 값을 기준으로 조인이 단일행을 선택할 수 없는 경우)가 아닌경우에 `ref`가 사용된다.\r\n사용된 키가 몇개의 행에만 일치하는경우, 좋은 조인 타입이다.\r\n`ref` 는 `<=>`또는 `=` 연산자를 사용하여 비교된 인덱스들에 대해 사용될 수 있다. 다음의 예제에서 MySQL은 *ref_table* 처리에 `ref` 조인을 사용할 수 있다.  \r\n```sql\r\nSELECT * FROM ref_table WHERE key_column = expr; //여기서 expr은 다른 테이블에 대한 조건 표현식을 의미한다.\r\n  \r\nSELECT * FROM ref_table, other_table\r\n  WHERE ref_table.key_column = other_table.column;\r\n  \r\nSELECT * FROM ref_table,other_table\r\n  WHERE ref_table.key_column_part1 = other_table.column\r\n  AND ref_table.key_column_part2 = 1;\r\n```\r\n* fulltext  \r\n`FULLTEXT` 인덱스를 사용하여 수행된 조인이다.\r\n\r\n* ref_or_null  \r\n이 조인 타입은 `ref` 와 유사하지만, MySQL이 `NULL` 값을 포함하는 행들에 대해 추가 검색 수행한다는 점이 다르다. 이 조인 타입 최적화는 서브쿼리를 해결하는데 가장 자주 사용된다. 다음의 예제에서 MySQL은 *ref_table*을 처리에 `ref_or_null` 조인을 사용할 수 있다.\r\n```sql\r\nSELECT * FROM ref_table\r\n  WHERE key_column = expr OR key_column IS NULL;\r\n```\r\n* index_merge  \r\n이 조인 타입은 인덱스 병합 최적화가 사용되었다는 것을 나타 낸다. 이 경우, 출력행의 `key` 컬럼은 사용된 인덱스들의 목록을 포함하며  `key_len` 은 사용된 인덱스에 대한 가장긴 키부분 목록을 포함한다.\r\n\r\n* unique_subquery  \r\n이 타입은 다음 형식의 `IN` 서브쿼리이 대한 `eq_ref`를 대체한다.\r\n```sql\r\nvalue IN (SELECT primary_key FROM single_table WHERE some_expr)\r\n```\r\n`unique_subquery`는 완전히 더나은 효율성을 위해 서브쿼리를 완전히 대체하는 인덱스 조회 함수일 뿐이다.\r\n\r\n* index_subquery  \r\n이 조인 타입은 `unique_subquery`와 비슷하다. `IN` 서브쿼리를 대체하지만, 다음의 형식의 서브쿼리에서 유니크가 아닌 인덱스에 대해 동작한다.\r\n```sql\r\nvalue IN (SELECT key_column FROM single_table WHERE some_expr)\r\n```\r\n\r\n* range  \r\n주어진 범위에 있는 행들만 조회되며, 행 선택에 인덱스를 사용한다. 출력 행의 `key` 컬럼은 해당 인덱스가 사용됨을 나타낸다. `key_len` 컬럼은 사용된 가장긴 키부분을 포함한다. `ref`컬럼은 이 타입에대해 `NULL` 이다.\r\n`range`는 `key`컬럼이  `=, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, LIKE` 또는  `IN()` 연산자를 사용하여 비교되는 상수일 때 사용된다.\r\n\r\n```sql\r\nSELECT * FROM tbl_name\r\n  WHERE key_column = 10;\r\n  \r\nSELECT * FROM tbl_name\r\n  WHERE key_column BETWEEN 10 and 20;\r\n  \r\nSELECT * FROM tbl_name\r\n  WHERE key_column IN (10, 20, 30);\r\n  \r\nSELECT * FROM tbl_name\r\n  WHERE key_part1 = 10 AND key_part2 IN (10, 20, 30);\r\n```\r\n\r\n* index   \r\n`index` 조인 타입은 인덱스 트리 스캔 빼고 `ALL` 하고 같으며, 두가지 상황에서 발생한다.\r\n* 인덱스가 쿼리에 대한 커버링 인덱스 이고,  테이블에서 필요한 모든 데이터를 충족하는 데 사용할 수 있는 경우 인덱스 트리만 스캔된다. 이 경우 `Extra` 컬럼은 `Using Index`라고 나온다. 보통 인덱스 전용 스캔은 일반적으로 인덱스 사이즈가 테이블 데이터보다 작기떄문에, `ALL`보다 빠르다.\r\n* 풀 스캔은 인덱스에서 읽어서 인덱스 순서대로 데이터 행을 조회하여 수행된다.  `Extra` 컬럼이 에는 인덱스 사용이 나오지 않는다.\r\nMySQL은 쿼리가 단일인덱스의 일부인 컬럼만 사용하는 경우, 이 조인타입을 사용할 수있다.\r\n\r\n* ALL  \r\n풀스캔은 이전 테이블의 행 조합 마다 수행된다. 테이블이 `const`로 표시되지않은 첫번째 테이블인 경우 일반적으로 좋지 않으며, 다른 모든 경우에는 *매우* 나쁘다. 보통은, 이전테이블의 상수값 이나 컬럼값을 기준으로 테이블에서 행을 검색할 수있는 인덱스를 추가하면 `ALL` 타입을 피할 수 있다.\r\n\r\n### possible_keys (사용가능한 인덱스)::possible-keys\r\n(JSON: possible_keys)    \r\n`possible_keys` 컬럼은 MySQL이 이 테이블에서 행을 찾기위해 선택할 수 있는 인덱스들을 나타낸다. 참고로 이 컬럼은 `EXPLAIN`의 출력에 표시된 테이블들의 순서와 별개입니다. 이 말은 테이블 순서 생성된 실행에서  `possible_keys`에 어떤 키들은 사용될수 없을 수도 있다는 의미이다.\r\n이 컬럼이 `NULL`이라면, 적절한 인덱스가 없다는 뜻이다. 이 경우 인덱싱에 적합한 컬럼을 참조하는지 확인하기위해 `WHERE` 절을 검사사여 쿼리의 성능을 개선할 수 있다. 적절한 인덱스를 생성하고 `EXPLAIN` 쿼리를 확인해보자.\r\nSHOW INDEX FROM  *table_name* 으로 테이블 인덱스를 볼수 있다.\r\n\r\n### key (사용할 인덱스)::key\r\n(JSON: key)  \r\n`key`  컬럼은 MySQL이 사용하기로 정한 키(인덱스)를 나타냅니다. MySQL이 행조회에 `possible_keys` 인덱스들중 중 한개를 사용하기로 정했다면, 인덱스는 키값으로 나열된다.\r\n`key` 는 `possible_keys` 값에 없는 인덱스를 지정할 수도 있다.  이는 `possible_keys` 인덱스중 어느행도 조회되는데 적합하지 않지만, 쿼리의 선택된 모든 컬럼이 다른 인덱스의 컬럼인경우 발생할 수 있다. 즉, 지정된 인덱스가 선택된 컬럼들을 포함하고 있기때문에, 어느행을 검색할지를 결정하는 데는 사용되지 않더라도 인덱스 스캔은 데이터 행 스캔보다 효율적이다. (*이 내용은 \"커버링 인덱스\"의 효율성에 대한 내용이다.*)\r\n`InnoDB`의 경우 쿼리에서 기본키를 선택하더라도 보조 인덱스가 선택한 열을 포함할 수 있다. 이는 `InnoDB`가 각 보조인덱스에 기본 키 값을 저장하기 때문이다. `key`컬럼이 `NULL`이라면, `MySQL`은 쿼리를 보다 효율적으로 실행하는데 사용할 인덱스를 찾지 못한다.\r\n\r\n`MySQL`이 `possible_keys` 컬럼 내 있는 인덱스를 강제로 사용하거나 무시하게 하려면, 쿼리에서 `FORCE_INDEX`, `USE_INDEX` 또는 `IGNORE_INDEX`를 사용하면 된다.\r\n\r\n### key_len (키의 길이)::key-len\r\n(JSON: key_length)    \r\n`key_len` 컬럼은 `MySQL`이 사용하기로 결정한 키의 길이를 나타낸다. `key_len`의 값은 MySQL이 실제로 사용하는 복합키의 일부가 얼마나 되는지 확인 할수 있게 해준다. \r\n실제 표시되는 값은 사용된 키의 바이트 길이를 나타내여 사용하는 유니코드마다 다를수 있다. (*실제로 사용하는 복합키의 일부의 의미는 쿼리에 따라 첫번째 컬럼만 사용할 수도 있고, 두번째 컬럼까지 사용할 수 있다는 의미이다.*)\r\n키 저장 포맷으로 인해, `NULL`이 될수 있는 컬럼의 키 길이는 `NOT NULL`인 컬럼의 길이보다 1이 크다. (*NULL을 구분할 비트가 추가되기 때문에*)\r\n\r\n### ref (참조 값)::ref\r\n(JSON: ref)\r\n`ref`컬럼은 테이블에서 `key` 컬럼 내 어떤 컬럼이나 제약이 지정된 인덱스와 비교되었는지 보여줍니다.\r\n값이 `func`라면, 사용된 값은 어떤 함수의 결과입니다. 어떤 함수인지 확인하려면, 확장된 `EXPLAIN`결과를 보기위해 `EXPLAIN`뒤에 `SHOW WARNINGS`를 사용하면 된다. \r\n함수는 실제로 산술 연산자 같은 연산자 일 수 있다.\r\n\r\n### rows (검사 행 개수)::rows\r\n(JSON: rows)    \r\n`rows`  컬럼은 `MySQL`이 쿼리 실행 검사를 해야만 한다고 여기는 행들의 개수를 나타낸다. `InnoDB` 테이블의 경우, 이 값은 예측치이며, 항상 정확하지 않을 수도 있다.\r\n\r\n### filtered (필터된 수치)::filtered\r\n(JSON: filtered)\r\n`filtered` 컬럼은 테이블 조건으로 필터된 테이블 행들의 예상 백분률을 나타낸다. \r\n최대 값은 100이며, 이는 행의 필터링이 발생되지않음을 의미한다. 100에서 감소된 값은 필터링 양이 증가함을 나타낸다. \r\n`rows` 는 검된 행의 예상치를 보여주고`rows` × `filtered`는 다음 테이블로 조인된 행의 갯수를 보여준다. 예를들어, `rows`가 1000이고 `filtered`가 50.00(50%)라면, 다음 테이블로 조인된 행의 개수는 1000 × 50% = 500이다.\r\n\r\n### Extra (추가적인 내용)::extra\r\n(JSON: 없음)\r\n이컬럼은  `MySQL`이 쿼리를 어떻게 해결하는지에 대한 추가적인 정보를 포함한다. 다른 값의 설명들은 `EXPLAIN` [Extra 정보]()을 보자.\r\n\r\n`Extra`컬럼에 해당하는 단일 JSON 속성 값은 따로 없지만, 이 컬럼 내에서 발생될수 있는 값들은 JSON 속성이나 `message` 속성의 텍스트로 노출된다.\r\n쿼리를 빠르게 만들고 싶다면, `Using filesort`와 `Using temporary`의 `Extra` 컬럼값을 조심하자. JSON 형식에서는 `using_filesort`와 `using_temporary_table` 값이 `true`와 같다.\r\n\r\n* Zero limit  \r\n쿼리에 `LIMIT 0`절이있고 어떤 행도 선택할 수 없는 경우이다.\r\n\r\n* Using Where with pushed condition  \r\n이 항목은 [NDB]() 테이블들에만 적용된다.\r\n\r\n* Using Where  \r\n`WHERE`절은 다음 테이블과 일치시킬 행이나 클라이언트에 보내낼 행을 제한하는데 사용된다.  \r\n특별하게 테이블의 모든행을 가져오길 의도하거나 검사하려 하지 않는한, `Extra` 값이 `Using Where`이 아니고 테이블 조인 타입이 `ALL` 또는 `index`라면, 쿼리에 문제가 있을수 있다.  \r\n\r\n`Using Where`은 직접적으로 대응되는 JSON 속성이 없고 `attached_condition` 속성은 사용되는 모든 `WHERE` 조건을 포함한다.\r\n\r\n* Using temporary  \r\n쿼리를 해결하기위해 `MySQL`은 결과를 보관하기위해 임시테이블을 생성할 필요가 있다. 이는 일반적으로 쿼리가 컬럼을 다르게 나열하는 `GROUP BY`와 `ORDER BY`절을 포함하면 발생한다.  \r\n\r\n* Using sort_union(...), Using union(...), Using intersect(...)  \r\n이런것들은 `index_merge` 조인타입에 대한 인덱스 스캔이 어떻게 병합되는지를 보여주는 특별한 알고리즘을 나타낸다.\r\n\r\n* Using MRR  \r\n테이블은 다중범위 읽기 최적화 전략을 사용하여 읽힌다.  \r\n\r\n* Using join buffer (Block Nested Loop), Using join buffer (Batched Key Access), Using join buffer (hash join)  \r\n이전 조인의 테이블은 조인버퍼로 부분적으로 읽히고, 그 행들은 버퍼에서 현재 테이블과 조인을 수행하는데 사용된다. \r\n(Block Nested Loop)는 Block Nested-Loop 알고리즘 사용을 나타내고,(Batched Key Access)는 Batched Key Access 알고리즘 사용을 나타내며 (hash join)은 해시조인 사용을 나타낸다.\r\n즉 `EXPLAIN` 출력의 이전라인에 있는 테이블의 키가 버퍼에 저장되고, 일치하는 행은 `Using join buffter`가 나타나는 줄로 보여진 테이블에서 일괄적으로 가져온다.\r\n\r\n* Using index for skip scan  \r\n스캔 스킵에대한 인덱스를 나타낸다.\r\n\r\n* using index for group-by  \r\n`Using index` 테이블 접근 방법과 유사하며, `Using index for group-by`sms `MySQL`이 실제테이블에 추가적인 어떤 디스크 접근도 없이 `GROUP BY` 또는 `DISTINT` 쿼리의 모든 컬럼을 검색하는데 사용할수 있는 인덱스를 찾았다는 것을 나타낸다.\r\n게다가, 각 그룹에대해 몇개의 인덱스 항목만 읽도록하는 가장 효융적인 방식으로 인덱스가 사용된다.\r\n\r\n* Using index condition  \r\n테이블은 인덱스 튜블을 접근하여 읽고 전체 테이블 행을 읽을것인지 결정하기위해 먼저 테스트한다. 이 방법의 경우, 인덱스 정보는 필수가 아닌한 전체 테이블 행을 읽는것을 연기(\"푸시다운\")하는 데 사용된다.\r\n\r\n* Using index  \r\n실제 행을 읽기위한 추가적인 탐색 없이 인덱스트리에서 정보만을 사용하여 테이블에서 컬럼 정보를 가져온다. 이 전략은 단일 인덱스의 부분인 컬럼만 사용하는 쿼리일때 사용될 수 있다.\r\nInnoDB에서 사용자정의 클러스터드 인덱스(기본키)를 가진 테이블인 경우, `Extra` 컬럼에 `Using index`가 없더라도 해당 인덱스가 사용될 수 있다. 이는 `type`이 인덱스와 `key`가 `PRIMARY`인 경우에 해당한다.\r\n사용된 커버링 인덱스에 대한 정보는 `EXPLAIN FORMAT=TRADITIONAL`과 `EXPLAIN FORMAT=JSON`에 대해 보여진다.\r\n\r\n* Using filesort  \r\n`MySQL`은 정렬된 순서로 행을 검색하는 방법을 찾기위해 한번 더 데이터를 훑어야 한다.\r\n정렬은 조인타입에 따라 모든 행을 검토하면서 `WHERE`절과 일치하는 모든 행에 대해 행을 가리키는 포인터와 정렬키를 저장하는 방식으로 수행된 다음 키들이 정렬되고 정렬된 순서로 행들을 가져온다.\r\n"
  },
  {
    "path": "/docs/back-end/spring/transaction-manager",
    "header": {
      "layout": "post",
      "title": "스프링의 트랜잭션 관리자",
      "tags": [
        "Spring",
        "Spring Boot",
        "Transaction",
        "Transaction Manager"
      ],
      "date": 1717495080000,
      "thumbnail": "/post/back-end/spring/spring-transaction-manager.svg",
      "current-company": "NEOWIZ",
      "current-position": "Software Engineer",
      "summary": "트랜잭션 관리자",
      "excerpt_separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "서버/백엔드",
        "스프링"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "트랜잭션 관리자",
            "title": "트랜잭션 관리자",
            "fragment": "root-0",
            "children": [
              {
                "rank": 3,
                "origin": "설명",
                "title": "설명",
                "fragment": "root-0-0",
                "children": []
              },
              {
                "rank": 3,
                "origin": "필드",
                "title": "필드",
                "fragment": "root-0-1",
                "children": []
              }
            ]
          },
          {
            "rank": 2,
            "origin": "설정기능",
            "title": "설정기능",
            "fragment": "root-1",
            "children": [
              {
                "rank": 3,
                "origin": "final setTransactionSynchronizationName(String constantName)",
                "title": "final setTransactionSynchronizationName(String constantName)",
                "fragment": "root-1-0",
                "children": []
              },
              {
                "rank": 3,
                "origin": "final setTransactionSynchronization( int transactionSynchronization)",
                "title": "final setTransactionSynchronization( int transactionSynchronization)",
                "fragment": "root-1-1",
                "children": []
              },
              {
                "rank": 3,
                "origin": "final setDefaultTimeout(int defaultTimeout)",
                "title": "final setDefaultTimeout(int defaultTimeout)",
                "fragment": "root-1-2",
                "children": []
              },
              {
                "rank": 3,
                "origin": "final setNestedTransactionAllowed(boolean nestedTransactionAllowed)",
                "title": "final setNestedTransactionAllowed(boolean nestedTransactionAllowed)",
                "fragment": "root-1-3",
                "children": []
              },
              {
                "rank": 3,
                "origin": "final setValidateExistingTransaction(boolean validateExistingTransaction)",
                "title": "final setValidateExistingTransaction(boolean validateExistingTransaction)",
                "fragment": "root-1-4",
                "children": []
              },
              {
                "rank": 3,
                "origin": "final setGlobalRollbackOnParticipationFailure(boolean gloabalRollbackOnParticipationFailure)",
                "title": "final setGlobalRollbackOnParticipationFailure(boolean gloabalRollbackOnParticipationFailure)",
                "fragment": "root-1-5",
                "children": []
              },
              {
                "rank": 3,
                "origin": "final setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly)",
                "title": "final setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly)",
                "fragment": "root-1-6",
                "children": []
              },
              {
                "rank": 3,
                "origin": "final setRollbackOnCommitFailure(boolean rollbackOnCommitFailure)",
                "title": "final setRollbackOnCommitFailure(boolean rollbackOnCommitFailure)",
                "fragment": "root-1-7",
                "children": []
              }
            ]
          },
          {
            "rank": 2,
            "origin": "PlatformTransactionManager 구현체",
            "title": "PlatformTransactionManager 구현체",
            "fragment": "root-2",
            "children": [
              {
                "rank": 3,
                "origin": "final getTransaction(TransactionDefinition definition)",
                "title": "final getTransaction(TransactionDefinition definition)",
                "fragment": "root-2-0",
                "children": []
              },
              {
                "rank": 3,
                "origin": "doGetTransaction",
                "title": "doGetTransaction",
                "fragment": "root-2-1",
                "children": []
              },
              {
                "rank": 3,
                "origin": "handleExistingTransaction",
                "title": "handleExistingTransaction",
                "fragment": "root-2-2",
                "children": []
              },
              {
                "rank": 3,
                "origin": "doBegin",
                "title": "doBegin",
                "fragment": "root-2-3",
                "children": []
              },
              {
                "rank": 3,
                "origin": "final commit(TransactionStatus status)",
                "title": "final commit(TransactionStatus status)",
                "fragment": "root-2-4",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "트랜잭션 관리자의 공통 처리사항을 알아보자",
    "content": "\r\n\r\n## 트랜잭션 관리자\r\n\r\n스프링은 트랜잭션 관리자를 추상화하여, 다양한 데이터 핸들링 프레임워크를 유연하게 사용할 수 있다.\r\n`@Transactional` 어노테이션을 사용하더라도, 데이터 핸들링 프레임워크 (JPA, JDBC, Hibernate 등)에 따라 다르게 동작한다.\r\n\r\n🔷 트랜잭션 관리자의 구현 목록:\r\n\r\n- DataSourceTransactionManager\r\n- HibernateTransactionManager\r\n- JdbcTransactionManager\r\n- JpaTransactionManager\r\n- JtaTransactionManager\r\n- KafkaTransactionManager\r\n- ResourcelessTransactionManager\r\n\r\n### 설명\r\n`org.springframework.transaction.jta.JtaTransactionManager` 같이 실제 플랫폼 트랜잭션매니저의 기반으로 사용되는 Spring의 표준 트랜잭션 작업흐름 구현체, 추상 기본  클래스이다.\r\n\r\n이 기본 클래스는 다음의  작업흐름을 처리를 제공한다.\r\n\r\n* 트랜잭션이 있는지 판단\r\n* 적절한 전파 동작을 적용\r\n* 필요하다면 트랜잭션을 중단하고 재개\r\n* 커밋 시 rollback-only 표시를 확인\r\n* 롤백 시 적절한 수정 사항을 적용 (실제 롤백 또는  rollback-only를 설정해서)\r\n* 등록된 동기화 콜백을 트리거 (트랜잭션 동기화가 활성화 된 경우)\r\n\r\n하위클래스는 트랜잭션의 특정 상태에대한 특정 템플릿 메서드를 구현해야 함 (예:  중단, 재개, 커밋, 롤백전). 가장중요한 건 추상화와 실제 구현체로 제공되어야만 하는것이고, 그외에는 기본값이 제공되므로 `overriding` 선택사항.  \r\n\r\n트랜잭션 동기화는 트랜잭션 완료시간에 호출되는 콜백을 등록하기위한 일반적인 메커니즘. 이것은 JTA 트랜잭션 내에서 동작할때 JDBC, 하이버네이트, JPA 등등에 대한 데이터 접근클래스로부터 내부적으로 사용. (트랜잭션 완료 시간에 닫히기 위해 트랜잭션 내에서 개방된 리소스를 등록. 예 : 트랜잭션 내 동일한 하이버네이트 세션의 재사용을 위해 )  \r\n\r\n이 클래스의 상태는 직렬화 가능하여  트랜잭션 인터셉터를 전달하는 프록시와 마찬가지로 트랜잭션 전략를 직렬화 가능. 이것은 하위클래스에 달려있는데, 상태를 직렬화 되게 만들고 싶다면 진행. 이 경우에 하위클래스는 마커 인터페이스인 `java.io.Seializable` 를 구현해야하며 일시적인 상태를 복원해야하는경우 잠재적으로 `private` readObject()  메소드 (자바 직렬화 규칙에따라 )를 구현해야함.  \r\n\r\n\r\n### 필드\r\n\r\n* SYNCHRONIZATION_ALWAYS = 0;\r\n    * 트랜잭션 동기화를 항상 활성화며 기존 백엔드 트랜잭션이 없는 PROPAGATION_SUPPORTS인 \"비어있는\" 트랜잭션 까지도 적용.\r\n\r\n* SYNCHRONIZATION_ON_ACTUAL_TRANSACTION = 1;\r\n    * 실제 트랜잭션을 위해서만 트랜잭션 동기화를 활성화 하며, 기존 백엔드 트랜잭션이 없는  PROPAGATION_SUPPORTS 인 비어있는 트랜잭션에는 적용되지 않음.\r\n\r\n* SYNCHRONIZATION_NEVER = 2;\r\n    * 실제 트랜잭션까지도 트랜잭션동기화를 활성화하지 않음.\r\n\r\n## 설정기능\r\n`AbstactPlatformTransactionManager`는 트랜잭션 동기화를 등록하고 관리할 수 있음.\r\n\r\n### final setTransactionSynchronizationName(String constantName)\r\n\r\n* 이 클래스의 해당 상수명으로 트랜잭션 동기화를 설정.\r\n\r\n\r\n\r\n### final setTransactionSynchronization( int transactionSynchronization)\r\n\r\n* 이 트랜잭션 매니저가 Thread-bound 트랜잭션 동기화 지원을 활성화 해야만 할때 설정함. 기본값은 `SYNCHRONIZATION_ALWAYS`.\r\n* 참고로 트랜잭션 동기화는 다른 트랜잭션 매니저에 의해 다중 동시 트랜잭션을 지원하지 않음. 한개의 트랜잭션 매니저만이 이것을 언제든지 허용할 수 있음.\r\n\r\n\r\n### final setDefaultTimeout(int defaultTimeout)\r\n\r\n* 트랜잭션 레벨에 초단위로 명시된 타임아웃이 없는경우 이 트랜잭션 매니저가 적용해야만하는 기본 타임아웃을 명시.\r\n* 기본값은 근본적인 트랜잭션 인프라 기본 타임아웃(예: 일반적으로, JTA Provider 의 경우 30초)이며, TransactionDefinition.TIMEOUT_DEFAULT 값으로 나타남.\r\n\r\n\r\n\r\n### final setNestedTransactionAllowed(boolean nestedTransactionAllowed)\r\n\r\n* 기본값은 \"false\"이며, 중복 트랜잭을 허용할지 설정.\r\n* 일반적으로 구체적인 트랜잭션 매니저 하위클래스에 의해 적절한 기본값으로 초기화 됨.\r\n\r\n\r\n### final setValidateExistingTransaction(boolean validateExistingTransaction)\r\n\r\n* 기존 트랜잭션에 참여하기 전에 검증돼야 하는지 설정.\r\n* 기존 트랜잭션(예: PROPAGATION_REQUIRED 또는 PROPAGATION_SUPPORT가 기존 트랜잭션을 만나는 경우)에 참여할때, 이 외부 트랜잭션의 형질은 내부 트랜잭션영역에 까지도 적용.\r\n* 유효성 검사는 내부 트랜잭션 정의에서 호환되지 않는 고립레벨 및 읽기전용 설정을 감지하고 해당 예외를 throw하여 이에따라 참여를 거부.\r\n* 기본값은 \"false\"이며, 내부 트랜잭션 설정을 느슨하게 무시하여, 외부 트랜잭션의 형질로 간단히 재정의.\r\n* \"true\" 플래그로 변경은 엄격한 유효성검사를 강제하도록 명령.\r\n\r\n\r\n### final setGlobalRollbackOnParticipationFailure(boolean gloabalRollbackOnParticipationFailure)\r\n\r\n* 참여하는 트랜잭션이 실패한후에 기존 트랜잭션을 `rollback-only`로 전역적으로 표시할지 설정.\r\n* 기본값은 \"true\"이며, 참여하는 트랜잭션(예: PROPAGATION_REQUIRED 또는 PROPAGATION_SUPPORT가 기존 트랜잭션을 만나는 경우)이 실패한다면, 트랜잭션은 `rollback-only`로 전역적으로 마킹. *이런 트랜잭션에 오직 가능한 결과는 롤백.*  \r\n* “false”로 변경시: 트랜잭션 발신자가 롤백 결정을 내림. 만약 참여하는 트랜잭션이 예외로 실패한다면, 호출자는 트랜잭션 내 다른경로로 계속하기로 결정할 수 있음. 하지만, 이는 모든 참여 자원이 데이터 액세스 실패 후에도 트랜잭션 커밋을 향해 계속할 수 있는 경우에만 작동. (일반적으로 Hibernate 세션은 해당되지 않는 경우임. 예: JDBC insert/update/delete 동작들의 sequence)  \r\n* **참고:** 이 플래그는 일반적으로 데이터 접근 작업(TransactionInterceptor가 롤백룰에 따라 PlatformTransactionManager.rollback() 호출을 트리거하는 경우)으로 인해 throw 된 예외가 발생한 하위 트랜잭션에 대한 명시적 롤백시도에만 적용. 플래그가 비활성화라면 호출자는 하위 트랜잭션의 롤백룰과 관계없이 예외를 처리하고 롤백을 결정할 수 있음. 그러나 이 플래그는 하위트랜잭션에 명시적 `setRollbackOnly` 호출을 적용하지 않으므로,이는  항상 최종적인 글로벌 롤백(`rollback-only` 호출후 예외가 발생하지 않을 수 있기 때문에 )을 유발.\r\n* 하위트랜잭션의 실패처리에 대한 추천드리는 방법은 글로벌 트랜잭션이 하위트랜잭션의 시작시 가져온 세이브포인트로 롤백될 수 있도록 하는 “중복 트랜잭션” 임. `PROPAGATION_NESTED`는 정확히 이러한 의미를 제공함. 그러나, 중복 트랜잭션 지원이 가능할 때만 동작함. `DataSource TransactionManager` 경우지만, `JtaTransactionManager`의 경우는 아님.\r\n\r\n\r\n### final setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly)\r\n* 트랜잭션이 `rollback-only`로 전역적으로 표시된 경우에 조기 실패할 것 인지 설정.\r\n* 기본값은 “false” 이며, 가장 바깥쪽의 트랜잭션 바운더리에서만 `UnexpectedRollbackExcetpion`을 발생시킴. 내부 트랜잭션 바운더리 내에서 전역 rollback-only 마커가 처음 감지하여 즉시 `UnexpectedRollbackException`을 발생시키려면 이 값을 변경해야함.\r\n* 참고로 스프링 2.0부터 전역  rollback-only 표시자에 대한 조기실패 동작이 통합 됨. (모든 트랜잭션 매니져는 기본적으로 가장 바깥쪽의 트랜잭션 바운더리에서만 `UnexpectedRollbackException`을 발생시킴.) 이 허용 예를들어 동작이 실패하고 트랜잭션이 완료되지 않은 후에도 유닛 테스트를 계속할 수 있음. 모든 트랜잭션 매니저는 이 플래그가 명시적으로 \"true\"로 설정됐을 때만 조기실패 시킴.\r\n\r\n### final setRollbackOnCommitFailure(boolean rollbackOnCommitFailure)\r\n*  `doCommit`메소드 호출의 실패에 `doRollback`이 수행 해야만하는지 설정함. 일반적으로 필요하지 않고 후속 롤백 예외로 커밋 예외를 무시할 가능성이 있으며, 따라서 피해야함.\r\n\r\n## PlatformTransactionManager 구현체\r\n\r\n\r\n### final getTransaction(TransactionDefinition definition)\r\n\r\n```java\r\n@Override\r\n\tpublic final TransactionStatus getTransaction(@Nullable TransactionDefinition definition)\r\n\t\t\tthrows TransactionException {\r\n\r\n\t\t// Use defaults if no transaction definition given.\r\n\t\tTransactionDefinition def = (definition != null ? definition : TransactionDefinition.withDefaults());\r\n\r\n\t\tObject transaction = doGetTransaction();\r\n\t\tboolean debugEnabled = logger.isDebugEnabled();\r\n\r\n\t\tif (isExistingTransaction(transaction)) {\r\n\t\t\t// Existing transaction found -> check propagation behavior to find out how to behave.\r\n\t\t\treturn handleExistingTransaction(def, transaction, debugEnabled);\r\n\t\t}\r\n\r\n\t\t// Check definition settings for new transaction.\r\n\t\tif (def.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {\r\n\t\t\tthrow new InvalidTimeoutException(\"Invalid transaction timeout\", def.getTimeout());\r\n\t\t}\r\n\r\n\t\t// No existing transaction found -> check propagation behavior to find out how to proceed.\r\n\t\tif (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {\r\n\t\t\tthrow new IllegalTransactionStateException(\r\n\t\t\t\t\t\"No existing transaction found for transaction marked with propagation 'mandatory'\");\r\n\t\t}\r\n\t\telse if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||\r\n\t\t\t\tdef.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||\r\n\t\t\t\tdef.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {\r\n\t\t\tSuspendedResourcesHolder suspendedResources = suspend(null);\r\n\t\t\tif (debugEnabled) {\r\n\t\t\t\tlogger.debug(\"Creating new transaction with name [\" + def.getName() + \"]: \" + def);\r\n\t\t\t}\r\n\t\t\ttry {\r\n\t\t\t\treturn startTransaction(def, transaction, debugEnabled, suspendedResources);\r\n\t\t\t}\r\n\t\t\tcatch (RuntimeException | Error ex) {\r\n\t\t\t\tresume(null, suspendedResources);\r\n\t\t\t\tthrow ex;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Create \"empty\" transaction: no actual transaction, but potentially synchronization.\r\n\t\t\tif (def.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT && logger.isWarnEnabled()) {\r\n\t\t\t\tlogger.warn(\"Custom isolation level specified but no actual transaction initiated; \" +\r\n\t\t\t\t\t\t\"isolation level will effectively be ignored: \" + def);\r\n\t\t\t}\r\n\t\t\tboolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);\r\n\t\t\treturn prepareTransactionStatus(def, null, true, newSynchronization, debugEnabled, null);\r\n\t\t}\r\n\t}\r\n```\r\n\r\n이 구현체는 전파동작을 처리함. doGetTransaction, isExistingTransaction 및 doBegin 메서드를 위임함.\r\n설정된 값을 먼저확인하고 없다면 기본값으로 세팅하  트랜잭션을 가져옴. 제일먼저 `TransactionDefinition` 기본값 세팅 후 `doGetTransaction`으로 트랜잭션을 불러옴.\r\n이 메서드에서는 먼저 살펴봐야할 메서드가 3가지정도로 나눌수 있음. `doGetTransaction`, `handleExistingTransaction`, `doBegin`을 보며 유추함.\r\n\r\n\r\n### doGetTransaction\r\n\r\n* 현재 트랜잭션 상태에대한 트랜잭션 객체를 리턴하는 메서드임.\r\n* 반환된 객체는 일반적으로 변경할수 있는 방식에 해당하는 트랜잭션을 전달하여 구체적인 트랜잭션 매니저 구현체에 명시됨.\r\n\r\n\r\n이 메서드는 추상화되어있고 각 구현체인 Transaction Manager들에 의하여 구현되있음. 일반적으로 `JDBC`를 사용하는 `DataSourceTransactionManager`를 예:\r\n\r\n```java\r\n@Override\r\nprotected Object doGetTransaction() {\r\n  DataSourceTransactionObject txObject = new DataSourceTransactionObject();\r\n  txObject.setSavepointAllowed(isNestedTransactionAllowed());\r\n  ConnectionHolder conHolder =\r\n      (ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource());\r\n  txObject.setConnectionHolder(conHolder, false);\r\n  return txObject;\r\n}\r\n```\r\n`line 4`에서 세이브포인트를 이 트랜잭션내에서 허용될 것인지를 정하고 매개변수로 중첩트랜잭션의 허용 여부을 보냄. `line 5`에 `ConnnectionHolder`가 컨넥션 및 세이브 포인트를 생성함. 아래 코드를 보시면 세이브포인트의 네이밍을 확인할 수 있음.\r\n\r\n```java\r\npublic Savepoint createSavepoint() throws SQLException {\r\n\t\tthis.savepointCounter++;\r\n\t\treturn getConnection().setSavepoint(SAVEPOINT_NAME_PREFIX + this.savepointCounter);\r\n\t}\r\n```\r\n트랜잭션 내에서 `SAVEPOINT_0`, `SAVEPOINT_1` .. 이런식으로 생성되면서 갯수를 체크함. `ConnectionHolder`는 현재 설정된 DataSource로 `Connnection`을 생성하여 할당. 결과적으로 세이브포인트 사용 여부와 컨넥션을 가지고 트랜잭션 객체를 반환함.\r\n\r\n### handleExistingTransaction\r\n트랜잭션이 존재하는지 확인하고 존재한다면 `handleExistingTransaction`으로 보내버림.\r\n\r\n```java\r\nprivate TransactionStatus handleExistingTransaction(\r\n\t\t\tTransactionDefinition definition, Object transaction, boolean debugEnabled)\r\n\t\t\tthrows TransactionException {\r\n\r\n\t\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {\r\n\t\t\tthrow new IllegalTransactionStateException(\r\n\t\t\t\t\t\"Existing transaction found for transaction marked with propagation 'never'\");\r\n\t\t}\r\n\r\n\t\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {\r\n\t\t\tif (debugEnabled) {\r\n\t\t\t\tlogger.debug(\"Suspending current transaction\");\r\n\t\t\t}\r\n\t\t\tObject suspendedResources = suspend(transaction);\r\n\t\t\tboolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);\r\n\t\t\treturn prepareTransactionStatus(\r\n\t\t\t\t\tdefinition, null, false, newSynchronization, debugEnabled, suspendedResources);\r\n\t\t}\r\n\r\n\t\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {\r\n\t\t\tif (debugEnabled) {\r\n\t\t\t\tlogger.debug(\"Suspending current transaction, creating new transaction with name [\" +\r\n\t\t\t\t\t\tdefinition.getName() + \"]\");\r\n\t\t\t}\r\n\t\t\tSuspendedResourcesHolder suspendedResources = suspend(transaction);\r\n\t\t\ttry {\r\n\t\t\t\treturn startTransaction(definition, transaction, debugEnabled, suspendedResources);\r\n\t\t\t}\r\n\t\t\tcatch (RuntimeException | Error beginEx) {\r\n\t\t\t\tresumeAfterBeginException(transaction, suspendedResources, beginEx);\r\n\t\t\t\tthrow beginEx;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {\r\n\t\t\tif (!isNestedTransactionAllowed()) {\r\n\t\t\t\tthrow new NestedTransactionNotSupportedException(\r\n\t\t\t\t\t\t\"Transaction manager does not allow nested transactions by default - \" +\r\n\t\t\t\t\t\t\"specify 'nestedTransactionAllowed' property with value 'true'\");\r\n\t\t\t}\r\n\t\t\tif (debugEnabled) {\r\n\t\t\t\tlogger.debug(\"Creating nested transaction with name [\" + definition.getName() + \"]\");\r\n\t\t\t}\r\n\t\t\tif (useSavepointForNestedTransaction()) {\r\n\t\t\t\t// Create savepoint within existing Spring-managed transaction,\r\n\t\t\t\t// through the SavepointManager API implemented by TransactionStatus.\r\n\t\t\t\t// Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.\r\n\t\t\t\tDefaultTransactionStatus status =\r\n\t\t\t\t\t\tprepareTransactionStatus(definition, transaction, false, false, debugEnabled, null);\r\n\t\t\t\tstatus.createAndHoldSavepoint();\r\n\t\t\t\treturn status;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Nested transaction through nested begin and commit/rollback calls.\r\n\t\t\t\t// Usually only for JTA: Spring synchronization might get activated here\r\n\t\t\t\t// in case of a pre-existing JTA transaction.\r\n\t\t\t\treturn startTransaction(definition, transaction, debugEnabled, null);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED.\r\n\t\tif (debugEnabled) {\r\n\t\t\tlogger.debug(\"Participating in existing transaction\");\r\n\t\t}\r\n\t\tif (isValidateExistingTransaction()) {\r\n\t\t\tif (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {\r\n\t\t\t\tInteger currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();\r\n\t\t\t\tif (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {\r\n\t\t\t\t\tConstants isoConstants = DefaultTransactionDefinition.constants;\r\n\t\t\t\t\tthrow new IllegalTransactionStateException(\"Participating transaction with definition [\" +\r\n\t\t\t\t\t\t\tdefinition + \"] specifies isolation level which is incompatible with existing transaction: \" +\r\n\t\t\t\t\t\t\t(currentIsolationLevel != null ?\r\n\t\t\t\t\t\t\t\t\tisoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :\r\n\t\t\t\t\t\t\t\t\t\"(unknown)\"));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!definition.isReadOnly()) {\r\n\t\t\t\tif (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {\r\n\t\t\t\t\tthrow new IllegalTransactionStateException(\"Participating transaction with definition [\" +\r\n\t\t\t\t\t\t\tdefinition + \"] is not marked as read-only but existing transaction is\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tboolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);\r\n\t\treturn prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null);\r\n\t}\r\n```\r\n`PROPAGATION_NEVER`은 현재 트랜잭션이 존재한다면 바로 예외를 throwing 하고,  `PROPAGATION_NOT_SUPPORTED`는 현재 트랜잭션을 중지함.\r\n`PROPAGATION_REQUIRES_NEW`는 현재 진행중인 트랜잭션을 중단하고 새로운 커넥션으로 트랜잭션을 시작하기 때문에 `startTransaction()`로 보냄.\r\n이처럼 다는 설명하지 못하지만 각 전파옵션과 현재 진행중인 트랜잭션의 유무를 판단하여 트랜잭션(상태)를 리턴함.\r\n\r\n### doBegin\r\n\r\n```java\r\n@Override\r\nprotected void doBegin(Object transaction, TransactionDefinition definition) {\r\n  DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;\r\n  Connection con = null;\r\n\r\n  try {\r\n    if (!txObject.hasConnectionHolder() ||\r\n        txObject.getConnectionHolder().isSynchronizedWithTransaction()) {\r\n      Connection newCon = obtainDataSource().getConnection();\r\n      if (logger.isDebugEnabled()) {\r\n        logger.debug(\"Acquired Connection [\" + newCon + \"] for JDBC transaction\");\r\n      }\r\n      txObject.setConnectionHolder(new ConnectionHolder(newCon), true);\r\n    }\r\n\r\n    txObject.getConnectionHolder().setSynchronizedWithTransaction(true);\r\n    con = txObject.getConnectionHolder().getConnection();\r\n\r\n    Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);\r\n    txObject.setPreviousIsolationLevel(previousIsolationLevel);\r\n    txObject.setReadOnly(definition.isReadOnly());\r\n\r\n    // Switch to manual commit if necessary. This is very expensive in some JDBC drivers,\r\n    // so we don't want to do it unnecessarily (for example if we've explicitly\r\n    // configured the connection pool to set it already).\r\n    if (con.getAutoCommit()) {\r\n      txObject.setMustRestoreAutoCommit(true);\r\n      if (logger.isDebugEnabled()) {\r\n        logger.debug(\"Switching JDBC Connection [\" + con + \"] to manual commit\");\r\n      }\r\n      con.setAutoCommit(false);\r\n    }\r\n\r\n    prepareTransactionalConnection(con, definition);\r\n    txObject.getConnectionHolder().setTransactionActive(true);\r\n\r\n    int timeout = determineTimeout(definition);\r\n    if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {\r\n      txObject.getConnectionHolder().setTimeoutInSeconds(timeout);\r\n    }\r\n\r\n    // Bind the connection holder to the thread.\r\n    if (txObject.isNewConnectionHolder()) {\r\n      TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());\r\n    }\r\n  }\r\n\r\n  catch (Throwable ex) {\r\n    if (txObject.isNewConnectionHolder()) {\r\n      DataSourceUtils.releaseConnection(con, obtainDataSource());\r\n      txObject.setConnectionHolder(null, false);\r\n    }\r\n    throw new CannotCreateTransactionException(\"Could not open JDBC Connection for transaction\", ex);\r\n  }\r\n}\r\n```\r\n\r\n이 메서드는 주어진 트랜잭션 정의에따라 의미하  새로운 트랜잭션을 시작함. 이 추상 트랜잭션 매니저에의해 이미 처리되기 때문에 전파동작을 적용하는것에 대해 걱정할 필요없음.   \r\n이 메소드는 트랜잭션 매니저가 실제로 새로운 트랜잭션을 시작하기로 결정할때 호출함. 이전 트랜잭션이 없거나, 이전트랜잭션이 중단됐거나 둘중 하나임.\r\n\r\n특별한 경우는 세이브 포인트 없이 중첩된 트랜잭션임. `useSavepointForNestedTransaction()`이 \"false\"를 리턴 한다면, 이 메소드는 필요할때 중첩된 트랜잭션을 시작을 호출함. 그런 흐름에, 활성트랜잭션이 있음. (이 메소드의 구현체는 이를 감지하고 적절한 중첩 트랜잭션을 시작해야함).\r\n\r\n### final commit(TransactionStatus status)\r\n이 커밋 구현은 기존 트랜잭션 및 프로그래밍 방식 롤백 요청에 참여하는 것을 처리함. `isRollbackOnly`및 `doCommit`그리고 `rollback`에 위임함.\r\n\r\n```java\r\n@Override\r\n\tpublic final void commit(TransactionStatus status) throws TransactionException {\r\n\t\tif (status.isCompleted()) {\r\n\t\t\tthrow new IllegalTransactionStateException(\r\n\t\t\t\t\t\"Transaction is already completed - do not call commit or rollback more than once per transaction\");\r\n\t\t}\r\n\r\n\t\tDefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;\r\n\t\tif (defStatus.isLocalRollbackOnly()) {\r\n\t\t\tif (defStatus.isDebug()) {\r\n\t\t\t\tlogger.debug(\"Transactional code has requested rollback\");\r\n\t\t\t}\r\n\t\t\tprocessRollback(defStatus, false);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {\r\n\t\t\tif (defStatus.isDebug()) {\r\n\t\t\t\tlogger.debug(\"Global transaction is marked as rollback-only but transactional code requested commit\");\r\n\t\t\t}\r\n\t\t\tprocessRollback(defStatus, true);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tprocessCommit(defStatus);\r\n\t}\r\n```\r\n"
  },
  {
    "path": "/docs/computer-science/computer-structure/hard-disk-1",
    "header": {
      "layout": "post",
      "title": "HDD(Hard Drive Disk)는 어떻게 동작하는가",
      "tags": [
        "HDD",
        "Hard Drive Disk",
        "하드디스크",
        "Hardware",
        "하드웨어",
        "저장장치",
        "컴퓨터"
      ],
      "date": 1695125760000,
      "thumbnail": "/post/computer-science/hdd.png",
      "profile-image": "/post/profile/winkkom.png",
      "current-company": "NEOWIZ",
      "current-position": "Software Engineer",
      "summary": "하드디스크란 무엇이고, 어떻게 동작할까?",
      "excerpt-separator": "<!--more-->",
      "hide": true,
      "breadcrumbs": [
        "문서",
        "컴퓨터",
        "하드웨어"
      ],
      "images": [
        {
          "src": "/post/computer/hdd_consist_of.png",
          "alt": "하드디스크 구성요소의 설명"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "하드디스크의 구성",
            "title": "하드디스크의 구성",
            "fragment": "root-0",
            "children": [
              {
                "rank": 3,
                "origin": "Head",
                "title": "Head",
                "fragment": "root-0-0",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "대표적인 저장장치 하드디스크는 어떻게 동작할까?\r\n하드디스크의 구성과, 동작원리를 파해쳐보자.",
    "content": "\r\n\r\n## 하드디스크의 구성\r\n\r\n![하드디스크 구성요소의 설명](/post/computer/hdd_consist_of.png)\r\n\r\n먼저 하드디스크가 어떤 구성으로 이루어져있는지를 알기전에, 동작과정을 간단하게 살펴보자.\r\n고정되어있는 `Platter(플래터)`는 `Spindle(스핀들)`에 의해 돌아가며, 가깝게 붙어있는 `Head(헤드)`가 `플래터`의 저장된 값을 읽는다.\r\n\r\n### Head \r\n\r\n"
  },
  {
    "path": "/docs/electric/about-electron",
    "header": {
      "layout": "wiki",
      "title": "전기에너지를 만드는 전자",
      "tags": [
        "원자",
        "전자",
        "원자핵",
        "렙톤"
      ],
      "date": 1694348520000,
      "profile-image": "/post/profile/winkkom.png",
      "current-company": "NEOWIZ",
      "current-position": "Software Engineer",
      "summary": "전자란?",
      "excerpt-separator": "<!--more-->",
      "hide": true,
      "breadcrumbs": [
        "문서",
        "electric"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": []
      }
    },
    "description": "",
    "content": "\r\n전자는 대부분의 원자에 모두 존재한다.\r\n원자가 전기적으로 중성이려면, 음전하를 띄고 있는 전자와, 양전하를 띄고있는 양성자의 개수가 동일해야 한다.\r\n따라서, 자연에 존재하는 모든 원소는 전자를 갖고있다고 봐도 된다.\r\n\r\n전자는 양전하에서 음전하로 이동하게 되는데, 이를 이용해 전기 에너지를 흐르게 할 수 있다.\r\n`(+)양전하` 에서 `(-)음전하`의 방향으로 전자가 이동하게 되면, 그 반대방향으로 전기장이 만들어진다.\r\n전기에너지는 그 전기장을 통에 전달이 된다.  \r\n\r\n<!--more-->\r\n"
  },
  {
    "path": "/docs/electric/about-atom",
    "header": {
      "layout": "wiki",
      "title": "만물을 이루는 원자",
      "tags": [
        "원자",
        "전자",
        "원자핵",
        "양성자",
        "중성자",
        "반도체"
      ],
      "date": 1693486620000,
      "profile-image": "/post/profile/winkkom.png",
      "current-company": "NEOWIZ",
      "current-position": "Software Engineer",
      "summary": "원자란?",
      "excerpt-separator": "<!--more-->",
      "hide": true,
      "breadcrumbs": [
        "문서",
        "electric"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": []
      }
    },
    "description": "",
    "content": "\r\n원자는 모든 물질을 이루는 가장 기본적인 입자이다. \r\n원자핵과 그 주변을 이동하는 전자로 구성되어있다. \r\n원자핵을 구성하는 핵자는 양성자와 중성자가 있으며, 화학적 또는 물리적 방법으로 분해할 수 없다.\r\n\r\n일반적으로 원자핵을 양전하를 띄고, 전자는 음전하를 띈다. \r\n원자핵에서 양성자가 양전하를 띄게 되는데,  해당 양전하의 개수와 전자의 개수가 같을 때 가장 안정적으로 전기적인 중성 상태가 된다. \r\n즉, 전하를 띄지 않는다. 양성자는 바꿀 수 없지만, 전자는 다른 원자로 이동시킬 수 있기 때문에 양전하와 음전하의 개수가 달라지게 된다.\r\n\r\n이때, 양전하의 개수보다 음전하(전자)의 개수가 많으면 음이온, 적으면 양이온이라고 칭하기도 한다. \r\n전자는 원자핵 주변을 돌게 되는데 이때 이동 속도는 약 30만 km (진공 상태의 빛의 속도)이다. \r\n전자가 이동하는 궤도는 양자 역학으로 인해 일정하지 않다고 한다. \r\n전자의 수(또는 양성자의 수)에 따라 원자번호가 결정되기 때문에 우리가 과학적으로 정의하는 원소가 고유성을 가질 수 있는 이유이기도 하다. \r\n양성자를 비롯한 핵자의 수가 바뀌는건 핵융합과 핵분열이 대표적이다.\r\n\r\n전자는 원자핵 주위를 돌며 , 원자의 가장 안쪽 핵자의 주변부터 원자의 밖의 방향으로 껍질처럼 배치된 위치에서 운동한다. \r\n또한 최대로 배치될 수 있는 이 개수는 (양성자의 개수와 같아야 하기 때문에) 정해져 있다.  \r\n전자는 외부로부터 에너지를 가하면, 가장자리부터 떨어져 나가며, 모든 전자가 떨어져 나가, 원자핵만 남은 경우 플라즈마라고 한다.\r\n<!--more-->\r\n\r\n"
  },
  {
    "path": "/docs/tool/customize-markdown-it",
    "header": {
      "layout": "post",
      "title": "markdown-it의 Renderer Rule",
      "tags": [
        "markdown-it",
        "typescript"
      ],
      "date": 1689329820000,
      "thumbnail": "/post/tool/customize-markdown-it.webp",
      "current-company": "Herit Corporation",
      "current-position": "Backend Server Developer",
      "summary": "Markdown it 규칙 파헤치기",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "라이브러리/도구"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "개요::overview",
            "title": "개요",
            "fragment": "overview",
            "children": [
              {
                "rank": 3,
                "origin": "적용 전::before-customize",
                "title": "적용 전",
                "fragment": "before-customize",
                "children": []
              },
              {
                "rank": 3,
                "origin": "적용 후::after-customize",
                "title": "적용 후",
                "fragment": "after-customize",
                "children": []
              }
            ]
          },
          {
            "rank": 2,
            "origin": "분석::analysis",
            "title": "분석",
            "fragment": "analysis",
            "children": [
              {
                "rank": 3,
                "origin": "Render Rule (규칙)::renderer-rule",
                "title": "Render Rule (규칙)",
                "fragment": "renderer-rule",
                "children": []
              }
            ]
          },
          {
            "rank": 2,
            "origin": "템플릿 규칙 적용::apply-template-rule",
            "title": "템플릿 규칙 적용",
            "fragment": "apply-template-rule",
            "children": [
              {
                "rank": 3,
                "origin": "규칙 수정::modify-rule",
                "title": "규칙 수정",
                "fragment": "modify-rule",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "javascript의 마크다운 파서인 markdown-it 라이브러리를 커스텀해서 사용해보자.",
    "content": "\r\n\r\n## 개요::overview\r\n\r\n`markdown-it`은 대중적으로 많이 알려진 javascript markdown parser library이다.\r\n\r\n이글은 마크다운이 무엇 인지에 대해서는 설명하지 않는다. 그저 개인 블로그를 직접 만드는 입장에서 골치덩이인 마크다운 파서를 어떻게하면 조금더 유용하게 쓸수 있을까 고민해보며 만들면서 작성하였다.\r\n\r\n예를 들어 `> BlockQuote`를 작성한다고 가정했을때. 단순히 블럭으로 묶는 것보다 `> BlockQuote {{ \"type\": \"warning\" }}`과 같이 추가적인 템플릿 구문을 추가하여, 경고 스타일의 블럭으로 보여 줄 수도 있을 것이다. 이를 하기 위해서는 기존 `markdown` 해석 형식에서 더 나아가 새로운 템플릿 해석 로직을 추가해야한다. 아래 코드를 보고 좀 더 쉽게 이해해보자.\r\n\r\n\r\n\r\n### 적용 전::before-customize\r\n\r\n*Markdown*\r\n\r\n```markdown\r\n> 준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다.\r\n```\r\n\r\n*HTML*\r\n\r\n```html\r\n<blockquote>\r\n  준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다.\r\n</blockquote>\r\n```\r\n\r\n\r\n\r\n### 적용 후::after-customize\r\n\r\n*Markdown*\r\n\r\n```markdown\r\n> 준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다.\r\n:{ \"type\": \"warning\" }\r\n```\r\n\r\n*HTML*\r\n\r\n```html\r\n<blockquote class=\"warning\">\r\n  <p>준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다.</p>\r\n</blockquote>\r\n```\r\n\r\n이는 더 많은 정보를 담을수 있으며, 동시에 추가적인 스타일로 시각적인 효과를 주어, 더 나은 가독성을 만들 수 있다.\r\n\r\n물론 이렇게 만드려면 사용하려는 markdown 구문마다 모두 규칙을 만들어 줘야한다.\r\n\r\n`Markdown-it` 같은 경우 많은 사람들이 블로그 제작시 사용하지만, 실제로 커스텀할 수 있는 `Renderer Rule(랜더링을 하기 위한 규칙)` 같은 기능은 사용하지 않는다. 사실 잘 알려져 있지도 않기 때문에, 많이 사용하지 않는것 일 수 있다.  자신의 블로그를 대충 꾸미고 싶은 사람은 없을테니 이런 방식을 알려 조금이라도 쉽게 이해를 돕고, 나 또한 정리를 하며 다시한번 정립하고 싶다.\r\n\r\n\r\n\r\n## 분석::analysis\r\n\r\n### Render Rule (규칙)::renderer-rule\r\n\r\n`Renderer Rule(이하 *규칙)` 같은 경우는 `Markdown-it`에서 제공하는 내부적인 규칙의 흐름이다.\r\n\r\n```typescript\r\nimport MarkdownIt from 'mardown-it';\r\n\r\nconst markdown = new MarkdownIt();\r\nconsole.log('rules: ', Object.keys(markdown.renderer.rules));\r\n// Output\r\n// rules: ['code_inline', 'code_block', 'fence', 'image', 'hardbreak', 'softbreak', 'text', 'html_block', 'html_inline']\r\n```\r\n\r\n위는 기본적으로 제공하는 규칙이며, 대략적으로 9개로 볼 수 있다. 이 배열에 명시적으로 있지 않은 요소는 기본규칙이 적용 된다. 예를 들어 `bullet_list_opend` 규칙이 정의 되어 있지 않았으므로, `markdown-it`은 `HTML`로 해석을 시도할 때, `Renderer.prototype.renderToken`이라는 일반 렌더러가 사용된다.\r\n\r\n\r\n\r\n새로운 마크다운 문법을 창시하지 않는한, 아마 기존 문법에서 조금 수정하는 정도 일 것이다.\r\n\r\n따라서 만약 `blockquote_open`이라는 규칙을 수정한다고하면 아래와 같이 할수 있다.\r\n\r\n```typescript\r\nimport MarkdownIt from \"markdown-it\";\r\nimport Token from \"markdown-it/lib/token\";\r\nimport Renderer from \"markdown-it/lib/renderer\";\r\n\r\nconst md = new MarkdownIt();\r\nmd.renderer.rules.blockquote_open = (tokens: Array<Token>, index: number, options: MarkdownIt.Options, env: any, self: Renderer): string => {\r\n\r\n  return '';\r\n}\r\n```\r\n\r\n위에서 받아오는 규칙 함수같은 경우 아래와 같이 타입으로 정의 되어있다.\r\n\r\n```typescript\r\ndeclare namespace Renderer {\r\n    type RenderRule = (tokens: Token[], idx: number, options: MarkdownIt.Options, env: any, self: Renderer) => string;\r\n\r\n    interface RenderRuleRecord {\r\n        [type: string]: RenderRule | undefined;\r\n        code_inline?: RenderRule | undefined;\r\n        code_block?: RenderRule | undefined;\r\n        fence?: RenderRule | undefined;\r\n        image?: RenderRule | undefined;\r\n        hardbreak?: RenderRule | undefined;\r\n        softbreak?: RenderRule | undefined;\r\n        text?: RenderRule | undefined;\r\n        html_block?: RenderRule | undefined;\r\n        html_inline?: RenderRule | undefined;\r\n    }\r\n}\r\n```\r\n\r\n| 인자      | 의미                                         |\r\n| --------- | -------------------------------------------- |\r\n| *tokens*  | 해석되는 모든 토큰 목록 (각 태그에대한 토큰) |\r\n| *index*   | 현재 토큰의 키에 해당하는 인덱스             |\r\n| *options* | `markdown-it`객체가 생성될 때, 정의된 옵션   |\r\n| *env*     | ???                                          |\r\n| *self*    | 렌더러 자체에대한 참조                       |\r\n\r\n규칙을 수정할 때, 실패한다면 기존 규칙으로 `fallback` 시켜줄수 있는 로직도 추가한다면 아래와 같다.\r\n\r\n```typescript\r\nimport MarkdownIt from \"markdown-it\";\r\nimport Token from \"markdown-it/lib/token\";\r\nimport Renderer from \"markdown-it/lib/renderer\";\r\n\r\nconst md = new MarkdownIt();\r\nconst proxy = (tokens: Array<Token>, index: number, options: MarkdownIt.Options, env: any, self: Renderer) => self.renderToken(tokens, index, options);\r\n//기본 fallback 규칙\r\nconst defaultBlockquoteOpenRule = md.renderer.rules.blockquote_open || proxy;\r\n\r\nmd.renderer.rules.blockquote_open = (tokens: Array<Token>, index: number, options: MarkdownIt.Options, env: any, self: Renderer): string => {\r\n  return defaultBlockquoteOpenRule(tokens, index, options, env, self);\r\n}\r\n\r\nconst markdownText = '뜨거운 태양아래 시원한 계곡물에 잠수!\\n> 준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다.';\r\n//HTML 렌더링\r\nconst html = md.render(markdownText);\r\n/* html \r\n<p>뜨거운 태양아래 시원한 계곡물에 잠수!</p>\r\n<blockquote>\r\n\t<p>준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다.</p>\r\n</blockquote>\r\n*/\r\n```\r\n\r\n*tokens*  인자를 출력해보면 다음과 같다.\r\n\r\n```\r\n[\r\n\t{ \"type\": \"paragraph_open\", \"tag\": \"p\" ...},\r\n\t{ \"type\": \"inline\" \"tag\": '' ...},\r\n\t{ \"type\": \"paragraph_close\", \"tag\": \"p\" ...},\r\n\t{ \"type\": \"blockquote_open\", \"tag\": \"blockquote\" ...},\r\n\t{ \"type\": \"paragraph_open\", \"tag\": \"p\" ...},\r\n\t{ \"type\": \"inline\", \"tag\": '' ...},\r\n\t{ \"type\": \"paragragh_close\", \"tag\": 'p' ...},\r\n\t{ \"type\": \"blockquote_close\", \"tag\": \"blockquote\" ...}\r\n]\r\n```\r\n\r\n어떤 패턴이 보인다. 그렇다. `tokens`는 위에서부터 순서대로 html 을 랜더링할 정보를 가지고 있다.\r\n\r\n랜더링 된 `HTML`과 비교하면 직관적으로 알 수 있다.\r\n\r\n```html\r\n<!-- paragraph_open, inline, paragraph_close -->\r\n<p>뜨거운 태양아래 시원한 계곡물에 잠수!</p>\r\n<!-- blockquote_open, paragraph_open, inline, paragragh_close, blockquote_close -->\r\n<blockquote>\r\n\t<p>준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다.</p>\r\n</blockquote>\r\n```\r\n\r\n\r\n\r\n위와 같이 규칙은 랜더링 되어야할 순서대로 생성되기 때문에, 이미 랜더링 된 토큰을 수정할수 없다.\r\n\r\n```html\r\n<blockquote>\r\n\t<p>준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다.</p>\r\n</blockquote>\r\n```\r\n\r\n이런 코드를 보면 순서로 봤을 때 [`blockquote_open` ,`paragraph_open`, `inline`, `paragragh_close`, `blockquote_close`] 로 진행된다.\r\n\r\n만약 내가 `blockquote` 태그에 `class=\"waring\"` 이라는 속성을 추가 해주고 싶다면. 이 정보를 전달해야한다.\r\n\r\n```markdown\r\n> 준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다.\r\n> 또는 심장마비가 올수도 있다.\r\n:{ \"type\": \"warning\" }\r\n```\r\n\r\n이런 마크다운이 있을때 별다른 처리가 없다면 아래와 같이 전달하는 속성정보가 그대로 전달되어 출력될 것이다.\r\n\r\n```markdown\r\n<blockquote>\r\n\t<p>준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다. 또는 심장마비가 올수도 있다. :{ \"type\": \"warning\" }</p>\r\n</blockquote>\r\n```\r\n\r\n따라서 `inline` 토큰에서 \"warning\" 값을 추출해서 `blockquote` 토큰에 `class` 속성으로 추가해줘야한다. 또한 `inline` 토큰에는 실제 노출이 필요한 문자열인 `준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다. 또는 심장마비가 올수도 있다.`만 아래와 같이 남아야한다.\r\n\r\n```markdown\r\n<blockquote class=\"warning\">\r\n\t<p>준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다. 또는 심장마비가 올수도 있다.<p>\r\n</bloackquote>\r\n```\r\n\r\n\r\n\r\n위에서 이미 랜더링된 토큰은 수정할 수 없다고 했다. 그 말은 현재 상황에서 보면 [`blockquote_open` ,`paragraph_open`, `inline`, `paragragh_close`, `blockquote_close`]  순서로 진행될때 `inline`토큰에서 `blockquote_open` 토큰에 `class` 속성을 주입해도 이미 랜더링된 `blockquote_open` 토큰에는 적용이 안된다는 말이다. 따라서 `blockquote_open` 에서 뒤에 랜더링될 `inline` 토큰을 수정해야 정상적으로 노출될 수 있다.\r\n\r\n## 템플릿 규칙 적용::apply-template-rule\r\n\r\n\r\n\r\n### 규칙 수정::modify-rule\r\n\r\n```typescript\r\nimport MarkdownIt from \"markdown-it\";\r\nimport Token from \"markdown-it/lib/token\";\r\nimport Renderer from \"markdown-it/lib/renderer\";\r\n\r\nconst md = new MarkdownIt();\r\nconst proxy = (tokens: Array<Token>, index: number, options: MarkdownIt.Options, env: any, self: Renderer) => self.renderToken(tokens, index, options);\r\n//기본 fallback 규칙\r\nconst defaultBlockquoteOpenRule = md.renderer.rules.blockquote_open || proxy;\r\n\r\nmd.renderer.rules.blockquote_open = (tokens: Array<Token>, index: number, options: MarkdownIt.Options, env: any, self: Renderer): string => {\r\n  try {\r\n    const templateRE = /^([\\s\\S]*?)\\s*:\\s*(\\{[\\s\\S]*\\})\\s*$/mg;\r\n    const inlineIndex = index +2;\r\n\r\n    if (inlineIndex >= tokens.length) throw new Error(`Index out of range from tokens: ${inlineIndex}`);\r\n    const inline = tokens[inlineIndex];\r\n    const content = inline.content;\r\n    const noneMatch = !templateRE.test(content);\r\n    templateRE.lastIndex = 0;\r\n    if (!inline.map || noneMatch) {\r\n      return defaultBlockquoteOpen(tokens, index, options, env, self);\r\n    }\r\n    /*\r\n    * 준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다. 두번째 줄이지! - executed[1]\r\n    * :{ \"type\": \"warning\" } - executed[2]\r\n    */\r\n    const executed = templateRE.exec(content);\r\n    const text = executed?.[1] ?? '';\r\n    const attributesStr = executed?.[2];\r\n    const attributes = JSON.parse(attributesStr ?? '{}');\r\n    //type = \"warning\"\r\n    const type = attributes['type'];\r\n\r\n\t\t//children은 inline내부에서 랜더링될 자식 토큰들의 목록이다.\r\n    //여기서 slice는 text값 뒤에 템플릿은 필요없기 때문에 제거해주기 위함이다.\r\n    const lfCount = countNewline(text);\r\n    const lineCount = lfCount +1;\r\n    inline.children = inline.children?.slice(0, lfCount + lineCount) ?? inline.children;\r\n    inline.content = text ?? inline.content;\r\n\r\n    //현재 토큰에 class 속성을 부여한다.\r\n    const blockquoteOpen = tokens[index];\r\n    if (type) {\r\n      blockquoteOpen.attrJoin('class', type);\r\n    }\r\n\r\n    return defaultBlockquoteOpen(tokens, index, options, env, self);\r\n  } catch (e: Error) {\r\n    console.error(`Error occurred at parsing token: \"${e.message}\"`);\r\n    return '';\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n`:{ \"type\" : \"warning\" }` 템플릿은 뭔가 급조해서 만들어서 만들었기 때문에 자신만의 템플릿을 만들어 더 나은 parser를 구현할 수 있을듯 하다.\r\n\r\n사실 기존에도 `chirpy` 같은 Jekyll 테마 같은 경우에는 커스텀 템플릿을 만들어 공유되고 있었다.\r\n\r\n"
  },
  {
    "path": "/docs/language/typescript/typescript-getting-start",
    "header": {
      "layout": "post",
      "title": "타입스크립트 시작하기 1 (소개)",
      "tags": [
        "Typescript",
        "Javascript",
        "Type"
      ],
      "date": 1681552860000,
      "current-company": "NEOWIZ",
      "current-position": "Software Engineer",
      "profile-image": "/post/profile/profile1.jpg",
      "thumbnail": "/post/typescript/typescript_getting_start.png",
      "summary": "타입스크립트 소개",
      "excerpt-separator": "<!--more-->",
      "hide": true,
      "breadcrumbs": [
        "문서",
        "언어",
        "타입스크립트"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "우리가 아는 자바스크립트",
            "title": "우리가 아는 자바스크립트",
            "fragment": "root-0",
            "children": []
          },
          {
            "rank": 2,
            "origin": "타입스크립트는 무엇인가?",
            "title": "타입스크립트는 무엇인가?",
            "fragment": "root-1",
            "children": []
          },
          {
            "rank": 2,
            "origin": "타입스크립트를 배우기전 ES5 또는 ESNext의 주요 문법을 알아보자",
            "title": "타입스크립트를 배우기전 ES5 또는 ESNext의 주요 문법을 알아보자",
            "fragment": "root-2",
            "children": [
              {
                "rank": 3,
                "origin": "비구조화 할당",
                "title": "비구조화 할당",
                "fragment": "root-2-0",
                "children": []
              },
              {
                "rank": 3,
                "origin": "화살표 함수 (arrow function)",
                "title": "화살표 함수 (arrow function)",
                "fragment": "root-2-1",
                "children": []
              },
              {
                "rank": 3,
                "origin": "클래스 (class)",
                "title": "클래스 (class)",
                "fragment": "root-2-2",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "타입스크립트 시작하기.\r\n도대체 왜 사용하는거고, 뭐가 좋은걸까?",
    "content": "\r\n\r\n## 우리가 아는 자바스크립트\r\n\r\n사실 나도 타입스크립트를 처음 배우는 거고, 잘 알지 못한다. 하지만, 자바스크립트와 같이 **동적타입**의 언어는 결국 많은 문제를 유발 시킬수 있는걸 알고 있다.\r\n일반 자바스크립트에는 타입이 없기 때문에 코드대로 그냥 변수로 받아야한다. 따라서 아래와 같은 일반 자바스크립트에서는 해괴한 연산도 가능하다.\r\n\r\n```javascript\r\n//일반 자바스크립트 함수의 선언\r\nfunction getNow() {\r\n    return new Date()\r\n}\r\n\r\nvar now = getNow();\r\nvar plus1Day = now + '1Day';\r\nconsole.log('plusDay:', plus1Day) \r\n//출력결과 -> plusDay: Sat Apr 15 2023 19:12:32 GMT+0900 (한국 표준시)1Day\r\n```\r\n\r\n3번라인에서 보면 `getNow()` 함수는 `Date` 타입의 현재시간 값을 리턴한다. 근데, 7번라인에서 다시보면 `Date` 타입과 `string` 연산을 한다.\r\n하지만, 어떠한 에러도 발생되지 않는다. 결과적으로 연산된 `plus1Day` 변수의 타입은 `string`이다.\r\n`Date` 함수와 `string`의 덧셈에 결과타입이 `string`인 내용은, 타입스크립트를 알아보는 과정에서 별로 중요하지 않기에 넘어간다.\r\n\r\n이 처럼 타입이 존재는 하지만, 변수가 타입에 연연하지않은 언어를 `동적타입 언어`라고 한다. \r\n우리가 일반적으로 알고있는 객체지향 언어는 모두 정적타입 언어 이다. 각 변수의 타입이 정해져있고, 정해진대로 연산을 하기 때문이다.\r\n게다가 `javascript`는 ECMA Script(ES)라는 표준 스크립트 버전이 있는데, 현재 우리가 사용중인 브라우저는 ES5 버전만 해석할 수 있다.\r\n\r\n`ES5`버전은 2009년에 공개된 버전이며, 현재까지 브라우저는 해당 버전이상의 자바스크립트는 해석할 수 없다.\r\n이 이상의 버전을 사용하려면, Babel(Javascript Compiler)같은 특정도구를 이용해 브라우저가 해석할 수 있는 자바스크립트의 버전으로 컴파일 해줘야 한다.\r\n이 외에도 `ES5`이상에서 지원되는 javascript 버전에는 여러가지 기능 및 문법들을 사용할수 있었다.\r\n\r\n```javascript\r\n//ES6 문법 const\r\nconst sum = (a, b) => {\r\n    return a + b\r\n}\r\n```\r\n위의 설명대로 브라우저는 `const`를 알 수 없다. 하지만 브라우저 내부에있는 js 엔진이 해석할 수 있기에 우리는 `ES`버전은 딱히 몰라도 상관없다.\r\n타입스크립트를 배우기위해선, 위의 내용들을 알고있어야한다. `ES5`의 문법은 당연히 `ESNext(6, 7..)`에서 포함하고 있고, 이또한 `Typescript`에서 포함하고있다.\r\n`타입스크립트`또한, `ESNext`와 동일하게 ES5로 `Transpile`을 해줘야 하는건 예외 없다. \r\n\r\n그럼 우리가 아는 자바스크립트를 그냥 사용해도 되는데, 왜 굳이 타입스크립트를 사용하는 걸까?\r\n\r\n## 타입스크립트는 무엇인가?\r\n\r\n간단하게 설명하면, 동적타입의 언어와 같이 모든 객체는 타입을 가지며, `Null-Sefe`한 연산을 할 수 있는 등 여러 장점이 있다.\r\n예를 들어 다음과 같은 `Javascript` 코드에서 문제가 발생 했을 때, 쉽게 문제를 알수 없다.\r\n\r\n```javascript\r\nfunction makePerson(name, age) {\r\n    return {\r\n        name: name,\r\n        age: age\r\n    }\r\n}\r\n\r\nconst person = makePerson(30, 'Kim')\r\n```\r\n\r\n하지만, 위와 같은 코드에 각 변수에대한 타입이 생긴다면, 작성할 때부터 문제를 알 수 있다.\r\n만약 위에 코드에서 타입이 추가된다면 어떻게 달라질까?\r\n\r\n```typescript\r\nclass Person {\r\n    name: string\r\n    age: number\r\n\r\n    constructor(name: string, _age_: number) {\r\n        this.name = name\r\n        this.age = age\r\n    }\r\n}\r\n\r\nfunction makePerson(name: string, age: number): Person {\r\n    return new Person(name, age)\r\n}\r\n\r\nconst person: Person = makePerson('Kim', 4)\r\n```\r\n\r\n좀 더 많은 코드가 작성되었다. 하지만, 각 변수는 타입을 가지며, 좀 더 견고한 어플리케이션을 만들수 있는 타입이 생겼다.\r\n클래스 생성을 통해, 의도한 값을 가지는 타입의 객체가 생성되었다. 이는 정말 중요한 내용이다.\r\n기존에 자바스크립트에서 할 수 없었던, 그리고 걱정하지 않아도 되었던, 코드를 작성할 수 있게된다.\r\n\r\n## 타입스크립트를 배우기전 ES5 또는 ESNext의 주요 문법을 알아보자\r\n\r\n앞서 말한것처럼 `Typescript`는 `ESNext`, `ES5`모두 포괄하고 있는 상위 집합이기에, 두가지 문법을 모두 사용할 수 있다.\r\n타입스크립몇가지 간단한 문법을 \r\n\r\n### 비구조화 할당\r\n\r\n`비구조화 할당(destructuring assignment)`는 객체와 배열에 적용할 수 있으며, 말그대로 구조화 하지않은 채 값을 특정 변수로 할당 하는 것 이다.\r\n이는 `ESNext`에서 제공되며,  \r\n\r\n```javascript{6}\r\nlet person = {\r\n    first_name: 'John',\r\n    age: 30\r\n}\r\n\r\nlet { first_name, age } = person\r\n\r\nconsole.log(typeof age) // \"number\"\r\nconsole.log(age)        // 30\r\nconsole.log(first_name) // \"John\"\r\n```\r\n\r\nperson을 이용하여, 비구조화 할당을 통해 `first_name` field와 `age`필드를 할당 할 수 있다.\r\n그럼 이 할당을 통해, `let { first_name, age }`의 값 중 `first_name`의 값을 바꾸면 어떻게 될까?\r\n\r\n```javascript\r\nlet person = {\r\n    first_name: 'John',\r\n    age: 30\r\n}\r\n\r\nlet { first_name, age } = person\r\n\r\nfirst_name = 'Micheal'\r\nconsole.log('person:', person)\r\n/*\r\n    person: {\r\n        \"first_name\": \"John\",\r\n        \"age\": 30\r\n    }\r\n */\r\nperson.first_name = 'Smith'\r\nconsole.log('first_name:', first_name)\r\n/*\r\n    first_name: Micheal\r\n */\r\n```\r\n\r\n첫번째로 할당된 `first_name`의 값을 변경했지만, 변경 되지 않았다.\r\n또한, 반대로 `person.first_name`의 값을 변경 했지만, 역시나 `first_name`의 값이 변경 되지 않았다.\r\n여기서 `비구조화 할당`은 얕은복사를 하는걸 알 수 있다.\r\n배열의 비구조화 할 당은 어떻게 사용할 수 있을까?\r\n\r\n```javascript{2}\r\nlet array = [1, 7, 54, 66, 90]\r\nlet [first, ...mod] = array\r\n\r\nconsole.log(array) // [1, 7, 54, 66, 90]\r\nconsole.log(first) // 1\r\nconsole.log(mod)   // [7, 54, 66, 90]\r\n```\r\n\r\n>2번 라인의 `...mod`는 `스프레드 연산자`이며, 내부 요소를 한번에 가져온다.\r\n> 스프레드 연산자는 인자의 마지막에만 사용할 수 있다.\r\n:{ \"type\": \"note\", \"icon\": \"info\" }\r\n\r\n`first`와 `mod`로 나누어 할당 했고 출력 결과는 위 처럼 배열의 순서에 맞는 값들로 나뉘어졌다.\r\n`객체`또는 `배열`의 구조를 분해해서 할당하기 때문에 `구조분해 할당`(`또는 \"비구조화 할당\"`)이라고 칭한다.\r\n\r\n\r\n### 화살표 함수 (arrow function)\r\n\r\n```javascript\r\n// 일반 함수형\r\nfunction toUpperCase(str) {\r\n    return str.toUpperCase()\r\n}\r\n\r\n// 화살표 함수형\r\nconst toUpperCase = () => str.toUpperCase()\r\n```\r\n\r\n자바스크립트에서는 함수또한 객체로 취급되며, 위와 같은 표현식으로 선언할 수 있다.\r\n이 화살표 함수(`arrow function`)은 내부로직이 한줄로 표현이 된다면, `{}`괄호와 `return`을 생략할 수있다.\r\n중요한 부분은 `=`다음으로 오는 `() => {}`구문이다. `()`에는 일반함수처럼 매개변수를 받을 수 있고, `{}` 내부 또한 함수와 동일하게 작성할 수 있다.\r\n*주의할 점*은 `화살표 함수` 내에서 `this` 키워드는 함수 `자신`을 의미한다는 점을 알고 있어야 한다. \r\n이는 `javascript`객체와 관련된 부분인데, `javascript`에서 `this`는 객체의 참조를 의미한다. \r\n`class` 또는 모듈에서 사용한다면, 현재 속해있는 객체(`브라우저`일반적으로 `window: DOM tree`로 바인딩) 에대해 바인딩 하기때문에, \r\n객체 자체인 `arrow`함수는 `this`에 대해 자기 자신이 바인드 되는 것이다.\r\n\r\n### 클래스 (class)\r\n\r\n일반적으로 객체지향 언어에서 지원 하는 `class`의 개념은 어떤 객체에 대해 정적인 관점에서 서술 할 때 사용 된다.\r\n아래의 예제를 통해 `알람시계`가 갖고있는 정적인 관점의 상태와 책임에 대해 좀더 객체지향적으로 이해하기 위해 `typescript`를 통해 알아보자.\r\n\r\n```typescript\r\n\r\nclass Speaker {\r\n    ringing() {\r\n        //저장된 음악으로, 스피커 동작 로직    \r\n    }\r\n}\r\n\r\ninterface Alarm {\r\n    alert(message: string): never\r\n}\r\n\r\nclass Clock implements Alarm {\r\n\r\n    private readonly _speaker: Speaker\r\n\r\n    constructor(speaker: Speaker) {\r\n        this._speaker = speaker\r\n    }\r\n    \r\n    setTimeOfRinging(milis: number, message: string): never {\r\n        setTimeout(() => {\r\n            this._speaker.ringing()\r\n            alert()\r\n        }, milis)\r\n    }\r\n    \r\n    alert(message: string): never {\r\n        console.log(message)\r\n    }\r\n}\r\n\r\nconst clock: Clock = new Clock(new Speaker())\r\nclock.setTimeOfRinging(1000, '1초가 지났습니다.')\r\n```\r\n\r\n기존에 `javascript`에서는 할 수 없던, 객체의 상속, 추상화가 가능 하므로서, 간단한 알람시계 클래스지만,각 객체들의 `책임`을 부여하므로써,\r\n좀 더 견고한 `어플리케이션`을 만들 수 있다.\r\n"
  },
  {
    "path": "/docs/tool/asdf",
    "header": {
      "layout": "post",
      "title": "다중모듈 관리툴 asdf",
      "tags": [
        "Module",
        "Multi Module"
      ],
      "date": 1676380440000,
      "thumbnail": "/post/tool/asdf.png",
      "current-company": "Herit Corporation",
      "current-position": "Backend Server Developer",
      "summary": "asdf",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "라이브러리/도구"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "설치",
            "title": "설치",
            "fragment": "root-0",
            "children": []
          },
          {
            "rank": 2,
            "origin": "명령어",
            "title": "명령어",
            "fragment": "root-1",
            "children": [
              {
                "rank": 3,
                "origin": "플러그인",
                "title": "플러그인",
                "fragment": "root-1-0",
                "children": []
              },
              {
                "rank": 3,
                "origin": "모듈",
                "title": "모듈",
                "fragment": "root-1-1",
                "children": []
              }
            ]
          },
          {
            "rank": 2,
            "origin": "설치 순서",
            "title": "설치 순서",
            "fragment": "root-2",
            "children": []
          }
        ]
      }
    },
    "description": "다양한 모듈의 버전을 한번에 관리할 수 있는 asdf",
    "content": "\r\n\r\nasdf 는 다중 모듈 버전 관리 도구이다.\r\n`nvm`이 node에 대한 버전을 관리할 수 있듯이, `asdf`는 java, node, go 등 다양한 모듈의 버전을 관리할 수 있다.\r\n먼저 모듈 버전 관리를 하려면 사용할 모듈의 플러그인을 설치해야 한다. 설치할 수 있는 플러그인이 뭐가 있는지 확인하고, 플러그인을 설치해서 버전 관리를 하면 되는 구조다.\r\n\r\n## 설치\r\n\r\n1. `git clone https://github.com/asdf-vm/asdf.git ~/.asdf --branch v0.15.0`\r\n2. [OS 별 참조](https://asdf-vm.com/guide/getting-started.html#_3-install-asdf)\r\n\r\n\r\n## 명령어\r\n\r\n### 플러그인\r\n\r\n```shell\r\n$ asdf plugin list all # 전체 플러그인 조회\r\n$ asdf plugin list all | grep <plugin-name> # 검색 (윈도우는 findStr)\r\n$ asdf plugin add <plugin-name> # 플러그인 설치 \r\n```\r\n\r\n### 모듈\r\n\r\n```shell\r\n$ asdf list-all <plugin-name> #플러그인 모듈 조회\r\n$ asdf list-all <plugin-name> | grep <module-name> # 검색 (윈도우는 findStr)\r\n$ asdf latest <plugin-name> <version> #최신 버전 확인\r\n$ asdf install <module-name> <version> #모듈 설치\r\n$ asdf local <module-name> <version> #현재 디렉토리에서 참조할 모듈 버전 지정(선행 설치 필요)\r\n$ asdf global <module-name <version> #전체 디렉토리에서 참조할 모듈 버전 지정 (선행 설치 필요)\r\n```\r\n\r\n[다른 명령어](https://asdf-vm.com/manage/commands.html);\r\n\r\n\r\n## 설치 순서\r\n\r\n1. 플러그인\r\n2. 모듈-버전\r\n"
  },
  {
    "path": "/docs/network/https",
    "header": {
      "layout": "post",
      "title": "HTTPS (HyperText Transfer Protocol Secure)",
      "tags": [
        "Network",
        "TCP/IP",
        "HTTP"
      ],
      "date": 1660237380000,
      "thumbnail": "/post/network/https/hilarious-process-from-making-premaster-secret.png",
      "profile-image": "/post/profile/winkkom.png",
      "current-company": "NEOWIZ",
      "current-position": "Software Engineer",
      "summary": "HTTPS",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "네트워크"
      ],
      "images": [
        {
          "src": "/post/network/https/http-without-encrypt.png",
          "alt": "암호화 되지 않은 정보 전송"
        },
        {
          "src": "/post/network/https/http-with-encrypt.png",
          "alt": "암호화 된 정보 전송"
        },
        {
          "src": "/post/network/https/tls-layer-structure.png",
          "alt": "TLS 계층 구조"
        },
        {
          "src": "/post/network/https/client-hello.png",
          "alt": "Client Hello"
        },
        {
          "src": "/post/network/https/captured-client-hello.png",
          "alt": "WireShark로 캡쳐된 Client Hello"
        },
        {
          "src": "/post/network/https/specification-of-cipher-suite.png",
          "alt": "Cipher Suite 스펙"
        },
        {
          "src": "/post/network/https/server-hello.png",
          "alt": "Server Hello"
        },
        {
          "src": "/post/network/https/certificate-in-tls-1.2.png",
          "alt": "TLS 1.2의 Certificate"
        },
        {
          "src": "/post/network/https/hilarious-certificate.png",
          "alt": "인증서의 공개키 검증"
        },
        {
          "src": "/post/network/https/hilarious-verification.png",
          "alt": "브라우저의 인증서 검증"
        },
        {
          "src": "/post/network/https/server-key-exchange.png",
          "alt": "Server Key Exchange"
        },
        {
          "src": "/post/network/https/captured-server-key-exchange.png",
          "alt": "WireShark로 캡쳐된 Server Key Exchange"
        },
        {
          "src": "/post/network/https/client-key-exchange.png",
          "alt": "Client Key Exchange"
        },
        {
          "src": "/post/network/https/hilarious-process-from-making-premaster-secret.png",
          "alt": "서버와 클라이언트의 공개키로 Premaster Secret을 만든다."
        },
        {
          "src": "/post/network/https/change-cipher-spec-and-finished.png",
          "alt": "Change Cipher Spec과 and Finished"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "HTTPS란?::what-is-https",
            "title": "HTTPS란?",
            "fragment": "what-is-https",
            "children": []
          },
          {
            "rank": 2,
            "origin": "HTTPS 동작 방식::how-https-work",
            "title": "HTTPS 동작 방식",
            "fragment": "how-https-work",
            "children": []
          },
          {
            "rank": 2,
            "origin": "TLS 1.2 동작 과정::how-tls-1.2-works-in",
            "title": "TLS 1.2 동작 과정",
            "fragment": "how-tls-1.2-works-in",
            "children": [
              {
                "rank": 3,
                "origin": "1. Client Hello::client-hello",
                "title": "1. Client Hello",
                "fragment": "client-hello",
                "children": []
              },
              {
                "rank": 3,
                "origin": "2. Server Hello::server-hello",
                "title": "2. Server Hello",
                "fragment": "server-hello",
                "children": []
              },
              {
                "rank": 3,
                "origin": "3. Certificate::certificate",
                "title": "3. Certificate",
                "fragment": "certificate",
                "children": []
              },
              {
                "rank": 3,
                "origin": "3-5. Server Key Exchange::server-key-exchange",
                "title": "3-5. Server Key Exchange",
                "fragment": "server-key-exchange",
                "children": []
              },
              {
                "rank": 3,
                "origin": "4. Client Key Exchange::client-key-exchange",
                "title": "4. Client Key Exchange",
                "fragment": "client-key-exchange",
                "children": []
              },
              {
                "rank": 3,
                "origin": "5. Change Cipher Spec and Finished::change-cipher-spec-and-finished",
                "title": "5. Change Cipher Spec and Finished",
                "fragment": "change-cipher-spec-and-finished",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "HTTPS(HyperText Transfer Protocol Secure)는 전송 계층에서 데이터를 암호화하여 보안을 강화한 프로토콜이다.\r\n클라이언트와 서버가 신뢰할 수 있는 통신이 어떻게 이루어지는지 알아보자.",
    "content": "\r\n## HTTPS란?::what-is-https\r\n\r\n**HTTPS**(HyperText Transfer Protocol Secure)는 HTTP의 보안 버전으로, 전송 계층에서 데이터를 암호화하여 보안을 강화한 프로토콜이다.\r\n기본 HTTP 프로토콜은 암호화되지 않은 텍스트로 통신하기 때문에, 중요한 정보를 주고 받을 때 보안에 취약하다.\r\n\r\n![암호화 되지 않은 정보 전송](/post/network/https/http-without-encrypt.png)\r\n:{ \"align\": \"center\", \"max-width\": \"400px\", \"description\": \"암호화 되지 않은 정보 전송\" }\r\n\r\n예를 들어 어떤 사이트에 가입하려고 할 때, 계정 정보를 암호화 없이 전송하게 된다면, 중간에 누군가가 정보를 가로채어 악용할 수 있다.\r\n인증서는 도메인을 기반으로 발급되기 때문에 `http://...`으로 접속한 경우 다른 사이트로 리다이렉트되어 악용될 수 있다. \r\n\r\n![암호화 된 정보 전송](/post/network/https/http-with-encrypt.png)\r\n:{ \"align\": \"center\", \"max-width\": \"400px\", \"description\": \"암호화 된 정보 전송\" }\r\n\r\n반대로 암호화된 HTTPS 프로토콜을 사용하게 되면, 중간에 누군가가 정보를 가로채도 암호화된 정보를 해독하기 어렵기 때문에 안전하다.\r\n또한 이 암호화의 간격이 짧아서, 암호화된 정보를 해독하는데 많은 시간이 소요되어 보안성이 높다.\r\n\r\n## HTTPS 동작 방식::how-https-work\r\n\r\nHTTPS는 [전송 계층](/docs/network/tcp-ip/transport-layer)과 **응용계층** 사이에서 동작 하기 때문에, 응용 계층의 구현과 상관없이 사용이 가능하다.\r\n\r\n흔히 **SSL**(Secure Socket Layer) 또는 **TLS**(Transport Layer Security)이라고 불리우는 프로토콜을 사용하여 데이터를 암호화한다.\r\n두 가지다 같은 내용이지만, 아래와 같이 구분된다:\r\n\r\n* **SSL**\r\n  * 넷스케이프(Netscape)에서 개발한 프로토콜\r\n  * 1.0: 공개된적 없음 (Netscape 내부에서만 사용)\r\n  * 2.0: 1995년 공개 (심각한 보안 취약점 존재로 2011년 공식 사용중단)\r\n  * 3.0: 1996년 공개 (현재도 사용중이지만, 취약점 존재, 2015년 공식 사용 중단)\r\n* **TLS**\r\n  * IETF(Internet Engineering Task Force)에서 개발한 프로토콜\r\n  * 1.0: 1999년 공개 (취약점 존재)\r\n  * 1.1: 2006년 공개 (취약점 보완)\r\n  * 1.2: 2008년 공개 (현재 사용중)\r\n  * 1.3: 2018년 공개 (현재 사용중)\r\n\r\n![TLS 계층 구조](/post/network/https/tls-layer-structure.png)\r\n:{ \"align\": \"center\", \"max-width\": \"600px\", \"description\": \"TLS 계층 구조\" }\r\n\r\n현재까지 사용되는 TLS는 1.2버전과 1.3버전이 있으며, 1.3버전이 보안성이 더 높다.\r\n\r\n>TLS는 크게 2가지 Record Protocol과 Handshake Protocol로 나뉘어지지만, 사실상 Handshake은 Record 위에서 동작한다.\r\n:{ \"type\": \"note\", \"icon\": \"info\" }\r\n\r\n## TLS 1.2 동작 과정::how-tls-1.2-works-in\r\n실제 `TLS 1.3`의 경우 Extensions의 `supported_versions` 확장 필드를 통해 `TLS 1.3`을 지원한다는 것을 알린다.\r\n\r\n\r\n### 1. Client Hello::client-hello\r\n\r\n![Client Hello](/post/network/https/client-hello.png)\r\n:{ \"align\": \"center\", \"max-width\": \"500px\", \"description\": \"Client Hello\" }\r\n\r\n먼저 [TCP 연결](/docs/network/tcp-ip/transport-layer#tcp-3-way-handshake)이 이루어지면 TLS Handshake가 시작된다.\r\n클라이언트는 서버에게 `Client Hello` 메세지를 보내어, 서버와의 통신을 시작한다.\r\n\r\n![WireShark로 캡쳐된 Client Hello](/post/network/https/captured-client-hello.png)\r\n:{ \"align\": \"center\", \"max-width\": \"400px\", \"description\": \"WireShark로 캡쳐된 Client Hello\" }\r\n\r\n* **Version**: 클라이언트가 지원하는 TLS 버전 0x0303(TLS 1.2)\r\n* **Cipher Suite**\r\n  * **키 교환**, **인증**, **암호화**, **해시 알고리즘** 등을 포함한 암호화 알고리즘의 조합\r\n  * ![Cipher Suite 스펙](/post/network/https/specification-of-cipher-suite.png)\r\n* **Random**: `Random` 필드는 클라이언트가 생성한 난수를 포함한다. 이는 세션을 생성할 때 사용되는 값이다. 일반적으로 32바이트의 난수를 생성한다.\r\n* **Compression Method**:  `null(0x00) - 압축하지 않음`으로 설정되어 있지만, `DEFLATE(0x01) - ZLIB 압축`, `LSZ(0x40) - LZS 압축` 등이 있다.\r\n* **Session ID**: 클라이언트가 생성한 세션 ID (재연결 시)\r\n  * 이 값은 `TLS 1.2`에서만 사용되고, `TLS 1.3`에서는 `Legacy Session ID`로 변경 되었으며, 하위 호환성을 위해 유지되었지만, 실제로는 사용되지 않는다.\r\n* **Extensions**\r\n  * TLS 1.2의 경우 선택적으로 사용되는 확장 필드이며, `TLS 1.3`에서는 필수로 사용된다.\r\n  * **supported_versiosn**: 클라이언트가 지원하는 TLS 버전을 나타내는 확장 필드\r\n  * **key_share**: `supported_groups`에서 명시한 그룹들에 대한 클라이언트의 공개키 값들\r\n    * `1-RTT` 핸드쉐이크를 위해 미리 키를 생성\r\n  * **pre_shared_key(선택사항)**: 클라이언트가 서버와 공유한 세션 ID\r\n    * `0-RTT` 핸드쉐이크를 위해 사용\r\n\r\n>클라이언트가 Client Hello 메세지를 보내면, TCP 계층에서 메세지를 받자마자 ACK가 전송한다. \r\n>하지만 TLS 레벨에서는 하위계층(TCP)의 통신은 알수 없기 떄문에, ACK 전송을 기다리지 않고 Server Hello를 전송한다.   \r\n: { \"type\": \"note\", \"icon\": \"info\" }\r\n\r\n### 2. Server Hello::server-hello\r\n\r\n![Server Hello](/post/network/https/server-hello.png)\r\n:{ \"align\": \"center\", \"max-width\": \"500px\", \"description\": \"Server Hello\" }\r\n\r\n서버는 클라이언트가 보낸 `Client Hello` 메세지를 받으면 클라이언트에게 `Server Hello` 메세지를 보낸다.\r\n클라이언트에서 보낸 `Client Hello` 메세지를 통해 서버는 클라이언트가 지원하는 암호화 알고리즘을 확인하고, 서버에서 사용할 암호화 알고리즘을 선택한다.\r\n\r\n>**Version**, **Cipher Suite**, **Random**, **Compression Method** 필드들은 `Client Hello`와 동일하다.\r\n: { \"type\": \"note\", \"icon\": \"info\" }\r\n\r\n### 3. Certificate::certificate\r\n\r\n![TLS 1.2의 Certificate](/post/network/https/certificate-in-tls-1.2.png)\r\n:{ \"align\": \"center\", \"max-width\": \"500px\", \"description\": \"TLS 1.2의 Certificate\" }\r\n\r\nCertificate 메세지에는 인증서 체인이 포함되어 있으며 각 인증서에는 공개키가 포함되어 있다.\r\n인증서는 [ASN.1](https://en.wikipedia.org/wiki/ASN.1)(**A**bstract **S**yntax **N**otation One) 형식으로 작성된다.\r\n\r\nX.509 인증서의 v3 디지털 인증서는 다음과 같은 필드를 포함한다:\r\n\r\n* Certificate\r\n  * Version Number\r\n  * Serial Number\r\n  * Signature Algorithm ID\r\n  * Issuer Name\r\n  * Validity period\r\n    * Not Before\r\n  * Not After\r\n  * Subject name\r\n  * Subject Public Key Info\r\n    * Public Key Algorithm\r\n  * Subject Public Key\r\n  * Issuer Unique Identifier (optional)\r\n  * Subject Unique Identifier (optional)\r\n  * Extensions (optional)\r\n    * ...\r\n* Certificate Signature Algorithm\r\n* Certificate Signature\r\n\r\n아무튼 각 인증서는 X.509 규격을 따르는데, 중요한 점은 이곳에 `공개키`와 `서명`이 포함되어 있다는 것이다.\r\n`클라이언트`는 `Certificate` 메세지를 받으면, 인증서 체인에 대해 각 인증서를 검증한다.\r\n\r\n```text\r\n[서버 인증서] -> [중간 CA 인증서] -> [ROOT CA 인증서]\r\n```\r\n\r\n예를 들어 이러한 구조로 인증서 체인이 있다면, 클라이언트는 서버인증서의 기본 필드, 확장 필드, 서명을 검증한다.\r\n각 인증서를 검증 하는 방법은 이래와 같다.\r\n\r\n![인증서의 공개키 검증](/post/network/https/hilarious-certificate.png)\r\n:{ \"align\": \"center\", \"max-width\": \"400px\", \"description\": \"인증서의 공개키\" }\r\n\r\n1. 인증서에서 `Certificate` 부분의 `ASN.1 DER` 인코딩된 바이트 문자열을 `Certificate Signature Algorithm`값을 이용해 해싱한다.\r\n2. 상위 인증서의 공개키로 `Certificate Signature`를 복호화하여 해시값을 얻는다.\r\n3. 1번에서 얻은 해시값과 2번에서 얻은 해시값을 비교하여 인증서의 유효성을 검증한다.\r\n\r\n>Root CA의 인증서는 자체 서명(Self-Signed) 인증서이며, **브라우저**는 대부분의 Root CA 인증서를 내장하고 있다. \r\n> 내장된 인증서 목록과 인증서 체인의 Root 인증서를 비교하여 검증한다. \r\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\" }\r\n\r\n\r\n![브라우저의 인증서 검증](/post/network/https/hilarious-verification.png)\r\n:{ \"align\": \"center\", \"max-width\": \"400px\", \"description\": \"무서운 브라우저의 인증서 검증\" }\r\n\r\n>이는 Root CA가 제공하는 인증서가 신뢰할 수 있는 인증서인지를 검증하는 과정이다.\r\n: { \"type\": \"warning\", \"icon\": \"info\" }\r\n\r\n### 3-5. Server Key Exchange::server-key-exchange\r\n\r\n![Server Key Exchange](/post/network/https/server-key-exchange.png)\r\n:{ \"align\": \"center\", \"max-width\": \"500px\", \"description\": \"Server Key Exchange\" }\r\n\r\n`Server Key Exchage` 메세지는 일반적인 상황에서는 전송되지 않지만, `Server Hello` 메세지의 `Cipher Suite`가 임시 교환 알고리즘을 사용하는 경우 전송된다.\r\n\r\n임시 키 알고리즘은 DHE(Diffie-Hellman Ephemeral) 또는 ECDHE(Elliptic Curve Diffie-Hellman Ephemeral) 등이 있다.\r\n\r\n![WireShark로 캡쳐된 Server Key Exchange](/post/network/https/captured-server-key-exchange.png)\r\n:{ \"align\": \"center\", \"max-width\": \"400px\", \"description\": \"WireShark로 캡쳐된 Server Key Exchange\" }\r\n\r\n`Server Key Exchange` 메세지를 받은 클라이언트는 서명을 확인 하고, 임시 공개키를 저장한다. 그후 키교환에 필요한 자체 임시 키 생성을 준비한다.\r\n\r\n### 4. Client Key Exchange::client-key-exchange\r\n\r\nTLS에서 메세지를 암호화 하고 복호화 하려면 어떤 세션키가 있어야한다. 하지만 그 세션키를 만드려면 먼저 `Premaster Secret`이라는 값이 만들어져야 한다.\r\n\r\n하지만, 이 값은 `Cipher Suite`의 키교환 알고리즘에 따라 만드는 방식이 제각각이다. 아래는 알고리즘별 차이를 설명한다.\r\n\r\n![Client Key Exchange](/post/network/https/client-key-exchange.png)\r\n:{ \"align\": \"center\", \"max-width\": \"500px\", \"description\": \"Client Key Exchange\" }\r\n\r\n* **RSA**:\r\n  * 클라이언트의 `Premaster Secret`는 48바이트 이다.\r\n  * 맨 앞의 2바이트는 TLS 프로토콜 버전인 `0x0303 0x0303`을 넣는다.\r\n  * 나머지 46바이트에는 암호학적으로 안전한 난수 생성기로 랜덤값을 생성하여 만든다.\r\n* **DHE**\r\n  * 암호학 적으로 안전한 난수 생성기로 -1~(p-1) 사이의 랜덤한 큰 정수로 **개인키 A**를 만든다.\r\n  * g^A mod p(g: 생성자, p: 소수, A: 개인키)로 **공개키**를 만든다.\r\n* **ECDHE**\r\n  * 암호학 적으로 안전한 난수 생성기로 1~(곡선차수-1) 사이의 랜덤한 큰 정수로 **개인키**를 만든다.\r\n  * 타원 곡선(EC)의 기준점(Generator Point)에 개인키를 [스칼라]() 곱셈하여 새로운 포인트 좌표(**공개키**)를 만든다.\r\n\r\n각 키 교환 알고리즘 별 생성된 정보는 `Client Key Exchange` 메세지에 담겨 서버로 전송된다.\r\n\r\n>RSA의 경우 `Premaster Secret`을 생성후 서버 인증서의 공개키로 암호화 하여 `Client Key Exchange` 메세지에 담아 전송한다.\r\n: { \"type\": \"tip\", \"icon\": \"lightbulb\" }\r\n\r\n**RSA**는 서버로 암호화 된 `Premaster Secret`을 전송하였다. 이는 서버에서 자신의 개인키로 복호화하여 `Premaster Secret`을 얻을수 있지만,\r\n**DHE**, **ECDHE**는 서버의 공개키와 전달받은 클라이언트의 공개키로 `Premaster Secret`을 생성한다.\r\n\r\n\r\n![서버와 클라이언트의 공개키로 Premaster Secret을 만든다.](/post/network/https/hilarious-process-from-making-premaster-secret.png)\r\n:{ \"align\": \"center\", \"max-width\": \"400px\", \"description\": \"서버와 클라이언트의 공개키로 Premaster Secret을 만든다.\" }\r\n\r\n#### 4.5 Sesion Key 생성::session-key-generation\r\n\r\n`Client Key Exchange`메세지까지 전송했다면, 양측 모두 `Premaster Secret`을 가지고 있다.\r\n이제 이 값을 이용하여, `Master Secret`을 생성하고, `Master Secret`을 이용하여 `Session Key`를 생성한다.\r\n\r\n**Master Secret**은 **PRF**(Pseudo Random Function)를 이용하여 `Master secret = PRF(Premaster Secret, \"master secret\", ClientHello.random + ServerHello.random)`로 생성한다.\r\n\r\n이렇게 생성된 `Master Secret`에서는 Cipher Suite에 따라 여러가지 값을 추출할 수 있다.\r\n \r\n* **Client Write MAC Key**: 클라이언트가 서버로 보내는 메세지를 MAC(Message Authentication Code)하기 위한 키\r\n* **Server Write MAC Key**: 서버가 클라이언트로 보내는 메세지를 MAC하기 위한 키\r\n* **Client Write Key**: 클라이언트가 서버로 보내는 메세지를 암호화하기 위한 키\r\n* **Server Write Key**: 서버가 클라이언트로 보내는 메세지를 암호화하기 위한 키\r\n* **Client Write IV**: 클라이언트가 서버로 보내는 메세지를 암호화하기 위한 초기화 벡터\r\n* **Server Write IV**: 서버가 클라이언트로 보내는 메세지를 암호화하기 위한 초기화 벡\r\n\r\n이중 실제 메세지를 암·복호화 하는데 사용되는 키를 세션키라 부른다.\r\n**클라이언트**는 **Client Write Key**로 암호화, **Server Write Key**로 복호화를 하며,\r\n**서버**는 **Server Write Key**로 암호화, **Client Write Key**로 복호화를 한다.\r\n\r\n>클라이언트와 서버는 메세지를 암·복호화 하기 위한 준비를 마쳤다. 이제부터는 암호화된 메세지를 주고 받을 수 있다.\r\n: { \"type\": \"note\", \"icon\": \"info\" }\r\n\r\n\r\n### 5. Change Cipher Spec and Finished::change-cipher-spec-and-finished\r\n\r\n![Change Cipher Spec과 and Finished](/post/network/https/change-cipher-spec-and-finished.png)\r\n:{ \"align\": \"center\", \"max-width\": \"600px\", \"description\": \"Change Cipher과 and Finished\" }\r\n\r\n`Change Cipher Spec` 메세지는 클라이언트와 서버가 암호화된 메세지를 주고 받을 준비가 되었음을 알리는 메세지이다.\r\n이 메세지 이후 각장치는 `Finished`로 첫 암호화 메세지를 전송한다.\r\n\r\n>Finished 메세지까지 보낸다면 TLS 핸드쉐이크가 완료된다.\r\n: { \"type\": \"tip\", \"icon\": \"check-circle\" }\r\n"
  },
  {
    "path": "/docs/algorithm/heap-sort",
    "header": {
      "layout": "post",
      "title": "힙 정렬 (Heap Sort)",
      "tags": [
        "Java",
        "Algorithm",
        "Sort",
        "Heap Sort",
        "Heap"
      ],
      "date": 1653482640000,
      "profile-image": "/post/profile/profile4.jpg",
      "thumbnail": "/post/algorithm/heap-sort/sort-8.svg",
      "current-company": "Herit Corporation",
      "current-position": "Backend Server Developer",
      "summary": "힙 정렬",
      "expose-images": true,
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "알고리즘"
      ],
      "images": [
        {
          "src": "/post/algorithm/heap-sort/sort-1.svg",
          "alt": "가장 우선순위가 높은 값을 뒤로 이동시키고 다시 루트노드부터 힙을 만든다. 이 때 노드의 범위에서 정렬된 개수 만큼만 제외한다."
        },
        {
          "src": "/post/algorithm/heap-sort/sort-2.svg",
          "alt": "두번째도 동일하게 루트를 뒤로 보내고 다시 힙을 만든다."
        },
        {
          "src": "/post/algorithm/heap-sort/sort-3.svg",
          "alt": "이 과정에서 제외된 범위는 오름차순으로 점점 정렬되는 것을 볼 수 있다."
        },
        {
          "src": "/post/algorithm/heap-sort/sort-4.svg",
          "alt": "정렬되는 요소가 많을 수 록 힙을 만드들기 위해 탐색하는 시간 또한 줄어든다."
        },
        {
          "src": "/post/algorithm/heap-sort/sort-5.svg",
          "alt": "각 요소마다 정렬되는 시간이 logN이기 때문이다."
        },
        {
          "src": "/post/algorithm/heap-sort/sort-6.svg",
          "alt": ""
        },
        {
          "src": "/post/algorithm/heap-sort/sort-7.svg",
          "alt": ""
        },
        {
          "src": "/post/algorithm/heap-sort/sort-8.svg",
          "alt": "마지막 요소까지 정렬"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 3,
            "origin": "Heap을 이용해 정렬을 하는 방법::how-to-sort-by-heap",
            "title": "Heap을 이용해 정렬을 하는 방법",
            "fragment": "how-to-sort-by-heap",
            "children": []
          },
          {
            "rank": 2,
            "origin": "구현 코드 (Java)::implementation-code",
            "title": "구현 코드 (Java)",
            "fragment": "implementation-code",
            "children": []
          }
        ]
      }
    },
    "description": "이전에 학습 했던 우선순위큐 \"heap\"으로 간단히 정렬을 구현 해보자.",
    "content": "\r\n### Heap을 이용해 정렬을 하는 방법::how-to-sort-by-heap\r\n\r\n힙 정렬을 위해서는 사전에 완전 이진 트리를 힙으로 만들고, 정렬을 수행할 수 있습니다.\r\n위에서 만든 힙을 통해 정렬을 하는 방법을 구현합니다.  \r\n힙 정렬은 간단하게, 아래의 정렬하는 순서를 가지고있습니다.\r\n\r\n1. 최상위 노드 `A`와 가장 끝의 노드 `B`를 바꾼다.\r\n2. 바꿔진 A는 맨뒤로 가며,힙에서 제외한다. \r\n3. 바꾼 값 `B`는, 자신의 자식이 있다면, 두개를 비교하여 가장 큰 값과 맞 바꾼다.\r\n4. `3.`의 내용을 힙이될때까지 반복한다.\r\n\r\n정렬을 할 때는 Heap의 우선값을 이용해 진행하기 때문에 `최대 힙` 으로는 오름차순 정렬, `최소 힙`으로는 내림차순 정렬을 할 수 있다.\r\n\r\n::image-group\r\n\r\n![가장 우선순위가 높은 값을 뒤로 이동시키고 다시 루트노드부터 힙을 만든다. 이 때 노드의 범위에서 정렬된 개수 만큼만 제외한다.](/post/algorithm/heap-sort/sort-1.svg)\r\n\r\n![두번째도 동일하게 루트를 뒤로 보내고 다시 힙을 만든다.](/post/algorithm/heap-sort/sort-2.svg)\r\n\r\n![이 과정에서 제외된 범위는 오름차순으로 점점 정렬되는 것을 볼 수 있다.](/post/algorithm/heap-sort/sort-3.svg)\r\n\r\n![정렬되는 요소가 많을 수 록 힙을 만드들기 위해 탐색하는 시간 또한 줄어든다.](/post/algorithm/heap-sort/sort-4.svg)\r\n\r\n![각 요소마다 정렬되는 시간이 logN이기 때문이다.](/post/algorithm/heap-sort/sort-5.svg)\r\n\r\n![](/post/algorithm/heap-sort/sort-6.svg)\r\n\r\n![](/post/algorithm/heap-sort/sort-7.svg)\r\n\r\n![마지막 요소까지 정렬](/post/algorithm/heap-sort/sort-8.svg)\r\n\r\n::\r\n\r\n\r\n## 구현 코드 (Java)::implementation-code\r\n\r\n::code-group\r\n```java::노드 비교\r\n//== 노드와 그 자식중에서 더큰(또는 작은) 위치를 찾는 메소드 ==//\r\npublic static int findLargest(int arr[], int node, int eh) {\r\n    // first child\r\n    int fc = (2 * (node + 1)) - 1;\r\n\r\n    if (fc + 1 < eh) {\r\n        if (arr[fc] <= arr[fc + 1]) {\r\n            return arr[fc + 1] <= arr[node] ? node : fc + 1;\r\n        } else {\r\n            return arr[fc] <= arr[node] ? node : fc;\r\n        }\r\n    }\r\n    if (fc < eh && arr[node] < arr[fc]) {\r\n        return fc;\r\n    } else {\r\n        return node;\r\n    }\r\n}\r\n```\r\n```java::값 교환\r\n//== 값을 아래로 내리는 메소드 ==//\r\n/**\r\n * 간단하게 보면 트리에서 마지막 힙의 위치를 구하고,\r\n * 루트 노드까지 역순으로 힙을 만들어갑니다.\r\n * \r\n * 최대 힙(또는 최소 힙)의 조건에 따라 더큰(또는 더 작은)값을 기준으로,\r\n * 해당 노드를 위로올리고 변경된 대상은 아래로 내려가며 계속 바꿉니다.\r\n */\r\npublic static void pushDown(int arr[], int node, int eh) {\r\n    do {\r\n        System.out.println(\"j: \" + node);\r\n        int temp = arr[node];\r\n        int large = findLargest(arr, node, eh);\r\n        System.out.println(drawBinaryTree(arr));\r\n\r\n        if (large == node)\r\n            break;\r\n\r\n        arr[node] = arr[large];\r\n        arr[large] = temp;\r\n\r\n        node = large;\r\n    } while (node <= eh);\r\n}\r\n```\r\n\r\n```java::정렬\r\npublic static void sort(int heap[]) {\r\n    int last = arr.length;\r\n    makeHeap(arr);\r\n\r\n    while (--last >= 0) {\r\n\r\n        int temp = arr[0];\r\n        arr[0] = arr[last];\r\n        arr[last] = temp;\r\n\r\n        System.out.println(\"last: \" + last);\r\n        pushDown(arr, 0, last);\r\n    }\r\n    ;\r\n}\r\n```\r\n\r\n```java::출력 메소드\r\npublic static String drawBinaryTree(int arr[]) {\r\n    StringBuilder builder = new StringBuilder();\r\n\r\n    int nol = (int) (Math.log(arr.length) / Math.log(2)) + 1;\r\n    int max = (int) Math.pow(2, nol - 1);\r\n\r\n    int printed = 0;\r\n    for (int i = 0; i < nol; i++) {\r\n        int perFloor = (int) Math.pow(2, i);\r\n        int tab = (max - perFloor) / 2 + (max - perFloor) % 2;\r\n        int last = printed + perFloor;\r\n\r\n        for (int j = 0; j < tab; j++) {\r\n            builder.append(\"  \");\r\n        }\r\n        for (int j = printed; (j < arr.length && j < last); j++) {\r\n            builder.append(String.format(\"(%d)\", arr[j]));\r\n        }\r\n        builder.append(\"\\n\");\r\n        printed += perFloor;\r\n    }\r\n\r\n    return builder.toString();\r\n}\r\n```\r\n\r\n::\r\n\r\n```java::메인 함수\r\npublic static void sort(int [] heap) throws Exception {\r\n    Heap.sort(arr);\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n"
  },
  {
    "path": "/docs/data-structure/heap",
    "header": {
      "layout": "post",
      "title": "힙 (Heap)",
      "tags": [
        "Java",
        "Data Structure",
        "Sort",
        "Heap Sort",
        "Heap"
      ],
      "date": 1651837980000,
      "profile-image": "/post/profile/profile4.jpg",
      "thumbnail": "/post/data-structure/heap/index.svg",
      "current-company": "Herit Corporation",
      "current-position": "Backend Server Developer",
      "summary": "힙",
      "expose-images": true,
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "자료구조"
      ],
      "images": [
        {
          "src": "/post/data-structure/heap/tree-images.svg",
          "alt": "위 트리중 어떤것이 힙일까?"
        },
        {
          "src": "/post/data-structure/heap/first-iteration.svg",
          "alt": "힙을 만드려면 완전 이진트리가 있어야 한다."
        },
        {
          "src": "/post/data-structure/heap/other-iteration.svg",
          "alt": "만약 마지막 내부노드부터 순회할 때, 쵀대힙을 만드려면 위와 같이 만들수 있어요."
        },
        {
          "src": "/post/data-structure/heap/last-iteration.svg",
          "alt": "최대힙을 만들어 이런 형태로 노드를 나눌수 있어요."
        },
        {
          "src": "/post/data-structure/heap/add-new-17.svg",
          "alt": "만약 다음의 힙에서 17이라는 값이 추가 된다면"
        },
        {
          "src": "/post/data-structure/heap/add-new-17-2.svg",
          "alt": "이런식으로 부모노드와 바꿔가며, 다시 힙을 유지할 수 있어요."
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "설명::intro",
            "title": "설명",
            "fragment": "intro",
            "children": [
              {
                "rank": 3,
                "origin": "Heap의 속성 (성질)::temper",
                "title": "Heap의 속성 (성질)",
                "fragment": "temper",
                "children": []
              },
              {
                "rank": 3,
                "origin": "Heap을 만드는 방법::how-to-make-heap",
                "title": "Heap을 만드는 방법",
                "fragment": "how-to-make-heap",
                "children": []
              },
              {
                "rank": 3,
                "origin": "Heap이 우선 값을 유지하는 방법::how-to-keeping-priority-value",
                "title": "Heap이 우선 값을 유지하는 방법",
                "fragment": "how-to-keeping-priority-value",
                "children": []
              }
            ]
          },
          {
            "rank": 2,
            "origin": "구현 코드 (Java)::implementation-code",
            "title": "구현 코드 (Java)",
            "fragment": "implementation-code",
            "children": []
          }
        ]
      }
    },
    "description": "\"heap\"이라는 단어는 원래 영어에서 \"쌓아올린 더미\"또는 \"무질서하게 쌓아올린 것\"을 의미한다.\r\n\r\n데이터 구조로서 Heap이라는 이름이 붙게 된 것은 1964년 J.W.J. Williams가 발표한 논문에서 처음 사용되었다.\r\n\r\n윌리엄즈는 이진트리를 배열로 표현하면서 부모-자식 관계가 마치 더미(heap)처럼 쌓여 있는 모양이라고 표현하였다.",
    "content": "\r\n\r\n## 설명::intro\r\n\r\n간단하게 말하여, 힙은 우선순위 큐 입니다. `JAVA`에서는 `PriorityQueue`라는 구현체를 통해 Heap 자료구조를 사용할 수 있어요.\r\n힙은 두 종류가 있는데 `최대 힙`과 `최소 힙`이 있어요.\r\n최대 Heap(최소 Heap)은 단어와 같이 최대 값(최소 값)을 우선순위로 판단하여, 어떠한 값이 들어와도, 항상 같은 순서의\r\n트리를 유지하며, 언제든지 최고 우선순위의 값을 적은 비용으로 쉽게 얻을수 있는 자료구조 입니다.\r\n\r\n### Heap의 속성 (성질)::temper\r\n\r\n* 최대 힙(**또는 최소 힙**)은 `잎(leaf)`의 계층을 제외한 모든 노드는 자식의 노드 보다 큰(**또는 작은**) 값을 가지고 있어야합니다.\r\n* 왼쪽부터 차례대로 채워져있는 `완전 이진 트리(Complete binary tree)`이어야 합니다.\r\n* 같은 계층의 노드들과는 정렬하지 않습니다.\r\n* 루트(뿌리)노드로 부터 내려오는 위치의 노드들 오름차순(**또는 내림차순**)입니다\r\n\r\n![위 트리중 어떤것이 힙일까?](/post/data-structure/heap/tree-images.svg)\r\n\r\n* 트리 A: 잎을 제외한 노드는 모두 정렬되었지만, 왼쪽부터 채워지지않아 Heap이 아닙니다.\r\n* 트리 B: 왼쪽부터 채워졌지만, 2번노드의 값은 그 자식에값보다 작습니다. 따라서 Heap이 아닙니다.\r\n* 트리 C: 잎을 제외한 모든 노드가 자식 또는 부모와 정렬 되어있고, 왼쪽부터 채워져있으므로 `Heap`입니다.\r\n\r\n> 이를 정리하면 아래와 같습니다.   \r\n> 1.`𝑛개`의 노드를 가진 힙은 정확히 하나만 있고 그 힙(트리)의 높이(height)는 `⎣log₂𝑛⎦`이다. 트리의 전체 노드의 개수가 `8`일경우 트리(힙)의 높이는 `3`이다. 즉 힢의 높이는 힙의 성질(속성)에 부합되는 노드들만 인정이 된다는 의미이다.  \r\n> 2.힙의 루트 노드는 항상 최댓값(**또는 최솟값**)을 저장한다. 최대 힙(**또는 최소 힙**)은 쵀댓값(**또는 최솟값**)을 효율적으로 관리하기 위한 자료구조이며, 루트에는 항상 가장 큰(**또는 작은**)값을 유지한다.  \r\n> 3.힙의 한 노드와 그 노드의 자손 노드들로 이루어진 부분 트리(subtree)도 힙이다. 힙은 힙으로 이루어져있으며 자식노드도 힙이 될수있지만, 노드의 자식이없다면 힙이될 수없다. 따라서 위 C 트리의 `4, 5, 6`번 노드는 힙이 아니다.  \r\n:{ \"type\": \"note\", \"icon\": \"info\" }\r\n\r\n### Heap을 만드는 방법::how-to-make-heap\r\n\r\n힙을 구성 하기 위해서는 다음의 순서대로 진행됩니다.\r\n\r\n1. 순회를 시작할 힙이되는 마지막 노드`⎣𝑛/₂⎦`를 찾는다.\r\n2. 마지막 노드 i를 이용해 자식노드가 있는지, 또한 있다면 그 중 자신 보다 큰값을 자신과 찾는다.\r\n3. 찾은 값과 자신을 바꾸고 바꾼 자신의 위치는 그값의 자식이 되며, 자신보다 큰값이 나오지 않을때까지 반복한다.\r\n4. 다음 노드(i -1)에서 다시 `3.`을 반복한다.\r\n\r\n> 자식 노드의 위치를 찾을때는 왼쪽`arr[2i]`값과 오른쪽`arr[2i + 1]`로 구할 수 있습니다.\r\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\" }\r\n\r\n위 의 내용을 정리하면 아래와 같습니다.\r\n\r\n\r\n![힙을 만드려면 완전 이진트리가 있어야 한다.](/post/data-structure/heap/first-iteration.svg)\r\n\r\n> 위의 트리는 *완전 이진트리* 입니다. 힙은 완전이진트리에서 만들수 있으므로, 일반 이진트리는 Compact하게 완전이진트리로 바꿔야 힙을 만들수 있습니다.\r\n> 왼쪽 트리의 마지막 힙의 값은 `15` 이며, 이는 자식(`6, 4`) 어느것 보다도 큰값입니다. 따라서 다음 순회로 넘어갑니다.\r\n> 순회는 내부 노드의 마지막 힙의 위치에서 부터 1까지 이어집니다. 따라서 다음 인덱스인 3번 노드(9)로 넘어갑니다.\r\n> 3번노드는 자신의 자식들 중 6번째, 7번째 (7, 12)와 비교하여 더 큰값을 가지는 12와 바꿉니다.\r\n:{ \"type\": \"note\", \"icon\": \"info\" }\r\n\r\n![만약 마지막 내부노드부터 순회할 때, 쵀대힙을 만드려면 위와 같이 만들수 있어요.](/post/data-structure/heap/other-iteration.svg)\r\n\r\n> 이후 과정은 위와 같이 반복됩니다. 내부노드를 순회하며 자신의 자식노드가 있는지 확인하고 있다면, 자신과 비교하여 더큰 값으로 바꿉니다. 이는 바꾼이후에도 `3.`이 반복되게 됩니다. 순회되는 노드가 최상위노드가 되고 모든 내부노드가 힙이 될때, 전체 트리는 힙이 됩니다.   \r\n> 마지막까지 바꾼 최종트리는 아래와 같습니다.\r\n:{ \"type\": \"note\", \"icon\": \"info\" }\r\n\r\n![최대힙을 만들어 이런 형태로 노드를 나눌수 있어요.](/post/data-structure/heap/last-iteration.svg)\r\n\r\n* 최상위 노드(루트)가 가장 큰값이 되며, 위는 최대힙을 만드는 단계였습니다.\r\n* 부모노드와 자식노드끼리는 순서의 값을 가지며, 항상 최대의 값을 가집니다.\r\n\r\n### Heap이 우선 값을 유지하는 방법::how-to-keeping-priority-value\r\n\r\n위에서는 완전이진트리로 힙을 어떻게 만드는지에 대해 알아봤습니다.\r\n하지만, 힙은 언제나 새로운값이 들어와도 항상 우선 순위로 값을 관리합니다. 만약 저기서 더큰값이 추가된다면,\r\n저 힙트리는 어떻게 바뀔까요? 새로운 값들을 추가해서 힙이 다시 어떻게 유지되는지 배워봅니다.\r\n\r\n#### 값 추가::add-new-value\r\n\r\n힙트리에서 값을 추가 할때는 마지막 노드로 붙여주고 위에서 했던것과 동일하게 힙을 만들어 줍니다.\r\n만약 새로운 값 17이 힙에 들어온다면 순서는 아래와 같이 바뀝니다.\r\n\r\n::image-group\r\n\r\n![만약 다음의 힙에서 17이라는 값이 추가 된다면](/post/data-structure/heap/add-new-17.svg)\r\n\r\n![이런식으로 부모노드와 바꿔가며, 다시 힙을 유지할 수 있어요.](/post/data-structure/heap/add-new-17-2.svg)\r\n\r\n::\r\n\r\n\r\n> A: 새로 들어온 값 17은 트리의 맨뒤인 10번노드로 들어갑니다.     \r\n> 또한 마지막 내부노드이자 자신의 부모인 5번 노드(4)부터 다시 순회를 시작하며,  \r\n> 자신보다 큰 값은 가진 자식 10번 노드(17)과 값을 바꿉니다.\r\n> B: 값이 바뀐 10번 노드(4)는 자식을 가지고있지 않으므로 다음 순회로 넘어갑니다.  \r\n> C: 다음 순회인 4번 노드(6)은 자식들보다 큰값이므로 다음 3번 노드(12)로 이동합니다. 하지만 이또한 자식들보다 값이 크므로, 2번 노드(8)로 이동합니다. 자신보다 큰값을 가지는 5번 자식노드(17)과 바꿉니다.  \r\n> D: 값이 바뀐 5번 노드(8)은 자식들 보다 값이 커, 바꿀 필요가 없으므로 다음 순회인 1번 노드(15)로 이동합니다.  \r\n> E: 현재 순회인 1번 노드(15)는 자신의 2번 노드(17)보다 값이 작으므로 바꿉니다.  \r\n> F: 최종적으로 힙이 완성되었습니다.\r\n:{ \"type\": \"tip\", \"icon\": \"check-circle\" }\r\n\r\n## 구현 코드 (Java)::implementation-code\r\n\r\n::code-group\r\n\r\n```java::힙 만들기\r\n//== 힙(Heap) 을 만드는 메소드 ==//\r\npublic static void makeHeap(int arr[]) {\r\n    // last heap\r\n    int lh = arr.length / 2;\r\n    System.out.println(\"Normal Array = \" + Arrays.toString(arr));\r\n    int eh = arr.length;\r\n    while (lh-- > 0) {\r\n\r\n        System.out.println(\"i: \" + lh);\r\n        pushDown(arr, lh, eh);\r\n    }\r\n\r\n    System.out.println(\"Array as Max Heap = \" + Arrays.toString(arr));\r\n}\r\n```\r\n\r\n```java::노드 비교\r\n//== 노드와 그 자식중에서 더큰(또는 작은) 위치를 찾는 메소드 ==//\r\npublic static int findLargest(int arr[], int node, int eh) {\r\n    // first child\r\n    int fc = (2 * (node + 1)) - 1;\r\n\r\n    if (fc + 1 < eh) {\r\n        if (arr[fc] <= arr[fc + 1]) {\r\n            return arr[fc + 1] <= arr[node] ? node : fc + 1;\r\n        } else {\r\n            return arr[fc] <= arr[node] ? node : fc;\r\n        }\r\n    }\r\n    if (fc < eh && arr[node] < arr[fc]) {\r\n        return fc;\r\n    } else {\r\n        return node;\r\n    }\r\n}\r\n```\r\n\r\n```java::값 교환\r\n//== 값을 아래로 내리는 메소드 ==//\r\n/**\r\n * 간단하게 보면 트리에서 마지막 힙의 위치를 구하고,\r\n * 루트 노드까지 역순으로 힙을 만들어갑니다.\r\n * \r\n * 최대 힙(또는 최소 힙)의 조건에 따라 더큰(또는 더 작은)값을 기준으로,\r\n * 해당 노드를 위로올리고 변경된 대상은 아래로 내려가며 계속 바꿉니다.\r\n */\r\npublic static void pushDown(int arr[], int node, int eh) {\r\n    do {\r\n        System.out.println(\"j: \" + node);\r\n        int temp = arr[node];\r\n        int large = findLargest(arr, node, eh);\r\n        System.out.println(drawBinaryTree(arr));\r\n\r\n        if (large == node)\r\n            break;\r\n\r\n        arr[node] = arr[large];\r\n        arr[large] = temp;\r\n\r\n        node = large;\r\n    } while (node <= eh);\r\n}\r\n```\r\n\r\n```java::출력 메소드\r\npublic static String drawBinaryTree(int arr[]) {\r\n    StringBuilder builder = new StringBuilder();\r\n\r\n    int nol = (int) (Math.log(arr.length) / Math.log(2)) + 1;\r\n    int max = (int) Math.pow(2, nol - 1);\r\n\r\n    int printed = 0;\r\n    for (int i = 0; i < nol; i++) {\r\n        int perFloor = (int) Math.pow(2, i);\r\n        int tab = (max - perFloor) / 2 + (max - perFloor) % 2;\r\n        int last = printed + perFloor;\r\n\r\n        for (int j = 0; j < tab; j++) {\r\n            builder.append(\"  \");\r\n        }\r\n        for (int j = printed; (j < arr.length && j < last); j++) {\r\n            builder.append(String.format(\"(%d)\", arr[j]));\r\n        }\r\n        builder.append(\"\\n\");\r\n        printed += perFloor;\r\n    }\r\n\r\n    return builder.toString();\r\n}\r\n```\r\n\r\n::\r\n\r\n```java::메인 함수\r\npublic static void main(String args []) throws Exception {\r\n    //== 힙 으로 만들기==//\r\n    int array [] = {1, 5, 8, 2, 74, 9, 12, 104, 87, 43};\r\n    Heap.makeHeap(array);\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n"
  },
  {
    "path": "/docs/language/cpp/cpp-convention",
    "header": {
      "layout": "post",
      "title": "c++ 시작하기",
      "tags": [
        "Language",
        "C++",
        "C"
      ],
      "date": 1644221400000,
      "profile-image": "/post/profile/profile4.jpg",
      "thumbnail": "/post/language/cpp/cpp-grammar.png",
      "current-company": "Herit Corporation",
      "current-position": "Backend Server Developer",
      "excerpt-separator": "<!--more-->",
      "summary": "C++ 문법",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "언어",
        "C++"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "문법::grammar",
            "title": "문법",
            "fragment": "grammar",
            "children": [
              {
                "rank": 3,
                "origin": "주요 연산자::operators",
                "title": "주요 연산자",
                "fragment": "operators",
                "children": []
              }
            ]
          },
          {
            "rank": 2,
            "origin": "명명규칙::naming-convention",
            "title": "명명규칙",
            "fragment": "naming-convention",
            "children": []
          }
        ]
      }
    },
    "description": "C++의 기본 문법을 배워보자",
    "content": "\r\n## 문법::grammar\r\n\r\n### 주요 연산자::operators\r\n\r\n**포인터 선언**\r\n```cpp\r\nint* num = new int[5];\r\nint* not_init;\r\n\r\nint new_num = 10;\r\nint* ptr = &new_num;\r\n\r\nint lazy = 512;\r\n*ptr = 20; //ptr이 가리키는 주소에 20 저장\r\nptr = &lazy; //ptr이 lazy의 주소를 가리킴\r\n```\r\n포인터 변수의 특징\r\n* 초기화 필수 아님\r\n* null 값 불가능\r\n* 다른변수나 주소로 재할당 가능\r\n* 더 복잡한 메모리 조작 가능\r\n* 주소 연산 및 포인터 연산 가능\r\n\r\n**참조 선언**\r\n```cpp\r\nint num = 10;\r\nint& a = num; // 참조 연산자, num의 값을 a에 저장\r\n```\r\n참조 변수의 특징\r\n* 선언시 반드시 초기화 해야함\r\n* null 참조 불가능\r\n* 재할당 불가능 (한 번 참조한 변수 고정)\r\n* 문법적으로 더 간결하고 안전\r\n* 원본 변수에 투명하게 접근 가능\r\n\r\n**주소 연산자**\r\n```cpp\r\nint num = 10;\r\n\r\n//int 인트에 대한 포인터 변수\r\nint* a = &num; // 주소 연산자, num의 주소를 a에 저장\r\n```\r\n주소 연산자의 결과는 변수에대한 물리주소기 때문에 컴퓨터 bit 체계의 따른 메모리크기를 부여받는다.  \r\n주소 정보이기 때문에 포인터 변수에만 담을 수 있다.\r\n\r\n\r\n## 명명규칙::naming-convention\r\n\r\n**파일명**:\r\n- 소스 파일: `.cpp`\r\n- 헤더 파일: `.h` 또는 `.hpp`\r\n- 파일명은 snake_case 또는 PascalCase 사용\r\n    - 예: `user_interface.cpp`, `UserInterface.cpp`\r\n\r\n**클래스/구조체**:\r\n- PascalCase 사용\r\n- 예: `class UserManager`, `struct PlayerData`\r\n\r\n**함수/메서드**:\r\n- camelCase 또는 snake_case\r\n- 예: `void getUserInput()` 또는 `void get_user_input()`\r\n\r\n**변수**:\r\n- camelCase 또는 snake_case\r\n- 예: `int playerScore` 또는 `int player_score`\r\n\r\n**상수/매크로**:\r\n- SCREAMING_SNAKE_CASE\r\n- 예: `const int MAX_PLAYERS = 10`, `#define PI_VALUE 3.14159`\r\n\r\n**namespace**:\r\n- 소문자 snake_case\r\n- 예: `namespace game_engine`\r\n\r\n**프로젝트 디렉토리**:\r\n```\r\nproject_name/\r\n├── src/            (소스 파일)\r\n├── include/        (헤더 파일)\r\n├── lib/           (라이브러리)\r\n├── test/          (테스트 파일)\r\n└── docs/          (문서)\r\n```\r\n\r\n\r\n(작성중)\r\n"
  },
  {
    "path": "/docs/data-structure/b-tree",
    "header": {
      "layout": "post",
      "title": "B-tree (Balanced Tree)",
      "tags": [
        "Data Structure",
        "B-Tree"
      ],
      "date": 1641324600000,
      "profile-image": "/post/profile/profile0.jpg",
      "thumbnail": "/post/data-structure/b-tree/index.png",
      "current-company": "Herit Corporation",
      "current-position": "Backend Server Developer",
      "summary": "B-tree",
      "expose-images": true,
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "자료구조"
      ],
      "images": [
        {
          "src": "/post/data-structure/b-tree/index.png",
          "alt": "B-tree"
        },
        {
          "src": "/post/data-structure/b-tree/node-of-b-tree.png",
          "alt": "B-tree의 노드"
        },
        {
          "src": "/post/data-structure/b-tree/b-tree-node-search.png",
          "alt": "B-tree 노드 내 검색"
        },
        {
          "src": "/post/data-structure/b-tree/b-tree-search-1.png",
          "alt": "루트 노드에서 각 키들과 비교하여 이동할 자식노드의 포인터를 찾는다."
        },
        {
          "src": "/post/data-structure/b-tree/b-tree-search-2.png",
          "alt": "접근한 자식노드에서도 동일하게 포인터를 찾는다."
        },
        {
          "src": "/post/data-structure/b-tree/b-tree-search-3.png",
          "alt": "리프노드에서 탐색하는 키들중 검색값을 찾는다."
        },
        {
          "src": "/post/data-structure/b-tree/b-tree-add-1.png",
          "alt": "값 11이 추가 되면, 루트 노드에서 비교하여 끝 포인터를 찾아 자식 노드로 이동한다."
        },
        {
          "src": "/post/data-structure/b-tree/b-tree-add-2.png",
          "alt": "리프노드까지 이동하여 삽입 위치를 찾았으므로 해당 위치에 삽입된다."
        },
        {
          "src": "/post/data-structure/b-tree/b-tree-add-3.png",
          "alt": "값 12가 추가 되면 이전과 동일하게 이동할 포인터를 찾는다."
        },
        {
          "src": "/post/data-structure/b-tree/b-tree-add-4.png",
          "alt": "삽입 위치를 찾았지만 12가 삽입되면 최대 키 개수 위반이므로 노드를 분할한다."
        },
        {
          "src": "/post/data-structure/b-tree/condition-of-redistribution-in-b-tree.png",
          "alt": "재분배는 형제 노드중 키의 개수가 여유 있을 때만 가능하다."
        },
        {
          "src": "/post/data-structure/b-tree/redistribution-in-key-deletions-1.png",
          "alt": "키삭제 이후 Node 3에서 최소 키 개수 규칙 위배"
        },
        {
          "src": "/post/data-structure/b-tree/redistribution-in-key-deletions-2.png",
          "alt": "부모 노드의 키를 가져와 노드를 유지하고, 부모노드는 재분배된 키를 가져온다."
        },
        {
          "src": "/post/data-structure/b-tree/merge-in-key-deletions-1.png",
          "alt": "키를 삭제했지만, 형제 노드 중에는 여유로운 노드가 없다."
        },
        {
          "src": "/post/data-structure/b-tree/merge-in-key-deletions-2.png",
          "alt": "형제 노드를 골라 해당 형제노드와 연결되어 있는 부모키를 가져와 병합한다."
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "B-tree란?::what-is-b-tree",
            "title": "B-tree란?",
            "fragment": "what-is-b-tree",
            "children": [
              {
                "rank": 3,
                "origin": "정의::definition",
                "title": "정의",
                "fragment": "definition",
                "children": []
              }
            ]
          },
          {
            "rank": 2,
            "origin": "노드 (Node)::node",
            "title": "노드 (Node)",
            "fragment": "node",
            "children": []
          },
          {
            "rank": 2,
            "origin": "데이터 검색::search",
            "title": "데이터 검색",
            "fragment": "search",
            "children": []
          },
          {
            "rank": 2,
            "origin": "데이터 삽입::insertion",
            "title": "데이터 삽입",
            "fragment": "insertion",
            "children": []
          },
          {
            "rank": 2,
            "origin": "데이터 삭제::deletion",
            "title": "데이터 삭제",
            "fragment": "deletion",
            "children": []
          }
        ]
      }
    },
    "description": "B-tree는 Balanced Tree의 약자로 균형 트리를 의미한다.\r\nB-tree는 현재까지도 데이터베이스, 파일 시스템 등 다양한 분야에서 사용되는 자료구조이다.",
    "content": "\r\n## B-tree란?::what-is-b-tree\r\n\r\n![B-tree](/post/data-structure/b-tree/index.png)\r\n:{ \"description\": \"B-tree 자료구조\" }\r\n\r\n**B-tree**는 Balanced Tree의 약자로 정렬된 데이터를 관리하고 `Log` 시간에서 검색, 순차접근, 삽입, 삭제가 가능한 자가균형 트리 자료구조이다.\r\n대용량 데이터를 다룰 때 사용되며 데이터 베이스, 파일 시스템 등 다양한 분야에서 사용된다.\r\n\r\n`B-tree`는 차수(`Degree`)를 가지며 이 값에 따라 구성 정보가 다음과 같이 달라진다:\r\n\r\n*degree: 4인 경우*\r\n\r\n* 최대 자식 수: 4\r\n* 최소 자식 수: (4 + 1) / 2 = 2\r\n* 최대 키 개수: 4 - 1 = 3\r\n\r\n>B-tree는 차수(m)에 따라 log~m~N의 시간 복잡도를 가진다.\r\n:{ \"type\": \"important\", \"icon\": \"warning-octagon\" }\r\n\r\n### 정의::definition\r\n\r\nKnuth 정리에 따라, *m* 차 B-tree는 다음의 속성을 만족하는 트리이다.\r\n\r\n1. 각 노드는 최대 *m* 개의 자식을 갖는다.\r\n2. 루트와 리프 노드를 제외한 각 노드는 최소 *⌈m/2⌉* 개의 자식을 갖는다.\r\n3. 루트노드는 리프노드가 아닌한 최소 두개의 자식노드를 갖는다.\r\n4. 모든 리프노드는 동일한 레벨에 존재한다.\r\n5. *k* 개의 자식노드를 가지는 노드는 *k-1* 개의 키를 가진다.\r\n\r\n각 내부 노드의 키는 서브트리를 구분하는 분리값으로 작용한다. 예를들어 내부 노드가 3개의 자식노드를 갖고 있다면, 2개의 키를 가지고 있어야만 한다:  *a~1~* 와 *a~2~*.  \r\n좌측 서브트리의 모든 값은 *a~1~* 보다 작고, 중앙 서브트리의 모든 값은 *a~1~* 와 *a~2~* 사이에 있으며, 우측 서브트리의 모든 값은 *a~2~* 보다 크다.\r\n\r\n**내부 노드**\r\n\r\n내부 노드는 루트노드와 리프노드를 제외한 모든 노드이다. 이는 일반적으로 자식 포인터와 키의 집합으로 정렬 돠어 표현된다. \r\n각 내부 노드는 **최대** *U* 개, **최소** *L* 개의 자식노드를 포함한다. 따라서, 키의 개수는 항상 자식노드(*L*-1 에서 *U*-1 사이의 키 개수) 개수 -1 이다.\r\n*U* 는 2*L* 또는 2*L* - 1중에 하나여야 한다. 그러므로 각 내부 노드는 최소한 절반 이상 채워진다. *U* 와 *L* 사이의 관계는 다음을 나타낸다.\r\n\r\n* 합법노드를 만들기 위해 결합될 수 있는 반만 채워진 두개의 노드\r\n* 두개의 합법노드로 분리될 수있는 한개의 꽉찬 노드 (만약 한개의 키를 부모 노드로 삽입할수 있는 공간이 있다면)\r\n\r\n> **합법노드**란 키의 개수가 최소 이상이며 최대 이하인 노드를 말한다.\r\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\" }\r\n\r\n이러한 속성은 B-tree에 새로운 값을 추가하거나 삭제가 가능하게 만들고 B-tree 속성을 지키기 위해 트리를 조정한다.\r\n\r\n**루트 노드**\r\n* 루트노드의 자식 개수는 내부노드와 동일한 상한은 있지만, 하한은 없다. 예를들어 전체 트리에 키의 개수가 *L*-1 보다 적을 때, 루트노드는 자식노드가 없는 단일 노드인 상황이다.\r\n\r\n**리프 노드**\r\n* Knuth 용어로 \"리프\" 노드는 실제 데이터 객체 / 청크이다. 다른 저자들이 말하는 \"리프\"는 리프 노드 바로 위에있는 내부 노드에 해당:\r\n  * 이 노드 들은 키(최대 *m*-1, 루트가 아니면  최소 *m*/2 -1개)와 데이터 객체/청크를 가리키는 포인터만 저장\r\n\r\n>현대의 B-tree는 이 Knuth 정리에서 발전하였다.\r\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\" }\r\n\r\n\r\n## 노드 (Node)::node\r\n\r\n![B-tree의 노드](/post/data-structure/b-tree/node-of-b-tree.png)\r\n:{ \"align\": \"center\", \"max-width\": \"500px\", \"description\": \"B-Tree의 노드\" }\r\n\r\n노드는 자식 노드들의 포인터들과 키들로 구성된다. 이미지에서 보이는 p1, p2...pn은 자식노드 들의 포인터를 의미한다.\r\ns1, s2, s3는 키를 의미한다. 데이터를 검색할 때, 키들중에서 비교를 하고 사잇 값이라면 해당 범위의 자식노드로 이동한다.\r\n\r\n**노드의 구조**\r\n\r\n다른 트리들과 마찬가지로 B-tree도 세가지 타입의 노드들로 표현될 수 있다: *루트, 내부, 리프*.\r\n\r\n노드의 구성요소는 다음과 같다:\r\n\r\n* *K*: B-tree의 각 노드에대한 검색 키의 최대 개수. (이 값은 전체 트리에서 동일하다)\r\n* *pt~i~*: 하위트리를 시작하는 자식노드에 대한 포인터.\r\n* *pr~i~*: 데이터를 저장하는 레코드에 대한 포인터.\r\n* *k~i~*: 0부터 시작하는 노드인덱스 *i*의 검색키.\r\n\r\nB-tree에서는 노드에대해 다음의 속성들이 관리된다.\r\n\r\n* B-tree내 *k~i~*(키)가 존재한다면 *k~i-1~*는 존재. (오름 차순 정렬에 대한 균형 관리를 의미)\r\n* 모든 리프노드는 동일한 조상 노드의 개수를 가진다.(트리의 높이를 일정하게 유지하는 관리를 의미)\r\n\r\nB-tree에서 내부 노드는 다음의 형식을 갖는다:\r\n\r\n| pt~0~ | k~0~ | pt~1~ | pr~0~ | k~1~ | pt~2~ | pr~1~ | ... | k~K-1~ | pt~K~ | pr~K-1~ |\r\n|-------|------|-------|-------|------|-------|-------|------|--------|-------|---------|\r\n:{ \"align\": \"center\", \"max-width\": \"500px\", \"description\": \"내부노드 구조\", \"type\": \"filled\" }\r\n\r\n| *k~0~* 존재 시 *pt~0~*             | *k~i-1~* , *k~i~* 존재 시 *pt~i~*                 | *k~i-1~* 존재, *k~i~* 미존재 시 *pt~i~* | *k~i~* , *k~i-1~* 미존재 시 *pt~i~* | *k~i~* 존재 시 *pr~i~*       | *k~i~* 미존재 시 *pr~i~* |\r\n|---------------------------------|------------------------------------------------|-----------------------------------|---------------------------------|---------------------------|----------------------|\r\n| *k~0~* 보다 작은 키들을 가진 서브트리를 가리킨다. | *k~i-1~* 보다 크고 *k~i~* 보다 작은 키들을 가진 서브트리를 가리킨다. | *k~i-1~* 보다 큰 키들을 가진 서브트리를 가리킨다.  | 여기서 *pt~i~* 는 비어있다.             | *k~i~* 와 같은 값인 레코드를 가리킨다. | 여기서 *pt~i~* 는 비어있다.  |\r\n:{ \"type\": \"filled\" }\r\n\r\n## 데이터 검색::search\r\n\r\n![B-tree 노드 내 검색](/post/data-structure/b-tree/b-tree-node-search.png)\r\n:{ \"align\": \"center\", \"max-width\": \"300px\", \"description\": \"B-tree 노드 내 검색\" }\r\n\r\n검색은 루트 노드부터, 리프노드까지 순차적으로 이어지며 log~m~N의 시간 복잡도를 가진다.\r\n노드 내에서 비교는 항상 `중앙(중간 값)`하고만 이루어지는데, 검색 과정에 따라 중앙이 바뀐다.\r\n\r\n>중앙 인덱스는 각 인덱스의 (시작 + 끝) / 2로 계산된다.  \r\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\" }\r\n\r\n**(`시작: 0, 중앙: 1, 끝: 3`)**    \r\n위 이미지처럼 `시작: 0, 끝: 3`이라면 중앙은 `(0 + 3) / 2 = 1`이 된다. 이 공식으로 **범위가 정해질 때** 마다 중앙이 바뀐다.  \r\n중앙 값이 정해지면, 비교를 시작하고 `중앙 < 찾는 값`이라면, 시작 포인터는 `중앙 +1: 2`가 된다.\r\n\r\n>반대로 `찾는 값 < 중앙`이라면, 끝 포인터는 `중앙 -1: 1`이 된다.\r\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\" }\r\n\r\n그럼 다시 `(2 + 3) / 2 = 2`가 중앙이 되고 다시 비교한다.   \r\n**(`시작: 2, 중앙: 2, 끝: 3`)**  \r\n이때 `찾는 값 < 중앙(2)`이라면 `시작(2)`보다 작은 값이기 때문에 `44`와 `79`사이의 포인터로 다음 자식노드로 이동하고,\r\n`중앙(2) < 찾는 값` 이라면 또다시 시작 포인터를 `중앙 +1: 3`으로 이동한다.\r\n\r\n이 과정에서 만약 중앙 값과 비교할 때 같다면, 해당 값 탐색에 성공한것이다.\r\n\r\n이런 식으로 루트노드부터 검색이 이루어 지면 아래와 같이 처리된다.\r\n\r\n::image-group\r\n\r\n![루트 노드에서 각 키들과 비교하여 이동할 자식노드의 포인터를 찾는다.](/post/data-structure/b-tree/b-tree-search-1.png)\r\n\r\n![접근한 자식노드에서도 동일하게 포인터를 찾는다.](/post/data-structure/b-tree/b-tree-search-2.png)\r\n\r\n![리프노드에서 탐색하는 키들중 검색값을 찾는다.](/post/data-structure/b-tree/b-tree-search-3.png)\r\n\r\n::\r\n\r\n>투 포인터(시작, 끝)로 범위 내 이분탐색이 되려면 먼저 노드내 정렬이 되어야 한다. 이는 B-tree가  정렬을 유지하는 자가균형 트리 이기 때문에 가능하다.\r\n:{ \"type\": \"note\", \"icon\": \"info\" }\r\n\r\n## 데이터 삽입::insertion\r\n\r\n검색할 때와 마찬가지로 루트노드 붙어 리프노드까지 이동하며 삽입할 위치를 찾는다.  \r\n실제 삽입은 리프노드에서 제일 먼저 일어나며, 그 과정들을 다음에 설명한다:\r\n\r\n**일반 적인 데이터 추가**\r\n\r\n![값 11이 추가 되면, 루트 노드에서 비교하여 끝 포인터를 찾아 자식 노드로 이동한다.](/post/data-structure/b-tree/b-tree-add-1.png)\r\n:{ \"align\": \"center\", \"max-width\": \"300px\", \"description\": \"2번 포인터로 이동\" }\r\n\r\n위의 구조에서 값 11이 추가되면 루트 노드에서는 삽입 위치를 찾기위해 [검색](#search)에서 사용한 방법대로 이분탐색으로 이동할 포인터를 찾는다.\r\n\r\n![리프노드까지 이동하여 삽입 위치를 찾았으므로 해당 위치에 삽입된다.](/post/data-structure/b-tree/b-tree-add-2.png)\r\n:{ \"align\": \"center\", \"max-width\": \"300px\", \"description\": \"리프 노드까지 이동 및 삽입\" }\r\n\r\n자식노드의 포인터로 이동된 뒤, 기존의 키들과 비교하여 삽입할 위치를 찾고 **최대 키 개수**를 넘지 않았다면 그 자리로 삽입된다.\r\n\r\n**데이터 추가에 대한 노드 확장**\r\n\r\n![값 12가 추가 되면 이전과 동일하게 이동할 포인터를 찾는다.](/post/data-structure/b-tree/b-tree-add-3.png)\r\n:{ \"align\": \"center\", \"max-width\": \"300px\", \"description\": \"2번 포인터로 이동\" }\r\n\r\n값 12가 추가 되면 이전과 동일하게 이동할 포인터를 찾는다.\r\n\r\n![삽입 위치를 찾았지만 12가 삽입되면 최대 키 개수 위반이므로 노드를 분할한다.](/post/data-structure/b-tree/b-tree-add-4.png)\r\n:{ \"align\": \"center\", \"max-width\": \"300px\", \"description\": \"최대 키 개수 위반! 노드 분할\" }\r\n\r\n기존 `[8, 9, 10, 11]`에서 `12`가 추가되면 `[8 ,9, 10, 11, 12]`가 되어 **최대 키 개수**를 위반하게 된다.\r\n\r\n이 경우에는 중간 값(`10`)을 기준으로 노드를 분할하여, 중간값의 왼쪽 포인터를 `[8, 9]` 노드에 연결, 오른쪽 포인터를 `[11, 12]` 노드에 연결한다.\r\n그리고 중간 값`10`은 부모노드로 이동하여, 부모노드에서도 삽입을 시도한다.\r\n\r\n만약 부모노드에서도 최대 키 개수를 넘어가면, 부모노드도 분할하여 중간값을 부모노드로 이동하고, 부모노드의 부모노드로 이동하여 삽입을 시도한다.\r\n\r\n>일반적으로 B-tree는 런타임에 차수를 수정할수 없으므로 해당 차수의 트리가 가질수 있는 모든 키의 개수에 도달한다면, 새로운 차수의 B-tree를 생성하여 데이터를 이동시킨다.\r\n:{ \"type\": \"important\", \"icon\": \"warning-diamond\" }\r\n\r\n## 데이터 삭제::deletion\r\n\r\n앞서 설명한 m차 B-tree의 노드 규칙은 다음과 같다.\r\n\r\n* 최대 자식 수: `m`\r\n* 최소 자식 수: `m / 2`\r\n* 최대 키 개수: `m - 1`\r\n\r\n>삭제는 삽입과 조금 다르게 삭제가 될 때마다 위 규칙을 확인하며 이에 따른 재분재나 병합이 발생한다.\r\n:{ \"type\": \"important\", \"icon\": \"warning-diamond\" }\r\n\r\n제약에 걸리지 않는 다면 삭제후 별다른 조치가 없다. 데이터 삭제에 대해 처리 할수 있는 조치는 `병합`과 `재분배`가 있다.\r\n\r\n**데이터 삭제에 대한 재분배**\r\n\r\n![재분배는 형제 노드중 키의 개수가 여유 있을 때만 가능하다.](/post/data-structure/b-tree/condition-of-redistribution-in-b-tree.png)\r\n:{ \"align\": \"center\", \"max-width\": \"700px\", \"description\": \"재분배는 형제노드의 개수의 영향을 받는다.\" }\r\n\r\n키가 삭제되고 최소 키 개수 규칙에 위배 되었다면, 형제 노드에 여유가 있을 때 재분배가 가능하다.\r\n\r\n예를 첫번째 `b-tree`는 `Node 3`의 6번 키가 삭제 되더라도, `Node 4`에 키가 여유(2 < 3) 있기 때문에 재분배가 가능하다.  \r\n반대로 두번째 `b-tree`는 `Node 3`의 6번 키가 삭제 되더라도, `Node 2`와 `Node 4`에 키가 여유(2 < 2)없기 때문에 재분배가 불가능하다.\r\n\r\n>4차 b-tree라면 삭제 되는 노드의 형제노드가 최소 키 개수 2이하 라면 재분배가 불가하여 병합으로 처리된다.\r\n:{ \"type\": \"caution\", \"icon\": \"x-circle\" }\r\n\r\n만약 재분배가 가능한 조건이라면 다음과같이 처리된다.\r\n\r\n![키삭제 이후 Node 3에서 최소 키 개수 규칙 위배](/post/data-structure/b-tree/redistribution-in-key-deletions-1.png)\r\n:{ \"align\": \"center\", \"max-width\": \"700px\", \"description\": \"최소 키 개수 규칙 위배\" }\r\n\r\n위 트리에서 `6`을 삭제한다고 할 때, 삭제가 이루어지고 나서 `Node 3`는 **최소 키 개수 규칙을 위배**한다.  \r\n이 경우 `Node 4`에서 키를 하나 가져와 `Node 3`에 삽입하면 최소 키 개수 규칙을 지킬 수 있다.\r\n\r\n>Node 4에 최소 키 개수보다 1개더 키를 가지고 있기 때문에 **재분배**가 가능하다.\r\n:{ \"type\": \"tip\", \"icon\": \"check-circle\" }\r\n\r\n![부모 노드의 키를 가져와 노드를 유지하고, 부모노드는 재분배된 키를 가져온다.](/post/data-structure/b-tree/redistribution-in-key-deletions-2.png)\r\n:{ \"align\": \"center\", \"max-width\": \"700px\", \"description\": \"재분배된 키를 부모노드로 이동\" }\r\n\r\n재분배가 가능하다면 여유로운 노드(Node 4)를 가리키고 있는 포인터에 붙은 키를 자식노드로 내린다.\r\n그리고 부모노드에서는 재분배된 키를 선별하기위해 가장 작은키 (왼쪽에서 가져온다면 가장 큰 키)를 부모노드로 이동시킨다.\r\n\r\n이렇게 되면 재분배가 되어 최소 키 개수 규칙을 지킬 수 있게 된다.\r\n\r\n\r\n**데이터 삭제에 대한 병합**\r\n\r\n![키를 삭제했지만, 형제 노드 중에는 여유로운 노드가 없다.](/post/data-structure/b-tree/merge-in-key-deletions-1.png)\r\n:{ \"align\": \"center\", \"max-width\": \"700px\", \"description\": \"재배치할 키가 없음\" }\r\n\r\n위와 같은 4차 B-tree가 있을 때 `Node 3`의 6번 키를 삭제하면, `Node 3`는 Underflow가 발생한다.\r\n이때 `Node 2`와 `Node 4`는 모두 최소 키 개수만큼만 가지고 있기 때문에 재분배가 불가능하다.\r\n\r\n![형제 노드를 골라 해당 형제노드와 연결되어 있는 부모키를 가져와 병합한다.](/post/data-structure/b-tree/merge-in-key-deletions-2.png)\r\n:{ \"align\": \"center\", \"max-width\": \"700px\", \"description\": \"형제 노드와 병합\" }\r\n\r\n이런 경우에는 형제 노드를 골라 해당 형제노드와 연결되어 있는 부모키를 가져와 병합한다.\r\n\r\n>삭제될 대상이 내부 노드에 있다면 리프 노드까지 이동한 뒤에 삭제한다.\r\n:{ \"type\": \"important\", \"icon\": \"warning-diamond\" }\r\n"
  },
  {
    "path": "/docs/software-design/decorator-pattern",
    "header": {
      "layout": "post",
      "title": "데코레이터 패턴 (Decorator Pattern)",
      "tags": [
        "Visitor Pattern",
        "Design Pattern",
        "Software Design"
      ],
      "date": 1631452920000,
      "thumbnail": "/post/software-design/decorator-pattern/index.png",
      "profile-image": "/post/profile/profile4.jpg",
      "current-company": "Herit Corporation",
      "current-position": "Backend Server Developer",
      "summary": "데코레이터 패턴",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "소프트웨어 설계"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "핵심 구성요소::key-components",
            "title": "핵심 구성요소",
            "fragment": "key-components",
            "children": []
          },
          {
            "rank": 2,
            "origin": "예제::example",
            "title": "예제",
            "fragment": "example",
            "children": [
              {
                "rank": 3,
                "origin": "다양한 커피 만들기::make-various-coffee",
                "title": "다양한 커피 만들기",
                "fragment": "make-various-coffee",
                "children": []
              }
            ]
          },
          {
            "rank": 2,
            "origin": "적용::applicability",
            "title": "적용",
            "fragment": "applicability",
            "children": []
          },
          {
            "rank": 2,
            "origin": "장단점::pros-and-cons",
            "title": "장단점",
            "fragment": "pros-and-cons",
            "children": []
          }
        ]
      }
    },
    "description": "데코레이터는 객체를 필요한 기능만 유연하게 확장할 수 있는 디자인 패턴이다.\r\n단어 그대로 무언가를 꾸며(확장)주기 위해 사용할 수 있다.",
    "content": "\r\n\r\n## 핵심 구성요소::key-components\r\n* **Component**: 기준이 되는 기본기능을 나타내는 **인터페이스**\r\n* **ConcreteComponent**: 기준이 되는 기본 구상 클래스\r\n* **Decorator**: 다양한 기능으로 꾸미기 위해 기본객체를 `Wrapping`하는 클래스\r\n* **ConcreteDecorator**: 실제 확장을 담당하는 데코레이터\r\n\r\n`데코레이터 패턴(이하 데코레이터)`는 [프록시 패턴]()과 유사하다. 구현의 개념과, 참조의 개념도 포함되어 있다.\r\n\r\n```mermaid\r\n---\r\nconfig:\r\n    class:\r\n        hideEmptyMembersBox: true\r\n---\r\nclassDiagram\r\n    class Component {\r\n        <<interface>>\r\n        +operation(): void\r\n    }\r\n    class ConcreteComponent {\r\n        +operation(): void\r\n    }\r\n    class Decorator {\r\n        -component: Component\r\n        +operation(): void\r\n    }\r\n    class ConcreteDecorator {\r\n        +operation(): void\r\n    }\r\n    Component <|.. ConcreteComponent\r\n    Component <|.. Decorator\r\n    Component <--o Decorator\r\n    Decorator <|-- ConcreteDecorator\r\n    \r\n```\r\n\r\n## 예제::example\r\n\r\n데코레이터 패턴을 살펴보기 전에 이해할 구성 요소간 역할과 책임:\r\n\r\n* **Component**\r\n    * **역할**: 기본 행위를 나타낸다.\r\n    * **책임**: 기본 행위를 구현하기 위해 필요한 기능들을 인터페이스한다.\r\n* **ConcreteComponent**\r\n    * **역할**: 실제 기본 행위의 기준이다.\r\n    * **책임**: 기본 역할에 대한 필요한 기능을 구현하며, 이를 수행한다.\r\n* **Decorator**\r\n    * **역할**: 여러 데코레이터에서 사용할 수 있도록 기본 객체를 래핑한다.\r\n    * **책임**: 공통적인 추가기능을 수행하며, 확장 객체가 올바르게 수행될수 있도록 기본 행위를 처리한다. \r\n* **ConcreteDecorator**\r\n    * **역할**: 실제 확장을 담당한다.\r\n    * **책임**: 래핑 객체에 대한 실제 확장기능을 수행하며, 기본 기능은 래핑 객체에 위임한다.\r\n\r\n### 다양한 커피 만들기::make-various-coffee\r\n\r\n커피를 만드려한다. 여러가지 커피와, 토핑을 추가하기 위해 토핑을 정의하고, 기본 커피에 추가하여 새로운 커피를 만들자.\r\n\r\n**Component**\r\n\r\n::code-group\r\n```java::커피\r\n// Component\r\npublic interface Coffee {\r\n    double getCost();\r\n    String getDescription();\r\n\r\n    default void print() {\r\n        System.out.printf(\"주문: %s\\n가격: %.2f원\\n\", getDescription(), getCost());\r\n    }\r\n}\r\n```\r\n\r\n```java::에스프레소\r\n// ConcreteComponent\r\npublic class Espresso implements Coffee {\r\n\r\n    @Override\r\n    public double getCost() {\r\n        return 1500;\r\n    }\r\n\r\n    @Override\r\n    public String getDescription() {\r\n        return \"에스프레소\";\r\n    }\r\n}\r\n```\r\n\r\n```java::아메리카노\r\n// ConcreteComponent\r\npublic class Americano implements Coffee {\r\n\r\n    private final Espresso espresso;\r\n\r\n    public Americano(Espresso espresso) {\r\n        this.espresso = espresso;\r\n    }\r\n\r\n    @Override\r\n    public double getCost() {\r\n        return espresso.getCost() + 500;\r\n    }\r\n\r\n    @Override\r\n    public String getDescription() {\r\n        return \"아메리카노\";\r\n    }\r\n```\r\n\r\n::\r\n\r\n**Decorator**\r\n\r\n::code-group\r\n```java::토핑\r\n// Decorator\r\npublic class CoffeeDecorator implements Coffee {\r\n\r\n    protected final Coffee decoratedCoffee;\r\n\r\n    public CoffeeDecorator(Coffee decoratedCoffee) {\r\n        this.decoratedCoffee = decoratedCoffee;\r\n    }\r\n\r\n    @Override\r\n    public double getCost() {\r\n        return this.decoratedCoffee.getCost();\r\n    }\r\n\r\n    @Override\r\n    public String getDescription() {\r\n        return this.decoratedCoffee.getDescription();\r\n    }\r\n}\r\n```\r\n\r\n```java::추가 샷\r\npublic class ExtraShot extends CoffeeDecorator {\r\n\r\n    public ExtraShot(Coffee decoratedCoffee) {\r\n        super(decoratedCoffee);\r\n    }\r\n\r\n    @Override\r\n    public double getCost() {\r\n        return super.getCost() + 1500;\r\n    }\r\n\r\n    @Override\r\n    public String getDescription() {\r\n        return super.getDescription() + \", 샷 추가\";\r\n    }\r\n}\r\n```\r\n\r\n```java::바닐라 시럽\r\npublic class Vanilla extends io.alloc.structure.decorator.coffee.decorator.CoffeeDecorator {\r\n\r\n    public Vanilla(Coffee decoratedCoffee) {\r\n        super(decoratedCoffee);\r\n    }\r\n\r\n    @Override\r\n    public double getCost() {\r\n        return super.getCost() + 1000;\r\n    }\r\n\r\n    @Override\r\n    public String getDescription() {\r\n        return super.getDescription() + \", 바닐라 시럽\";\r\n    }\r\n}\r\n```\r\n\r\n```java::휘핑 크림\r\npublic class WhippedCream extends io.alloc.structure.decorator.coffee.decorator.CoffeeDecorator {\r\n\r\n    public WhippedCream(Coffee decoratedCoffee) {\r\n        super(decoratedCoffee);\r\n    }\r\n\r\n    @Override\r\n    public double getCost() {\r\n        return super.getCost() + 800;\r\n    }\r\n\r\n    @Override\r\n    public String getDescription() {\r\n        return super.getDescription() + \", 휘핑 크림\";\r\n    }\r\n}\r\n```\r\n::\r\n\r\n```java::클라이언트 코드\r\nEspresso espresso = new Espresso();\r\n\r\n// 아메리카노\r\nCoffee americano = new Americano(espresso);\r\namericano.print();\r\n\r\n// 샷이 추가된 아메리카노 주문\r\nCoffee doubleShot = new ExtraShot(americano);\r\ndoubleShot.print();\r\n\r\n//트리플샷\r\nCoffee tripleShot = new ExtraShot(doubleShot);\r\ntripleShot.print();\r\n\r\n//바닐라 시럽, 휘핑크림이 추가된  아메리카노 주문\r\nVanilla vanillaAdded = new Vanilla(americano);\r\nCoffee whippedVanillaAmericano = new WhippedCream(vanillaAdded);\r\nwhippedVanillaAmericano.print();\r\n```\r\n\r\n클라이언트는 필요한 확장 기능을 사용하여, 유연하게 최종 기능을 구현할 수 있으며, 원본에대한 불변성까지 보장할 수 있다.\r\n\r\n> 지속적인 확장을 위해 원본을 재사용할 수 도 있다.\r\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\" }\r\n\r\n\r\n```text::결과\r\n주문: 아메리카노\r\n가격: 2000.00원\r\n주문: 아메리카노, 샷 추가\r\n가격: 3500.00원\r\n주문: 아메리카노, 샷 추가, 샷 추가\r\n가격: 5000.00원\r\n주문: 아메리카노, 바닐라 시럽, 휘핑 크림\r\n가격: 3800.00원\r\n```\r\n\r\n## 적용::applicability\r\n\r\n`데코레이터`는 다음과 같은 상황에서 적용 가능하다.\r\n\r\n* 원본의 코드를 훼손하지 않으면서 런타임에 유연한 확장이 필요한 경우\r\n* 상속으로의 확장이 불가능 하거나 어색한 경우\r\n\r\n## 장단점::pros-and-cons\r\n\r\n**장점**\r\n\r\n* [단일 책임 원칙](): 다양한 기능을 분리하여, 각각의 클래스가 하나의 책임을 갖도록 한다.\r\n* 새로운 자식클래스를 만들지 않고도, 기존 클래스의 기능을 확장할 수 있다.\r\n* 런타임에 객체들의 책임을 추가하거나, 제거 가능하다.\r\n\r\n**단점**\r\n\r\n* 래퍼들의 스택에서 특정 래퍼를 제거하기가 어렵다. (중간만 빼려면 다시 만들어야 한다.)\r\n* 데코레이터의 행동이 스택내의 순서에 의존하지 않는 방식으로 구현하기가 어렵다.\r\n  * 즉 데코레이터의 순서가 중요한 경우, 데코레이터의 순서를 보장하기 어렵다.\r\n"
  },
  {
    "path": "/docs/computer-science/operating-system/linkers-and-loaders",
    "header": {
      "layout": "wiki",
      "date": 1628985300000,
      "title": "링커와 로더 (Linkers and Loaders)",
      "tags": [
        "Operating System",
        "Linker",
        "Loader"
      ],
      "summary": "링커와 로더",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "컴퓨터",
        "operating-system"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "개요::overview",
            "title": "개요",
            "fragment": "overview",
            "children": []
          },
          {
            "rank": 2,
            "origin": "동작 과정::workflow",
            "title": "동작 과정",
            "fragment": "workflow",
            "children": []
          },
          {
            "rank": 2,
            "origin": "동적 링크 라이브러리::dynamic-link-library",
            "title": "동적 링크 라이브러리",
            "fragment": "dynamic-link-library",
            "children": []
          }
        ]
      }
    },
    "description": "",
    "content": "\r\n## 개요::overview\r\n\r\n일반 적인 실행파일은 바이너리로 디스크에 존재한다.\r\n`Unix/Linux`에서 실행가능한 `.out(c/c++ 컴파일러가 생성한 실행파일)`이나 `Windows`에서 실행가능한 `.exe` 파일이 그 예이다.\r\n\r\n링커와 로더는 컴파일과정에서 생성된 실행파일을 메모리에 로드하고 실행가능한 형태로 만드는 역할을 한다.\r\n\r\n## 동작 과정::workflow\r\n\r\n[`CPU`](/wiki/central-processing-unit)에서 실행하려면 프로그램을 메모리로 가져와 프로세스 형태로 배치되어야 한다.  \r\n아래는 프로그램을 컴파일 하고 메모리에 배치하여 사용가능한 `CPU` 코어에서 실행할 수 있는 과정을 단계별로 설명한다.\r\n\r\n\r\n```mermaid\r\nflowchart\r\n    id1((소스\r\n    프로그램\r\n    main.c)) \r\n    id2([컴파일러])\r\n    id3((오브젝트\r\n    파일\r\n    main.o))\r\n    id4([링커])\r\n    id5((실행 파일\r\n    main))\r\n    id6([로더])\r\n    id7((메모리의\r\n    프로그램))\r\n    id8((다른\r\n    오브젝트\r\n    파일))\r\n    id9((동적 링크\r\n    라이브러리))\r\n    id1 -- \"`**gcc -c main.c**`\" --> id2\r\n    id2 --> id3\r\n    id3 --> id4\r\n    id4 -- \"`**gcc -o main main.o -lm**`\" --> id5\r\n    id5 -- \"` 실행 **./main**`\" --> id6\r\n    id6 --> id7\r\n    id8 -.-> id4\r\n    id9 -.-> id7\r\n```\r\n\r\n`main.c` 파일은 컴파일러에 의해 `main.o` 파일로 컴파일 되며 이는 임의의 메모리에 적재되도록 설계된 오브젝트 파일이다.\r\n이러한 형식을 **재배치 가능 오브젝트 파일**(**R**elocatable **O**bject **F**ile)이라고 한다.  \r\n\r\n`링커`는 이러한 `ROF`를 하나의 바이너리 `실행`파일로 결합한다. 이 과정을 링킹이라 하며, 이 단계에서는 표준 C 또는 수학 라이브러리 (flag `-lm`)와 같은 다른 오브젝트 파일을 포함 시킬 수 있다.\r\n\r\n`로더`는 이진 실행파일을 메모리에 잭재(load)하는 데 사용되며, `CPU` 코어에서 실행할 수 있는 상태가 된다. 링크 및 로드와 관령된 활동은 재배치(relocation)로, \r\n프로그램 부분에 최종 주소를 할당 하고 프로그램 코드와 데이터를 해당 주소와 일치하도록 조정하여 프로그램이 실행될 때 코드가 라이브러리 함수를 호출하고 변수에 접근할 수 있게 한다. \r\n\r\n> 링커는 여러 오브젝트 파일에 대한 물리적인 바이너리를 재배치 하는것이고 로더는 이러한 바이너리를 메모리로 로드할 때 논리적인 메모리 주소(가상메모리 주소)를\r\n> 실제 물리적 메모리 주소로 변환하며 주소에 대한 재배치를 수행한다.\r\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\" }\r\n\r\n> 물리적 최종 주소는 프로세스가 할당받는 메모리공간(코드, 데이터, 스택, 힙)으로 프로세스가 접근할 수 있다는 의미이다.\r\n:{ \"type\": \"note\", \"icon\": \"info\" }\r\n\r\nUnix 시스템 CLI(Command Line Interface)에 프로그램 이름(./main)을 입력하면 Shell 프로그램은 `fork()` 시스템 콜을 사용하여 프로그램 실행을 위한, 프로세스를 생성한다.\r\n그후 `exec()`에 실행파일 이름과 함께 로더를 호출한다. 로더는 프로세스 주소에 프로그램 적재한다.\r\n\r\n오브젝트 파일과 실행 파일은 일반적으로 표준화된 형식을 가지는데, \r\n이는 컴파일된 기계 코드 및 프로그램에서 참조되는 함수 및 변수에대한 메타데이터를 포함 하는 기호 테이블을 포함한다. \r\n이는 변수와 함수에 대한 메타데이터를 모아둔 심볼 테이블(symbol table)이 포함되어 있다. 이러한 심볼들을 링커가 연결한다.\r\n\r\nUnix/Linux 시스템에서는 이 표준 형식을 ELF(**E**xecutable and **L**inkable **F**ormat)라고, \r\nWindows 시스템에서는 PE(**P**ortable **E**xecutable)라고, macOS 시스템에서는 Mach-O 라고한다.\r\n\r\n\r\n## 동적 링크 라이브러리::dynamic-link-library\r\n\r\n링크과정에서 모든라이브러리를 포함하는 것은 비효율적이다. 이러한 문제를 해결하기 위해 동적 링크 라이브러리가 등장하였다.\r\n우리가 흔히 알고 있는 `.so` 또는 `.dll` 파일이 이에 해당한다. Windows 운영체제는 이(**D**ynamically **L**inked **L**ibrary)를 지원한다.\r\n\r\nDLL의 장점은 실행파일에서 사용되지 않을 수 있는 라이브러리를 링크만하고 로드는 하지 않아도 된다.\r\n이러한 DLL은 런타임에 필요한 경우 조건부로 로드된다. 대신 동적 링크를 사용할 있도록 링커는 재배치 정보를 프로그램에 추가한다.\r\n\r\n이러한 동적 링크 라이브러리는 다음의 방법으로 여러 프로세스에서 공유할 수 있기 때문에 메모리 사용이 크게 절약된다:\r\n\r\n1. 프로세스가 DLL/so 라이브러리 함수 호출\r\n2. 링커가 해당 라이브러리 적재 여부 확인\r\n3. 이미 물리 메모리에 로드되어 있다면\r\n   * 해당 물리 메모리 영역을 자신의 가상메모리 주소 공간에 매핑\r\n   * 참조 카운트 증가\r\n4. 그렇지 않다면\r\n   * 라이브러리를 물리 메모리에 로드\r\n   * 자신의 가상메모리 주소 공간에 매핑\r\n   * 참조 카운트 초기화\r\n\r\n> 링커는 라이브러리를 로드할 때 이전에 프로그램에 추가했던 재배치 정보를 사용하여 라이브러리를 로드한다. \r\n:{ \"type\": \"note\", \"icon\": \"info\" }\r\n\r\n> 각 운영체제는 동적 링크 라이브러리에 대한 참조를 관리하며, 참조 카운트가 0이 되면 해당 라이브러리를 언로드한다.\r\n:{ \"type\": \"important\", \"icon\": \"warning-octagon\" }\r\n"
  },
  {
    "path": "/docs/computer-science/operating-system/system-service",
    "header": {
      "layout": "wiki",
      "date": 1628985300000,
      "title": "시스템 서비스 (System Service)",
      "tags": [
        "Operating System",
        "System Service",
        "System Utility",
        "Daemon"
      ],
      "summary": "시스템 서비스",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "컴퓨터",
        "operating-system"
      ],
      "images": [
        {
          "src": "/post/computer/macos-activity-monitor.png",
          "alt": "macOS 운영체제의 시스템 서비스(활성 상태 보기)"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "시스템 서비스란?::what-is-system-service",
            "title": "시스템 서비스란?",
            "fragment": "what-is-system-service",
            "children": []
          },
          {
            "rank": 2,
            "origin": "시스템 서비스의 종류::types-of-system-service",
            "title": "시스템 서비스의 종류",
            "fragment": "types-of-system-service",
            "children": [
              {
                "rank": 3,
                "origin": "포그라운드 서비스::foreground-service",
                "title": "포그라운드 서비스",
                "fragment": "foreground-service",
                "children": []
              },
              {
                "rank": 3,
                "origin": "백그라운드 서비스::background-service",
                "title": "백그라운드 서비스",
                "fragment": "background-service",
                "children": []
              }
            ]
          },
          {
            "rank": 2,
            "origin": "서브 시스템::sub-system",
            "title": "서브 시스템",
            "fragment": "sub-system",
            "children": []
          }
        ]
      }
    },
    "description": "",
    "content": "\r\n## 시스템 서비스란?::what-is-system-service\r\n\r\n![macOS 운영체제의 시스템 서비스(활성 상태 보기)](/post/computer/macos-activity-monitor.png)\r\n:{ \"description\": \"macOS 운영체제의 시스템 서비스(활성 상태 보기)\" }\r\n\r\n시스템 서비스(System Service)는 시스템 유틸리티(System Utility)로도 알려진 시스템 프로그램(System Program)이다.\r\n시스템 사용을 위해 편리하게 제공되며 내부 구현은 복잡한 프로그램이다. 일부는 우리가 알고 있는 [시스템 API](/wiki/system-call#api-and-system-call)이다.\r\n\r\n사용자는 **노래를 들으며**, 게임을 어떻게 할 수 있는지 알 필요가 없다. 사용자가 원하는 것을 쉽게 사용할 수 있도록 운영체제가 시스템 서비스를 제공한다.\r\n예를 들어 크롬 브라우저에서 유튜브 뮤직을 재생하고 Stream 앱으로 게임을 실행하고 있어도 노래가 정지되지 않는다.\r\n\r\n근본적으로는 노래가 재생되고 있는 `Chrome` 앱이 백그라운드로 전환 될때 오디오 시스템과 통신하는 데몬을 실행하기 때문에 사용자는 눈치채지 못한다.\r\n\r\n> macOS의 경우 Chrome 앱이 백그라운드로 전환되면 `coreaudiod` 데몬이 실행되며 하드웨어 드라이버를 제어한다.\r\n: { \"type\": \"tip\", \"icon\": \"lightbulb\" }\r\n\r\n## 시스템 서비스의 종류::types-of-system-service\r\n\r\n시스템 서비스는 포그라운드 서비스(Foreground Service)와 백그라운드 서비스(Background Service)로 나뉜다.\r\n`Foreground`는 현재 사용자와 직접적인 상호작용을 하는 서비스를 말하고, `Background`는 프로세스의 상태로 사용자와 직접적인 상호작용을 하지 않는 서비스를 말한다.\r\n\r\n각 운영체제별 시스템 서비스의 종류는 다음과 같다:\r\n\r\n| 운영체제 |          포그라운드 서비스           |                   백그라운드 서비스                    |\r\n|:---:|:----------------------------:|:----------------------------------------------:|\r\n| Windows |        `작업 관리자`, `엣지`        |      `작업 스케줄러`, `윈도우 디펜더`, `윈도우 업데이트 서비스`      |\r\n| macOS   |    `활성 상태 보기`, `시스템 환경설정`    | `coreaudiod`, `알림 센터`, `bird (iCloud 데이터 동기화)` |\r\n| Linux   | `vim 에디터`, `top (프로세스 관리도구)` |           `systemd`, `cron`, `sshd (SSH 데몬)`           |\r\n\r\n### 포그라운드 서비스::foreground-service\r\n\r\n**파일 관리**\r\n\r\n파일과 디렉토리를 생성하며, 삭제, 복사, 명명, 출력, 목록화 및 일반적인 조작을 수행한다.\r\n\r\n**상태 정보**\r\n\r\n시스템의 상태정보를 제공한다. 예를들어 날짜, 시간, 가용 메모리 및 디스크, 사용자 수 등과 같은 상태정보를 제공한다. 이러한 기능을 제공하는 서비스들은 환경설정 정보를 저장하고 검색할 수 있는 등록(registry) 기능을 지원하기도 한다.\r\n\r\n**파일 변경**\r\n\r\n앞서 설명한 파일관리와 비슷하지만, 기능을 연계하여 파일을 변경(예: `text editor`)하거나 파일의 속성을 변경하는 기능을 제공한다.\r\n\r\n**프로그래밍 언어 지원**\r\n\r\n일반적인 프로그래밍 언어를 지원하기 위해 컴파일러, 링커, 디버거, 런타임 라이브러리 등을 제공한다. 예를들어 리눅스의 경우 기본적으로 `gcc` 컴파일러를 제공한다.\r\n\r\n**프로그램 적재와 수행**\r\n\r\n컴파일 된 프로그램을 링크하는 `링키지 에디터`(linkage editor)와 실행가능한 바이너리를 메모리에 적재하는 로더(loader)를 제공한다.\r\n* 로더는 메모리의 절대 주소에 로드하는 `절대 로더`(Absolute Loader)와 동적인 주소에 로드하는 `재배치 가능 로더`(Relocatable Loader)로 나뉘며, 큰 프로그램을 부분적으로 메모리에 로드하는 `중첩 로더`(Overlay Loader)도 있다.\r\n\r\n**통신**\r\n\r\n사용자 와 다른 시스템 간에 가상접속을 구현하는 통신 서비스를 제공한다. 예를 들어 리눅스의 `ls | grep text`와 같은 명령어는 `|`를 통해 두 프로그램을 연결한다.\r\n\r\n\r\n### 백그라운드 서비스::background-service\r\n\r\n프로그램은 자신의 할일을 완수하면 종료되는 프로그램도 있는 반면에, 시스템이 종료될 때 까지 계속 실행되는 프로그램도 있다.\r\n이러한 프로그램을 **백그라운드 서비스(Background Service)** 또는 **데몬(Daemon)** 이라고 한다.\r\n\r\n앞서 `coreaudiod` 데몬은 `macOS`에서 오디오 시스템을 제어한다고 했었다. 이외에도 네트워크 연결을 청취(Listen)하는 네트워크 데몬이 있고, \r\n시스템 연결요청을 올바른 프로세스에 연결해주는 역할을 수행한다. \r\n\r\n또 다른 예로 프로세스를 시작시키는 프로세스 스케줄러, 시스템 오류 감시 서비스 및 출력서버 등이 있다. \r\n또한 OS가 중요한 활동을 커널 컨텍스트(Kernel Context)에서가 아니라 사용자 컨텍스트(User Context)에서 수행 해야하는 경우, 데몬을 이용해서 이 작업을 수행할 수 있다.\r\n\r\n\r\n## 서브 시스템::sub-system\r\n\r\nOS의 핵심 기능을 놀리적으로 분할한 작은 단위의 시스템이고 서비스와는 다른 개념이다.  \r\n예를 들어 계층으로 분류를 하면 아래와 같다:\r\n\r\n```\r\n운영체제\r\n├── 파일시스템 서브시스템 (File System Subsystem)\r\n│   └── VFS → 실제 파일시스템 → 블록 디바이스 드라이버 → 물리장치\r\n├── 메모리 관리 서브시스템 (Memory Management Subsystem)\r\n│   └── 가상메모리 → 페이지테이블 → 물리메모리\r\n├── 프로세스 관리 서브시스템 (Process Management Subsystem)\r\n│   └── 스케줄러 → 프로세스/스레드 관리 → CPU\r\n└── I/O 서브시스템 (I/O Subsystem)\r\n    └── I/O 스케줄러 → 디바이스 드라이버 → 물리장치\r\n```\r\n이는 특정 기능 역역 전체를 관리하는 상위 개념이며, 그 아래 있는 여러 계층 구조와 구성요소들을 포함한다.\r\n\r\n> `서브 시스템`은 시스템의 핵심 기능을 제공하기 위해 존재하는 작은 단위의 시스템이다.\r\n: { \"type\": \"tip\", \"icon\": \"lightbulb\" }\r\n"
  },
  {
    "path": "/docs/network/media-type",
    "header": {
      "layout": "wiki",
      "title": "미디어 타입 (Media Type)",
      "date": 1616235000000,
      "tags": [
        "Network",
        "HTTP",
        "Media Type",
        "MIME Type"
      ],
      "summary": "미디어 타입",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "네트워크"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "미디어 타입이란?::what-is-media-type",
            "title": "미디어 타입이란?",
            "fragment": "what-is-media-type",
            "children": []
          }
        ]
      }
    },
    "description": "",
    "content": "\r\n## 미디어 타입이란?::what-is-media-type\r\n\r\n**미디어 타입**(Media Type)은 웹에서 전송되는 데이터의 형식을 나타내는 메타 정보이다.\r\n웹에서는 주로 **MIME**(**M**ultipurpose **I**nternet **M**ail **E**xtensions) 타입이라고 불리며, 데이터의 형식을 나타내는 문자열이다.\r\n\r\n`MIME`는 이메일을 위한 표준 포맷을 정의하였으며, 이를 확장하여 웹에서도 사용되고 있다.\r\n서버에서는 전달할 자원의 확장자를 이용해 미디어 타입을 결정하며, 브라우저는 이를 통해 어떤 방식으로 자원을 처리할지 결정한다.\r\n\r\n>이러한 미디어 타입은 표현 계층으로서의 구현이다. \r\n: { \"type\": \"note\", \"icon\": \"info\" }\r\n\r\n(타입)/(서브타입)의 형식으로 이루어져 있으며, 서브타입은 타입에 따라 다양하게 나뉜다.\r\n\r\n| MIME Type |                                       설명                                        | 일반 적인 서브타입 예시 |\r\n|:---:|:-------------------------------------------------------------------------------:|:---:|\r\n| text |                    텍스트를 포함하는 모든 문서를 나타내며 이론상 인간이 읽을수 있어야 한다.                    | plain, html, css, javascript |\r\n| image | 모든 종류의 이미지를 나타내며, 애니메이션되는 이미지(animated gif 처럼)가 이미지타입에 포함되긴 하지만, 비디오는 포함되지 않는다. | jpeg, png, gif, svg |\r\n| audio |                                모든 종류의 오디오 파일을 나타낸다.                                | mp3, wav, ogg |\r\n| video |                                모든 종류의 비디오 파일을 나타낸다.                                | mp4, webm, ogg |\r\n| application |                         모든 종류의 바이너리 데이터를 나타낸다.                         | octet-stream, json, pdf, zip |\r\n\r\n\r\n\r\n"
  },
  {
    "path": "/docs/network/http",
    "header": {
      "layout": "post",
      "title": "HTTP (HyperText Transfer Protocol)",
      "tags": [
        "Network",
        "TCP/IP",
        "HTTP"
      ],
      "date": 1616160120000,
      "thumbnail": "/post/network/http/index.png",
      "profile-image": "/post/profile/profile1.jpg",
      "current-company": "Cubic INC",
      "current-position": "SI Researcher",
      "summary": "HTTP",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "네트워크"
      ],
      "images": [
        {
          "src": "/post/network/http/index.png",
          "alt": "HTTP 통신"
        },
        {
          "src": "/post/network/http/request-format.png",
          "alt": "HTTP 요청 메세지"
        },
        {
          "src": "/post/network/http/response-format.png",
          "alt": "HTTP 응답 메세지"
        },
        {
          "src": "/post/network/http/http-message.png",
          "alt": "HTTP 메세지 전문"
        },
        {
          "src": "/post/network/http/keep-alive.png",
          "alt": "Keep-Alive"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "HTTP란?::what-is-http",
            "title": "HTTP란?",
            "fragment": "what-is-http",
            "children": []
          },
          {
            "rank": 2,
            "origin": "HTTP 메세지 구조::message-structure",
            "title": "HTTP 메세지 구조",
            "fragment": "message-structure",
            "children": [
              {
                "rank": 3,
                "origin": "요청 메세지::request-message",
                "title": "요청 메세지",
                "fragment": "request-message",
                "children": []
              },
              {
                "rank": 3,
                "origin": "응답 메세지::response-message",
                "title": "응답 메세지",
                "fragment": "response-message",
                "children": []
              }
            ]
          },
          {
            "rank": 2,
            "origin": "메세지 본문::message-body",
            "title": "메세지 본문",
            "fragment": "message-body",
            "children": []
          },
          {
            "rank": 2,
            "origin": "HTTP Header Options::header-options",
            "title": "HTTP Header Options",
            "fragment": "header-options",
            "children": [
              {
                "rank": 3,
                "origin": "Keep-Alive::keep-alive",
                "title": "Keep-Alive",
                "fragment": "keep-alive",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "HTTP는 HyperText Transfer Protocol의 약자로, 웹 서버와 웹 클라이언트 간의 통신을 위한 프로토콜이다.\r\nTCP 위에서, 요청/응답 방식으로 동작한다.",
    "content": "\r\n## HTTP란?::what-is-http\r\n\r\n**HTTP**(HyperText Transfer Protocol)는 웹 서버와 웹 클라이언트 간의 통신을 위한 프로토콜이다.\r\n기본적으로 클라이언트가 서버에 요청을 보내고, 서버는 요청에 대한 응답을 보내는 방식으로 동작한다.\r\n\r\n![HTTP 통신](/post/network/http/index.png)\r\n:{ \"align\": \"center\", \"max-width\": \"400px\", \"description\": \"HTTP 통신\" }\r\n\r\nHTTP의 일반적인 동작은 이미지처럼  [TCP](/docs/network/tcp-ip/transport-layer#tcp-3-way-handshake) 위에서 수행된다.\r\n이미 연결이 맺어졌다는 가정하에, 메세지를 교환하는 방식이다.\r\n\r\n각 장치에서는 TCP 세그먼트의 페이로드를 HTTP 메세지로, 표준화된 규격에 맞게 해석하여 처리한다.\r\n[HTTP/1.1](https://www.rfc-editor.org/info/rfc2616)은 1999년에 표준화되었으며, 현재는 [HTTP/2](https://www.rfc-editor.org/info/rfc7540) 등 상위 버전도 나와있다.\r\n\r\n## HTTP 메세지 구조::message-structure\r\n\r\nHTTP는 상태가 없는(Stateless) 프로토콜이기 떄문에 서버에서 이전 요청들의 상태를 저장하지 않는다. \r\n메세지는 크게 요청(Request) 메세지와 응답(Response) 메세지로 나뉘며 각 메세지는 표준 규격을 따른다.\r\n\r\n### 요청 메세지::request-message\r\n\r\n![HTTP 요청 메세지](/post/network/http/request-format.png)\r\n:{ \"align\": \"center\", \"max-width\": \"600px\", \"description\": \"HTTP 요청 메세지\" }\r\n\r\nHTTP 메세지는 요청 라인, 헤더, 본문으로 구성된다. 예제에서는 이해를 위해 요청 라인과 헤더를 알아보자.\r\n\r\n*Request Line*\r\n\r\n* **Method**: 요청 방식을 나타낸다. (GET, POST, PUT, DELETE 등)\r\n* **Request-URI**: 요청 대상의 리소스를 나타낸다.\r\n* **Protocol**: HTTP 프로토콜의 버전을 나타낸다.\r\n\r\n요청 라인에서는 클라이언트가 요청하는 리소스에 대하여 어떤 방식으로 요청하는지 와 어떤 프로토콜의 버전으로 처리에 대해 요청하는지를 나타낸다. \r\n\r\n*Header*\r\n\r\n* **Host**: 요청 대상의 호스트를 나타낸다.\r\n* **User-Agent**: 요청을 보내는 클라이언트의 정보를 나타낸다.\r\n* **Accept**: 클라이언트가 받아들일 수 있는 컨텐츠 타입을 나타낸다.\r\n* **Content-Type**: 요청 본문의 타입을 나타낸다.\r\n* **Content-Length**: 요청 본문의 길이를 나타낸다.\r\n\r\n헤더에서는 클라이언트가 요청하는 리소스에 대하여 추가적인 정보를 담고 있다. \r\n이미지에서는 일부 헤더가 생략 되었지만, 실제로 Content-Length 같이 요청의 끝을 알 수 없어 메세지 해석이 어려운 경우 TCP 연결종료 끝을 판단한다.\r\n따라서 대부분은 HTTP 클라이언트는 기본적인 헤더를 포함되게 되어있다.\r\n\r\n\r\n### 응답 메세지::response-message\r\n\r\n![HTTP 응답 메세지](/post/network/http/response-format.png)\r\n:{ \"align\": \"center\", \"max-width\": \"600px\", \"description\": \"HTTP 응답 메세지\" }\r\n\r\nHTTP 응답 메세지는 상태 라인, 헤더, 본문으로 구성된다. 예제에서는 이해를 위해 상태 라인과 헤더를 알아보자.\r\n\r\n*Status Line*\r\n\r\n* **Protocol**: HTTP 프로토콜의 버전을 나타낸다.\r\n* **Status-Code**: 요청에 대한 응답 상태 코드를 나타낸다.\r\n  * | 전체 범위 | 정의된 범위 | 분류 |\r\n    |:---:|:---:|:---:|\r\n    | 1xx | 100 ~ 101 | 정보 |\r\n    | 2xx | 200 ~ 206 | 성공 |\r\n    | 3xx | 300 ~ 305 | 리다이렉션 |\r\n    | 4xx | 400 ~ 415 | 클라이언트 에러 |\r\n    | 5xx | 500 ~ 505 | 서버 에러 |\r\n* **Reason-Phrase**: 상태 코드에 대한 설명을 나타낸다.\r\n  * | 상태 코드 | 사유 구절 | 의미 |\r\n    |:---:|:---:|:---:|\r\n    | 200 | OK | 요청이 성공적으로 처리되었음 |\r\n    | 404 | Not Found | 요청한 리소스를 찾을 수 없음 |\r\n    | 500 | Internal Server Error | 서버 내부 에러로 요청을 처리할 수 없음 |\r\n\r\n상태 라인에서는 서버가 클라이언트에게 응답하는 상태 코드와 그에 대한 설명을 나타낸다.  \r\n\r\n상태 코드는 [RFC9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-status-codes)에 정의되어 있으며, 상태 코드에 따라 클라이언트는 어떻게 처리해야 하는지 알 수 있다.\r\n이는 사유구절과 한개의 상태 정보로 사용된다. \r\n\r\n*Header*\r\n\r\n* **Server**: 서버의 정보를 나타낸다.\r\n* **Content-Type**: 응답 본문의 타입을 나타낸다.\r\n* **Content-Length**: 응답 본문의 길이를 나타낸다.\r\n* **Date**: 응답을 보낸 시간을 나타낸다.\r\n* **Connection**: 클라이언트와 서버의 연결 상태를 나타낸다.\r\n\r\n## 메세지 본문::message-body\r\n\r\n![HTTP 메세지 전문](/post/network/http/http-message.png)\r\n:{ \"align\": \"center\", \"max-width\": \"600px\", \"description\": \"HTTP 메세지 전문\" }\r\n\r\n`HTTP` 메세지의 **요청라인과 상태라인 그리고 헤더**가 메세지에 대한 설정 정보라면 본문은 실제 데이터를 담고 있는 부분이다.\r\n\r\nHTTP 메세지 해석시 본문을 알기 위해서는, 메세지 전체를 볼 필요가있다. \r\n먼저 메세지 시작을 알기위해 `Header`와 `Body`를 구분하는 개행이 필요하다. http 메세지는 표준 스트림으로 읽기 때문에 끝을 알수가 없다.\r\n\r\n따라서 메세지 헤더의 `Content-Length`를 통해 본문의 길이를 알 수 있으며, 이를 통해 본문의 끝을 알 수 있다.\r\n\r\n이미지에는 요청 본문이 `application/x-www-form-urlencoded`형식으로 되어있고, 응답 본문에는 `application/html`형식으로 되어있는걸 알 수 있다.\r\n메세지를 받는 대상이 올바르게 해석할 수 있도록 `Content-Type`을 통해 본문의 타입을 알려준다.\r\n\r\n\r\n## HTTP Header Options::header-options\r\n\r\nHTTP는 TCP 위에서 동작하기 때문에, HTTP 헤더 옵션으로 TCP의 기능을 사용할 수 있다.\r\n예를 들어 `Keep-Alive` 헤더는 특정 시간동안 요청의 세션을 재사용할 수 있도록 지원한다.  \r\n\r\n### Keep-Alive::keep-alive\r\n\r\n`Keep-Alive`는 TCP 스펙의 지속 연결(`Persistent Connection`)을 이용하여, 클라이언트와 서버간의 연결을 유지하는 기능이다.\r\n\r\n```http\r\nGET /index.html HTTP/1.1\r\nHost: www.example.com\r\nConnection: Keep-Alive\r\nKeep-Alive: timeout=60, max=1000\r\n...\r\n```\r\n\r\n![Keep-Alive](/post/network/http/keep-alive.png)\r\n:{ \"align\": \"center\", \"max-width\": \"400px\", \"description\": \"Keep-Alive를 1분으로 설정\" }\r\n\r\n예를 들어 위와 같이 `Connection`은 `Keep-Alive`로 설정되어 있고, `Keep-Alive` 헤더에는 `timeout`과 `max`를 설정하였다.\r\n이 경우 60초 동안 세션을 유지하고, 최대 1000개의 요청을 처리할 수 있으며 둘 중 하나가 먼저 도달하면 세션을 종료한다.\r\n\r\n> 이렇게 지원되는 `Keep-Alive`는 세션 계층으로서의 구현이다.\r\n: { \"type\": \"note\", \"icon\": \"info\" }\r\n"
  },
  {
    "path": "/docs/network/tcp-ip/transport-layer",
    "header": {
      "layout": "post",
      "title": "전송 계층 (Transport Layer)",
      "tags": [
        "Network",
        "Transport Layer",
        "OSI",
        "OSI 7 Layer",
        "TCP/IP"
      ],
      "date": 1614864120000,
      "thumbnail": "/post/network/tcp-ip/transport-layer/tcp-segment-structure.png",
      "profile-image": "/post/profile/profile1.jpg",
      "current-company": "Cubic INC",
      "current-position": "SI Researcher",
      "summary": "전송 계층",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "네트워크",
        "TCP/IP"
      ],
      "images": [
        {
          "src": "/post/network/tcp-ip/transport-layer/udp-datagram-structure.png",
          "alt": "UDP 데이터그램 구조"
        },
        {
          "src": "/post/network/tcp-ip/transport-layer/tcp-segment-structure.png",
          "alt": "TCP 세그먼트 구조"
        },
        {
          "src": "/post/network/tcp-ip/transport-layer/syn-diagram-in-tcp.png",
          "alt": "클라이언트에서 연결을 맺기위해 SYN을 보낸다."
        },
        {
          "src": "/post/network/tcp-ip/transport-layer/captured-segment-of-syn.png",
          "alt": "WireShark로 캡쳐된 SYN 세그먼트"
        },
        {
          "src": "/post/network/tcp-ip/transport-layer/syn+ack-diagram-in-tcp.png",
          "alt": "서버에서는 연결을 수락하기 위해 SYN+ACK를 보낸다."
        },
        {
          "src": "/post/network/tcp-ip/transport-layer/captured-segment-of-syn+ack.png",
          "alt": "WireShark로 캡쳐된 SYN + ACK 세그먼트"
        },
        {
          "src": "/post/network/tcp-ip/transport-layer/ack-diagram-in-tcp.png",
          "alt": "클라이언트에서는 서버의 응답을 확인하기 위해 ACK를 보낸다."
        },
        {
          "src": "/post/network/tcp-ip/transport-layer/captured-segment-of-ack.png",
          "alt": "WireShark로 캡쳐된 ACK 세그먼트"
        },
        {
          "src": "/post/network/tcp-ip/transport-layer/data-send-diagram-in-tcp.png",
          "alt": "서버와 클라이언트는 데이터를 전송한다."
        },
        {
          "src": "/post/network/tcp-ip/transport-layer/captured-segment-of-data.png",
          "alt": "WireShark로 캡쳐된 데이터 전송 세그먼트"
        },
        {
          "src": "/post/network/tcp-ip/transport-layer/fin-diagram-in-tcp.png",
          "alt": "클라이언트와 서버는 세션을 종료하기위해 FIN을 보낸다."
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "전송 계층이란?::what-is-transport-layer",
            "title": "전송 계층이란?",
            "fragment": "what-is-transport-layer",
            "children": []
          },
          {
            "rank": 2,
            "origin": "UDP 데이터그램 구조::datagram-structure",
            "title": "UDP 데이터그램 구조",
            "fragment": "datagram-structure",
            "children": []
          },
          {
            "rank": 2,
            "origin": "TCP 세그먼트 구조::segment-structure",
            "title": "TCP 세그먼트 구조",
            "fragment": "segment-structure",
            "children": []
          },
          {
            "rank": 2,
            "origin": "TCP 3-way Handshake::tcp-3-way-handshake",
            "title": "TCP 3-way Handshake",
            "fragment": "tcp-3-way-handshake",
            "children": [
              {
                "rank": 3,
                "origin": "SYN::synchronize",
                "title": "SYN",
                "fragment": "synchronize",
                "children": []
              },
              {
                "rank": 3,
                "origin": "SYN + ACK::synchronize-acknowledgment",
                "title": "SYN + ACK",
                "fragment": "synchronize-acknowledgment",
                "children": []
              },
              {
                "rank": 3,
                "origin": "ACK::acknowledgment",
                "title": "ACK",
                "fragment": "acknowledgment",
                "children": []
              },
              {
                "rank": 3,
                "origin": "데이터 전송::data-send",
                "title": "데이터 전송",
                "fragment": "data-send",
                "children": []
              },
              {
                "rank": 3,
                "origin": "FIN::finish",
                "title": "FIN",
                "fragment": "finish",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "전송 계층은 OSI 7 Layer 모델에서 L4에 구현되며, TCP와 UDP 프로토콜을 사용하며, 각 프로토콜에 맞게 필요한 처리를 제공한다.",
    "content": "\r\n## 전송 계층이란?::what-is-transport-layer\r\n\r\nL4는 송신자와 수신자 간의 데이터 전송을 관리하며, 종단 간(End-to-End) 통신을 제공한다.\r\n포트번호를 이욜하기 때문에, 특정 어플리케이션이나 프로세스를 식별 할 수 있다.\r\n\r\n여러 프로토콜중에는 `QUIC`, `RUDP`, `DCCP`, `SCTP` 등이 있지만, 대표적으로는 `TCP`와 `UDP`가 있다. \r\nL4는 운영체제 커널에 구현되며 네트워크 통신의 핵심으로서 데이터의 신뢰성, 전송 속도, 어플리케이션 식별을 담당한다.\r\n\r\n## UDP 데이터그램 구조::datagram-structure\r\n\r\n![UDP 데이터그램 구조](/post/network/tcp-ip/transport-layer/udp-datagram-structure.png)\r\n: { \"align\": \"center\", \"max-width\": \"700px\", \"description\": \"UDP 데이터그램 구조\" }\r\n\r\n**UDP**(User Datagram Protocol)는 전송 계층 프로토콜로, 데이터그램 방식으로 데이터를 전송한다.\r\n\r\n비연결형 데이터그램 프로토콜로 간단하고 빠른 데이터 전송을 위한 프로토콜이다.\r\n연결에 대한 설정과 TCP 3way handshake 과정이 없기 때문에 오버헤드 없이 빠른 전송이 가능하다.\r\n\r\n때문에, 데이터 전송의 신뢰성은 보장하지 않지만, 실시간 스트리밍이나 DNS 등에서 사용된다.\r\n\r\n\r\n## TCP 세그먼트 구조::segment-structure\r\n\r\n![TCP 세그먼트 구조](/post/network/tcp-ip/transport-layer/tcp-segment-structure.png)\r\n: { \"align\": \"center\", \"max-width\": \"700px\", \"description\": \"TCP의 세그먼트 구조\" }\r\n\r\n**TCP**(Transmission Control Protocol)는 전송 계층 프로토콜로, 연결형 프로토콜로 데이터를 전송한다.\r\n\r\n각 필드는 다음을 의미한다:\r\n\r\n* **Source Port**: 송신지의 포트 번호\r\n* **Destination Port**: 수신지의 포트 번호\r\n* **Initial Sequence Number**: TCP 연결의 첫번째 패킷에 할당된 시퀀스 번호를 의미 (SYN)\r\n* **Acknowledgment Number**: 연결시에는 ISN +1, 실제 데이터 수신시에는 + 데이터 크기 (Bytes Size)\r\n* **Data Offset**: TCP 헤더의 길이를 4바이트 단위로 표현한 값\r\n  * 이 필드는 Option 필드를 포함한 헤더의 길이를 계산하기 위해 사용된다. \r\n  * 32비트 체계에서 1 word는 4바이트이므로 4비트로 표현할 수 있는 값인 0000 ~ 1111은 0 ~ 15를 의미하고 이에 *4를 하여 0 ~ 60바이트라는 의미이다.\r\n  * 하지만 TCP 헤더의 필수 표현 값이 20바이트이므로 최소 20(01000) ~ 최대 60(1111)이다.\r\n*  **Reserved**: 예약된 필드로, 사용되지 않는다.\r\n* **Flags**: TCP 제어플레그이다. (여기서는 필수 플래그만 다룬다.)\r\n    * **SYN**(Synchronize Sequence Number): 세션 생성시 시퀀스 번호 동기화를 위한 세그먼트를 의미한다.\r\n    * **ACK**(Acknowledgment): Acknowledgment Number 필드가 유효한 값을 가지고 있음을 의미한다.\r\n    * **FIN**(Finish): 세션 종료 요청의 세그먼트를 의미한다.\r\n* **Window Size**: 수신자가 수신할 수 있는 데이터의 양을 의미한다. (수신측, 발신측 모두 다음에 받게될 세그먼트에 대하여 자신의 버퍼상태를 포함한다.)\r\n* **Checksum**: TCP 세그먼트의 오류 검출을 위한 필드로, 세그먼트의 데이터를 포함한 모든 필드의 체크섬을 계산하여 저장한다.\r\n* **Urgent Pointer**: 긴급 데이터의 마지막 바이트를 가리키는 포인터이다.\r\n\r\n\r\n## TCP 3-way Handshake::tcp-3-way-handshake\r\n\r\n`TCP`는 연결 지향형 프로토콜이기 때문에, 연결에 대한 신뢰성을 보장하기위해 핸드쉐이크(악수)라는 개념을 사용한다.\r\n핸드쉐이크는 말그대로 세션 연결을 하기전에, 상대방과의 연결을 확인하는 과정이다.\r\n\r\n핸드쉐이크는 `SYN`, `SYN + ACK`, `ACK` 세그먼트를 통해 3가지의 과정으로 이루어져서 `3-way Handshake`라고 불린다.\r\n\r\n### SYN::synchronize\r\n\r\n![클라이언트에서 연결을 맺기위해 SYN을 보낸다.](/post/network/tcp-ip/transport-layer/syn-diagram-in-tcp.png)\r\n: { \"align\": \"center\", \"max-width\": \"400px\", \"description\": \"SYN 전송\" }\r\n\r\n예를 들어 `:58660` **클라이언트**에서 `:8955` **서버**로 세션을 맺기 위해 다음과같이 요청을 보낸다.\r\n\r\n기본적으로 아무 연결을 맺지 않은 상태는 `Closed` 상태이다. 서버는 요청을 수신하기위해 `Listen` 상태로 대기한다. \r\n제일 먼저 발신지에서는 목적지로 세션을 맺기위해 `SYN` 세그먼트를 전송한다.\r\n\r\n![WireShark로 캡쳐된 SYN 세그먼트](/post/network/tcp-ip/transport-layer/captured-segment-of-syn.png)\r\n: { \"description\": \"WireShark로 캡쳐된 SYN 세그먼트\" }\r\n\r\n위 이미지는 `WireShark`로 캡쳐된 `SYN` 세그먼트이다.\r\n클라이언트에서 서버로 `4248590219`라는 임의의 시퀀스 번호를 가진 `SYN` 세그먼트를 전송 하는 모습을 볼 수 있다.\r\n\r\n이때 서버의 상태는 `SYN_SENT` 상태이다.\r\n\r\n### SYN + ACK::synchronize-acknowledgment\r\n\r\n![서버에서는 연결을 수락하기 위해 SYN+ACK를 보낸다.](/post/network/tcp-ip/transport-layer/syn+ack-diagram-in-tcp.png)\r\n: { \"align\": \"center\", \"max-width\": \"400px\", \"description\": \"SYN + ACK 전송\" }\r\n\r\n서버는 클라이언트로부터 `SYN` 세그먼트를 받으면, 세션을 맺기위해 `SYN + ACK` 세그먼트를 전송한다.\r\n이는 연결수락을 의미하는 세그먼트이다.\r\n\r\n![WireShark로 캡쳐된 SYN + ACK 세그먼트](/post/network/tcp-ip/transport-layer/captured-segment-of-syn+ack.png)\r\n: { \"description\": \"WireShark로 캡쳐된 SYN + ACK 세그먼트\" }\r\n\r\n서버는 정확하게 `SYN`의 ISN +1을 `ACK`로 전송을 한것이 보인다. \r\n서버는 `1595116508`이라는 SYN을 보내며, 이때 서버의 상태는 `SYN_RECV` 상태이다.\r\n\r\n>클라이언트의 ISN인 `4248590219`에 `1`을 더한 `4248590220`을 `ACK`로 전송한것을 확인할 수 있다.\r\n: { \"type\": \"note\", \"icon\": \"info\" }\r\n\r\n### ACK::acknowledgment\r\n\r\n![클라이언트에서는 서버의 응답을 확인하기 위해 ACK를 보낸다.](/post/network/tcp-ip/transport-layer/ack-diagram-in-tcp.png)\r\n: { \"align\": \"center\", \"max-width\": \"400px\", \"description\": \"ACK 전송\" }\r\n\r\n클라이언트는 SYN + ACK 세그먼트를 받으면, 세션을 맺기위해 `ACK` 세그먼트를 전송한다.\r\n\r\n![WireShark로 캡쳐된 ACK 세그먼트](/post/network/tcp-ip/transport-layer/captured-segment-of-ack.png)\r\n: { \"description\": \"WireShark로 캡쳐된 ACK 세그먼트\" }\r\n\r\n클라이언트는 서버의 ISN +1을 `ACK`로 전송하며, 이때 클라이언트의 상태는 `ESTABLISHED` 상태이다.\r\n\r\n>서버의 ISN인 `1595116508`에 `1`을 더한 `1595116509`을 `ACK`로 전송한것을 확인할 수 있다.\r\n: { \"type\": \"note\", \"icon\": \"info\" }\r\n\r\n### 데이터 전송::data-send\r\n\r\n![서버와 클라이언트는 데이터를 전송한다.](/post/network/tcp-ip/transport-layer/data-send-diagram-in-tcp.png)\r\n: { \"align\": \"center\", \"max-width\": \"400px\", \"description\": \"데이터 전송\" }\r\n\r\n`ACK`로 세션이 맺어지는 순간부터 데이터를 전송할 수 있고, 데이터를 전송할 때마다 `ACK`를 받아야 한다.\r\n이는 수신측과 발신측 모두에 해당되는 내용이다.\r\n\r\n![WireShark로 캡쳐된 데이터 전송 세그먼트](/post/network/tcp-ip/transport-layer/captured-segment-of-data.png)\r\n: { \"description\": \"WireShark로 캡쳐된 데이터 전송 세그먼트\" }\r\n\r\n위 네 개의 각 세그먼트는 클라이언트와 서버가 데이터를 주고받는 과정을 보여준다.\r\n[HTTP]()는 `요청/응답` 방식이기 때문에 위처럼 클라이언트가 요청을 보내고, 서버가 응답을 보내는 방식으로 동작한다.\r\n\r\n그렇기 때문에 `1`번에서 클라이언트가 `GET /greeting`을 요철 했을 때 `2`번 서버가 ACK를 보내는 것을 볼 수 있다.\r\n반대로 서버가 `3`번에서 `200 OK`를 응답하면, 클라이언트가 `4`번에서 ACK를 보내는 것을 확인할 수 있다.\r\n\r\n>요청/응답 구조는 HTTP 스펙이므로 TCP 기준으로만 봤을때는 데이터 전송에대한 응답으로 ACK를 보내는 것이다.\r\n:{ \"type\": \"important\", \"icon\": \"warning-octagon\" }\r\n\r\n\r\n### FIN::finish\r\n\r\n연결 종료를 위한 통신과정은 `4-way Handshake`로 이루어 지며, `FIN`, `ACK`, `FIN`, `ACK` 세그먼트를 통해 처리된다.\r\n`FIN`은 세션을 종료하기 위헤 보내는 세그먼트이다.\r\n\r\n![클라이언트와 서버는 세션을 종료하기위해 FIN을 보낸다.](/post/network/tcp-ip/transport-layer/fin-diagram-in-tcp.png)\r\n: { \"align\": \"center\", \"max-width\": \"400px\", \"description\": \"FIN 전송\" }\r\n\r\n위의 이미지와 보는 보와 같이 세션이 연결 중인 상태(`ESTABLISHED`)에서 연결을 종료가 필요한 장치에서 `FIN` 세그먼트를 전송한다.\r\n실제로는 서버와 클라이언트 어디쪽에서든지 먼저 연결종료 요청을 할수 있지만, 여기서는 클라이언트가 먼저 `FIN` 세그먼트를 전송하였다.\r\n\r\n1. 클라이언트에서 연결종료를 위해 서버로 `FIN` 세그먼트로 전송하며, 이때 클라이언트의 상태는 `FIN_WAIT_1` 상태이다.\r\n2. 서버는 `FIN` 세그먼트를 받으면, `ACK` 세그먼트로 응답을 전송하며, 이때 서버의 상태는 `CLOSE_WAIT` 상태이다.\r\n3. 서버가 연결종료에 대한 준비를 모두 끝낸후 클라이언트에게 `FIN` 세그먼트를 전송하며, 이때 서버의 상태는 `LAST_ACK` 상태이다.\r\n4. 클라이언트는 `FIN` 세그먼트를 받으면, `ACK` 세그먼트로 응답을 전송하며, 이때 클라이언트의 상태는 `TIME_WAIT` 상태이다.\r\n5. 클라이언트는 `TIME_WAIT` 상태에서 `2MSL(Maximum Segment Lifetime)` 시간동안 대기하고, 이후에 연결이 종료되며, 이때 클라이언트의 상태는 `CLOSED` 상태이다.\r\n\r\n\r\n>TCP는 연결의 신뢰성을 보장하기 위해서는 많은 네트워크 비용이 필요하다.\r\n: { \"type\": \"important\", \"icon\": \"warning-octagon\" }\r\n"
  },
  {
    "path": "/docs/network/tcp-ip/network-layer",
    "header": {
      "layout": "post",
      "title": "네트워크 계층 (Network Layer)",
      "tags": [
        "Network",
        "Network Layer",
        "OSI",
        "OSI 7 Layer",
        "TCP/IP"
      ],
      "date": 1614599400000,
      "thumbnail": "/post/network/tcp-ip/network-layer/ip-packet-structure.png",
      "profile-image": "/post/profile/profile1.jpg",
      "current-company": "Cubic INC",
      "current-position": "SI Researcher",
      "summary": "네트워크 계층",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "네트워크",
        "TCP/IP"
      ],
      "images": [
        {
          "src": "/post/network/tcp-ip/network-layer/ip-packet-structure.png",
          "alt": "IP 패킷 구조"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "네트워크 계층이란?::what-is-network-layer",
            "title": "네트워크 계층이란?",
            "fragment": "what-is-network-layer",
            "children": []
          },
          {
            "rank": 2,
            "origin": "패킷 구조::packet-structure",
            "title": "패킷 구조",
            "fragment": "packet-structure",
            "children": []
          },
          {
            "rank": 2,
            "origin": "라우팅::routing",
            "title": "라우팅",
            "fragment": "routing",
            "children": []
          }
        ]
      }
    },
    "description": "네트워크 계층은 OSI 7 Layer, L3로 IP 주소 지정 방식으로 데이터를 전송하는 계층이다.\r\n주요 동작으로는 IP 패킷을 생성하고 목적지까지 라우팅을 처리한다.",
    "content": "\r\n## 네트워크 계층이란?::what-is-network-layer\r\n\r\n네트워크 계층은 OSI 7 Layer 중 3번째 계층으로, 데이터를 전송하는 데 사용되는 IP 주소 지정 방식을 사용한다.\r\n\r\n주요 기능으로는 출발지에서 목적지까지 데이터를 전송하기 위한 최적의 경로를 결정한다. \r\nIP 주소를 이용하여 논리적 주소지정 방식을 사용하는데, 이는 네트워크 상의 장치를 고유하게 식별한다.\r\n\r\n네트워크 계층에서는 데이터 전송시, [전송계층]()으로 부터 전달받은 데이터를 패킷으로 분할한다. 또한 들어온 패킷을 재조립하여 상위 계층으로 전달한다.\r\n\r\n## 패킷 구조::packet-structure\r\n\r\n![IP 패킷 구조](/post/network/tcp-ip/network-layer/ip-packet-structure.png)\r\n: { \"align\": \"center\", \"max-width\": \"700px\", \"description\": \"IP 패킷 구조\" }\r\n\r\nIP 패킷은 크게 헤더와 페이로드로 구성되며 IP 패킷은 [데이터 링크 계층](/docs/network/tcp-ip/data-link-layer) 프레임의 페이로드이다.\r\n\r\n일반적으로 헤더는 20바이트이며 나머지는 옵션과 페이로드(세그먼트)이다.\r\n\r\n* **Version**: IP 버전을 나타내며 4비트로 표현된다.(IPv4: 0b0100, IPv6: 0b0110)\r\n* **IHL**(**I**nternet **H**eader **L**ength): IP 헤더 길이를 나타내며 4비트로 표현된다. (최소 20바이트, 최대 60바이트)\r\n* **DSCP**(**D**ifferentiated **S**ervices **C**ode **P**oint): 패킷의 우선순위와 처리방식을 나타내며, 6비트로 표현된다.\r\n  * 0에서 63까지의 값을 가질 수 있으며 각 값은 특정한 서비스 클래스를 나타낸다.\r\n* **ECN**(**E**xplicit **C**ongestion **N**otification): 네트워크의 혼잡을 알리는데 사용되며, 2비트로 표현된다.\r\n* **Total Length**: IP 패킷의 전체 길이를 나타내며, 16비트로 표현된다.\r\n* **Identification**: 패킷의 식별자로 패킷 조각들을 구분하는데 사용되며, 16비트로 표현된다.\r\n* **Flags**: 패킷 조각화를 나타내는데 사용되며, 3비트로 표현된다.\r\n* **Fragment Offset**: 조각화된 패킷의 상대적 위치를 나타내며, 13비트로 표현된다.\r\n* **Time to Live**: 패킷이 네트워크에서 살아있을 수 있는 시간을 나타내며, 8비트로 표현된다.\r\n* **Protocol**: 패킷의 전송계층의 프로토콜(TCP:6, UDP:7)을 나타내며, 8비트로 표현된다.\r\n* **Header Checksum**: 헤더의 오류를 검출하는데 사용되며, 16비트로 표현된다.\r\n* **Source IP Address**: 출발지 IP 주소를 나타내며, 32비트로 표현된다.\r\n* **Destination IP Address**: 목적지 IP 주소를 나타내며, 32비트로 표현된다.\r\n* **Options**: 옵션 필드로, 0바이트에서 40바이트까지 가질 수 있다.\r\n  * 옵션필드는 IHL 필드에 의해 길이를 알 수 있기 떄문에, Payload의 시작을 알 수 있다.\r\n\r\n\r\n## 라우팅::routing\r\n\r\n라우팅은 네트워크 계층에서 목적지까지 데이터를 전송하기 위한 최적의 경로를 결정하는 과정이다.\r\n각 L3 계층은 IP 주소 기반 라우팅 테이블을 갖고 있고, 이를 이용해 패킷의 목적지를 결정한다.\r\n\r\n```text::mac의 라우팅 테이블\r\nnetstat -nr\r\nRouting tables\r\n\r\nInternet:\r\nDestination        Gateway            Flags               Netif Expire\r\ndefault            192.168.0.1        UGScg                 en0       \r\n127                127.0.0.1          UCS                   lo0       \r\n127.0.0.1          127.0.0.1          UH                    lo0       \r\n169.254            link#12            UCS                   en0      !\r\n192.168.0          link#12            UCS                   en0      !\r\n192.168.0.1/32     link#12            UCS                   en0      !\r\n192.168.0.1        0:1d:ec:83:2b:37   UHLWIir               en0   1199\r\n192.168.0.11       32:f2:70:c7:90:20  UHLWIi                en0    943\r\n192.168.0.67/32    link#12            UCS                   en0      !\r\n192.168.0.67       f2:af:d9:77:b1:a1  UHLWI                 lo0       \r\n224.0.0/4          link#12            UmCS                  en0      !\r\n224.0.0.251        1:0:5e:0:0:fb      UHmLWI                en0       \r\n255.255.255.255/32 link#12            UCS                   en0      !\r\n```\r\n\r\n"
  },
  {
    "path": "/docs/computer-science/operating-system/system-call",
    "header": {
      "layout": "wiki",
      "date": 1614452640000,
      "title": "시스템 콜 (System Call)",
      "tags": [
        "Operating System",
        "System Call"
      ],
      "summary": "시스템 콜",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "컴퓨터",
        "operating-system"
      ],
      "images": [
        {
          "src": "/post/computer-science/operating-system/system-call/copy-file.png",
          "alt": "cp 명령으로 파일 복사"
        },
        {
          "src": "/post/computer-science/operating-system/system-call/process-of-system-call.png",
          "alt": "시스템 콜 호출"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "시스템 콜이란?::what-is-system-call",
            "title": "시스템 콜이란?",
            "fragment": "what-is-system-call",
            "children": []
          },
          {
            "rank": 2,
            "origin": "예제::example",
            "title": "예제",
            "fragment": "example",
            "children": []
          },
          {
            "rank": 2,
            "origin": "시스템콜의 동작 과정::how-system-call-works",
            "title": "시스템콜의 동작 과정",
            "fragment": "how-system-call-works",
            "children": [
              {
                "rank": 3,
                "origin": "API와 시스템 콜::api-and-system-call",
                "title": "API와 시스템 콜",
                "fragment": "api-and-system-call",
                "children": []
              },
              {
                "rank": 3,
                "origin": "시스템콜 인터페이스::system-call-interface",
                "title": "시스템콜 인터페이스",
                "fragment": "system-call-interface",
                "children": []
              }
            ]
          },
          {
            "rank": 2,
            "origin": "시스템 콜의 유형::types-of-system-calls",
            "title": "시스템 콜의 유형",
            "fragment": "types-of-system-calls",
            "children": [
              {
                "rank": 3,
                "origin": "프로세스 제어::process-control",
                "title": "프로세스 제어",
                "fragment": "process-control",
                "children": []
              },
              {
                "rank": 3,
                "origin": "파일 조작::file-manipulation",
                "title": "파일 조작",
                "fragment": "file-manipulation",
                "children": []
              },
              {
                "rank": 3,
                "origin": "장치 관리::device-management",
                "title": "장치 관리",
                "fragment": "device-management",
                "children": []
              },
              {
                "rank": 3,
                "origin": "정보 유지::information-maintenance",
                "title": "정보 유지",
                "fragment": "information-maintenance",
                "children": []
              },
              {
                "rank": 3,
                "origin": "통신과 보호::communication-and-protection",
                "title": "통신과 보호",
                "fragment": "communication-and-protection",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "",
    "content": "\r\n## 시스템 콜이란?::what-is-system-call\r\n\r\n시스템 콜(System Call)은 사용자 프로그램 또는 시스템 프로그램이 시스템 자원을 사용하기 위해 커널에게 요청하는 인터페이스이다.\r\n우리가 흔히 알고있는 표준 라이브러리(`C의 stdio.h: fopen(), fread(), fwrite()`)도 내부적으로는 시스템 콜(`C로 구현`)을 호출하여 커널에게 요청한다.\r\n\r\n시스템 자원은 커널에서 관리하기 때문에 외부에서 직접적으로 사용할 수 없어, 이를 위해 커널에서 제공하는 인터페이스를 사용하여 시스템 콜을 호출할 수 있다.\r\n이러한 호출은 일반적으로 C/C++로 작성된 함수 형태로 제공된다.\r\n\r\n---\r\n\r\n## 예제::example\r\n\r\n::text-wrapping\r\n\r\n![cp 명령으로 파일 복사](/post/computer-science/operating-system/system-call/copy-file.png)\r\n\r\n예를 들어 한 파일로부터 데이터를 읽어서 다른 파일로 복사하는 간단한 프로그램을 작성한다 가정해 보자.\r\n\r\n`UNIX`의 CP 명령(`cp in.txt out.txt`)은 두개의 파일 이름을 인자로 받아서 첫번째 파일로부터 데이터를 읽어서 두번째 파일로 데이터를 쓴다.\r\n먼저 인자를 받고 나면 파일을 열고, 출력파일을 생성하여 출력 파일도 연다. 각각의 연산은 별개의 시스템콜(`open()`)을 호출한다.\r\n\r\n하지만 이와 같은 경우는 파일을 복사하기전 모든 검증과정이 끝났을 때의 상황이다.\r\n만약 입력 파일(`in.txt`)이 존재하지 않거나, 그 파일에 대한 접근이 금지된 경우 프로그램은 에러 메세지를 출력하고 비정삭적으로 종료(또 다른 시스템콜)를 해야한다.\r\n\r\n입력 파일에 대한 검증이 완료되어도, 출력파일을 생성할 때, 동일한 이름을 가진 파일이 이미 존재하면 기존 파일을 삭제(delete)/변경(write) 또는 새로운 파일 이름으로 생성(create)할 수 있다.\r\n이런 복사라는 과정에서도 다양한 시스템콜이 여러번 호출된다.\r\n\r\n::{ \"align\": \"right\" }\r\n\r\n**연속된 시스템 콜의 예**\r\n\r\n1. 입력파일 이름 획득\r\n    1. 화면에 프롬프트 출력\r\n    2. 입력파일 받아들임\r\n2. 출력파일 이름 획득\r\n    1. 화면에 프롬프트 출력\r\n    2. 출력파일 받아들임\r\n3. 입력파일 열기\r\n    1. 파일이 존재하지 않을 경우, 비정상적으로 종료\r\n4. 출력파일 생성\r\n    1. 파일이 존재할 경우, 비정상적으로 종료\r\n5. 루프 (읽기가 실패할 때까지 반복)\r\n    1. 입력파일로 부터 읽어 들임\r\n    2. 출력파일에 쓰기\r\n6. 입력파일 닫기\r\n7. 출력파일 닫기\r\n8. 화면에 완료 메세지 출력\r\n9. 종료\r\n\r\n## 시스템콜의 동작 과정::how-system-call-works\r\n\r\n시스템 콜은 실제 동작이 아니다. 시스템 콜은 커널 수준에서 제공하는 인터페이스이며, 그 구현은 커널함수로 이루어지게 된다.\r\n따라서 시스템 콜은 c로 만들어지더 라도 커널내에서 제어하려는 자원에 따라 [어셈블리어]() 또는 c로 작성된 함수로 구현된다.\r\n\r\nc언어로 작성된 표준 라이브러리(`libc`)에 래핑 API가 제공되는데, 이는 아래와 같다:\r\n\r\n1. glibc: GNU C 라이브러리\r\n    * [저장소](https://sourceware.org/git/glibc.git)\r\n    * read()함수 정의: [`/include/unistd.h`](https://sourceware.org/git/?p=glibc.git;a=blob;f=include/unistd.h)\r\n    * read()함수 구현: [`/sysdeps/unix/sysv/linux/read.c`](https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/read.c)\r\n    * 특징\r\n        * Linux 배포판의 표준라이브러리\r\n        * 가장 광범위하게 사용됨\r\n        * 가장 완전한 POSIX 구현\r\n    * 사용되는 시스템: Ubuntu, Fedora, CentOS, Debian 등\r\n2. musl: musl libc\r\n    * [저장소](https://git.musl-libc.org/cgit/musl)\r\n    * read()함수 정의: [`/include/unistd.h`](https://git.musl-libc.org/cgit/musl/tree/include/unistd.h)\r\n    * read()함수 구현: [`/src/unistd/read.c`](https://git.musl-libc.org/cgit/musl/tree/src/unistd/read.c)\r\n    * 특징\r\n        * 경량화된 C표준 라이브러리\r\n        * 임베디드 시스템과 작은 Linux 배포판에 최적화\r\n        * 최소한의 리소스 사용\r\n    * 사용되는 시스템: Alpine Linux, Void Linux 등\r\n4. BSD libc\r\n    * [저장소](https://github.com/freebsd/freebsd-src)\r\n    * read()함수 정의: [`/include/unistd.h`](https://github.com/freebsd/freebsd-src/blob/main/include/unistd.h)\r\n    * read()함수 구현: [`/lib/libc/sys/read.c`](https://github.com/freebsd/freebsd-src/blob/main/lib/libc/sys/read.c)\r\n    * 특징\r\n        * BSD(Berkeley Software Distribution) 계열의 표준 라이브러리\r\n        * POSIX 표준 준수\r\n        * Unix 시스템 고유의 확장 기능 제공\r\n    * 사용되는 시스템: FreeBSD, NetBSD, OpenBSD, MacOS/iOS 등\r\n\r\n```c\r\n#include <unistd.h> //unix standard\r\n\r\nssize_t read(int fd, void *buf, size_t count) {\r\n    return syscall_cp(SYS_read, fd, buf, count);\r\n}\r\n```\r\n\r\n이 코드는 `musl libc`의 read 시스템콜 래핑 API이다. 각 시그니처는 다음을 의미한다:\r\n\r\n1. `fd`: 읽으려는 파일 디스크립터\r\n2. `buf`: 데이터를 읽어들일 버퍼\r\n3. `count`: 버퍼로 읽어 들일 수 있는 최대 바이트 수\r\n\r\n읽기가 성공한 경우 읽어 들인 바이트 수(ssize_t)를 반환하고, 오류가 발생한 경우 `-1`을 반환한다.\r\n\r\n> Unix/Linux 시스템에서는 `man read` 명령어로 man(manual) 페이지에서 시스템의 모든 명령어, 함수, 시스템콜 등에 대한 정보를 확인할 수 있다.\r\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\" }\r\n\r\n![시스템 콜 호출](/post/computer-science/operating-system/system-call/process-of-system-call.png)\r\n:{ \"max-width\": \"400px\", \"align\": \"center\", \"description\": \"시스템 콜 호출 과정\" }\r\n\r\n시스템 콜 호출은 다음과 같이 처리된다.\r\n\r\n1. 사용자 프로그램은 시스템 콜을 호출한다. (syscall_cp()): 운영체제 에서\r\n   제공하는 [Wrapping API](https://git.musl-libc.org/cgit/musl/tree/src/unistd/read.c) 호출\r\n2. 시스템 콜인터페이스는 사용자 요청을 검증(인자 유효성, 권한, 리소스 가용성 등)하고 커널에 전달한다.\r\n3. 커널로 전달 전 CPU는 커널모드로 전환되고, 사용자\r\n   요청을 [시스템 콜 테이블](https://github.com/torvalds/linux/blob/v5.6/arch/x86/entry/syscalls/syscall_64.tbl)을 통해 시스템 콜 번호로\r\n   매핑한다.\r\n4. CPU는 실행전 커널모드로 전환하여 커널 함수를 실행하고, 사용자모드로 전환하고 반환값은 사용자 프로그램으로 전달하며, 제어또한 사용자 프로그램으로 넘어간다.\r\n\r\n### API와 시스템 콜::api-and-system-call\r\n\r\n앞서 시스템 콜 인터페이스는 사용자의 요청을 검증하고 커널 함수로 전달하는 역할을 한다고 했다.\r\n그렇다면 어떤 방식으로 사용자의 요청을 검증하는 것일까?\r\n\r\n시스템에서 제공되는 Wrapping API는 사용자 공간에서 `libc`로 제공된다.  \r\n사용자가 `read()` API(**glibc** 기준)를 사용하는 시점부터 알아보자.\r\n\r\n```c::Wrapping API 호출\r\n// include/unistd.h\r\nextern ssize_t __libc_read (int __fd, void *__buf, size_t __n);\r\n\r\n// sysdeps/unix/sysv/linux/read.c\r\nssize_t __libc_read (int fd, void *buf, size_t nbytes) {\r\n  return SYSCALL_CANCEL (read, fd, buf, nbytes);\r\n}\r\n\r\nlibc_hidden_def (__libc_read)\r\n\r\nlibc_hidden_def (__read)\r\nweak_alias (__libc_read, __read)\r\nlibc_hidden_def (read)\r\nweak_alias (__libc_read, read) //외부에서는 read()로 호출하며 alias로 __libc_read()를 호출한다.\r\n```\r\n\r\n`__libc_read()` 함수는 시스템콜 인터페이스(`SYSCALL_CANCEL`)로 read 시스템콜을 호출한다.\r\n이 내부적으로 인자값을 어떻게 전달하고 내부적인 시스템콜 매크로를 어떻게 선택하는지 알 수 있다.\r\n\r\n::code-group\r\n\r\n```c::1. SYSCALL_CANCEL 매크로\r\n//1. 연결된 인터페이스 매크로는 내부적으로 INLINE_SYSCALL_CALL() 매크로를 호출한다. \r\n# define SYSCALL_CANCEL(...) \\\r\n  __SYSCALL_CANCEL_CALL (__VA_ARGS__) //(__VA_ARGS__는 가변인자)\r\n```\r\n\r\n```c::2. __SYSCALL_CANCEL_CALL 매크로\r\n#define __SYSCALL_CANCEL_CALL(...) \\\r\n  __SYSCALL_CANCEL_DISP (__SYSCALL_CANCEL, __VA_ARGS__)\r\n```\r\n\r\n```c::3. __INLINE_SYSCALL_DISP 매크로\r\n//앞서 전달한 __SYSCALL_CANCEL 값을 b로 받는다.\r\n//요청 당시 매개변수 (read, fd, buf, nbytes)를 __SYSCALL_CANCEL_NARGS()로 전달한다. \r\n#define __SYSCALL_CANCEL_DISP(b,...) \\\r\n  __SYSCALL_CANCEL_CONCAT (b,__SYSCALL_CANCEL_NARGS(__VA_ARGS__))(__VA_ARGS__)\r\n//여기서 중요한점은 __SYSCALL_CANCEL_CONCAT은 매크로 이름을 만드는 매크로이다.\r\n//즉 b: __SYSCALL_CANCEL 와 __SYSCALL_CANCEL_NARGS(__VA_ARGS__)의 결과값을 인자로 받는다.\r\n\r\n//상위에 작성된 매크로 이름 생성 매크로 \r\n#define __SYSCALL_CANCEL_CONCAT_X(a,b)     a##b //a와 b를 붙인다.\r\n#define __SYSCALL_CANCEL_CONCAT(a,b)       __SYSCALL_CANCEL_CONCAT_X (a, b)\r\n```\r\n\r\n```c::4. __SYSCALL_CANCEL_NARGS 매크로\r\n//NARGS는 \"Number of Arguments\"의 약자로, 가변인자의 개수를 반환한다.\r\n#define __SYSCALL_CANCEL_NARGS_X(a,b,c,d,e,f,g,h,n,...) n\r\n#define __SYSCALL_CANCEL_NARGS(...) \\\r\n  __SYSCALL_CANCEL_NARGS_X (__VA_ARGS__,7,6,5,4,3,2,1,0,)\r\n//위처럼 되면 __SYSCALL_CANCEL_NARGS(read, fd, buf, nbytes)는 3를 반환한다.\r\n//a=read, b=fd, c=buf, d=nbytes, e=7, f=6, g=5, h=4, n=3\r\n```\r\n\r\n```c::5. 호출할 매크로 선택\r\n#define __SYSCALL_CANCEL_DISP(b,...) \\\r\n  __SYSCALL_CANCEL_CONCAT (b,__SYSCALL_CANCEL_NARGS(__VA_ARGS__))(__VA_ARGS__)\r\n//해당 코드의 매크로를 치환하면 아래처럼 된다.\r\n//b: __SYSCALL_CANCEL\r\n//__SYSCALL_CANCEL_NARGS(read, fd, buf, nbytes): 3\r\n//__SYSCALL_CONCAT(__SYSCALL_CANCEL, 3)(read, fd, buf, nbytes): __SYSCALL_CANCEL3(read, fd, buf, nbytes)\r\n\r\n//결과적으로 __SYSCALL_CANCEL3(read, fd, buf, nbytes) 매크로를 호출한다.\r\n```\r\n\r\n::\r\n\r\n위에서는 `__SYSCALL_CANCEL3(read, fd, buf, nbytes)` 매크로를 호출하였다.\r\n이제 해당 매크로를 시점으로 어떻게 이어지는지 알아 보자\r\n\r\n::code-group\r\n\r\n```c::1. __SYSCALL_CANCEL3 매크로 호출\r\n/* sysdeps\\unix\\sysv\\linux\\mips\\mips64\\n32\\syscall_types.h */\r\ntypedef long long int __syscall_arg_t;\r\n//Syscall Safe Convert\t\t    \r\n#define __SSC(__x) ((__syscall_arg_t) (__typeof__ ((__x) - (__x))) (__x))\r\n\r\n/* sysdeps\\unix\\sysdep.h */\r\n# define __SYSCALL_CANCEL7_ARG_DEF\r\n# define __SYSCALL_CANCEL7_ARCH_ARG_DEF\r\n# define __SYSCALL_CANCEL7_ARG\r\n\r\nlong int __syscall_cancel (__syscall_arg_t arg1, __syscall_arg_t arg2,\r\n\t\t\t   __syscall_arg_t arg3, __syscall_arg_t arg4,\r\n\t\t\t   __syscall_arg_t arg5, __syscall_arg_t arg6,\r\n\t\t\t   __SYSCALL_CANCEL7_ARG_DEF\r\n\t\t\t   __syscall_arg_t nr) attribute_hidden;\r\n\t\t\t   \r\n#define __SYSCALL_CANCEL3(name, a1, a2, a3) \\\r\n  __syscall_cancel (__SSC (a1), __SSC (a2), __SSC (a3), 0, 0, 0,\t\\\r\n\t\t    __SYSCALL_CANCEL7_ARG __NR_##name)\r\n```\r\n\r\n```c::2. ntpl/cancellation.c 함수 호출\r\n//Native POSIX Thread Library (NPTL)의 취소 기능을 위한 코드\r\nlong int\r\n__syscall_cancel (__syscall_arg_t a1, __syscall_arg_t a2,\r\n\t\t  __syscall_arg_t a3, __syscall_arg_t a4,\r\n\t\t  __syscall_arg_t a5, __syscall_arg_t a6,\r\n\t\t  __SYSCALL_CANCEL7_ARG_DEF __syscall_arg_t nr)\r\n{\r\n  //__internal_syscall_cancel(fd, buf, nbytes, 0, 0, 0, 0)\r\n  int r = __internal_syscall_cancel (a1, a2, a3, a4, a5, a6,\r\n\t\t\t\t     __SYSCALL_CANCEL7_ARG nr);\r\n  return __glibc_unlikely (INTERNAL_SYSCALL_ERROR_P (r))\r\n\t ? SYSCALL_ERROR_LABEL (INTERNAL_SYSCALL_ERRNO (r))\r\n\t : r;\r\n}\r\n```\r\n\r\n```c::3. ntpl/cancellation.c 함수 호출2\r\n/* Called by the INTERNAL_SYSCALL_CANCEL macro, check for cancellation and\r\n   returns the syscall value or its negative error code.  */\r\nlong int\r\n__internal_syscall_cancel (__syscall_arg_t a1, __syscall_arg_t a2,\r\n\t\t\t   __syscall_arg_t a3, __syscall_arg_t a4,\r\n\t\t\t   __syscall_arg_t a5, __syscall_arg_t a6,\r\n\t\t\t   __SYSCALL_CANCEL7_ARG_DEF\r\n\t\t\t   __syscall_arg_t nr)\r\n{\r\n  long int result;\r\n  struct pthread *pd = THREAD_SELF;\r\n  \r\n  ...\r\n\r\n  /* Call the arch-specific entry points that contains the globals markers\r\n     to be checked by SIGCANCEL handler.  */\r\n  //__syscall_cancel_arch(&pd->cancelhandling, __NR_read, fd, buf, nbytes, 0, 0, 0)\r\n  result = __syscall_cancel_arch (&pd->cancelhandling, nr, a1, a2, a3, a4, a5,\r\n\t\t\t          a6 __SYSCALL_CANCEL7_ARCH_ARG7);\r\n\t\t\t          \r\n  ch = atomic_load_relaxed (&pd->cancelhandling);\r\n  \r\n  if (result == -EINTR && cancel_enabled_and_canceled (ch))\r\n    __syscall_do_cancel ();\r\n\r\n  return result;\r\n}\r\n```\r\n\r\n```asm::4. 실제 시스템콜 호출\r\n#include <sysdep.h>\r\n#include <descr-const.h>\r\n/* sysdeps/unix/sysv/linux/mips/x86_64/syscall_cancel.S */\r\n/* long int [rax] __syscall_cancel_arch (volatile int *cancelhandling [%rdi],\r\n\t\t\t\t\t __syscall_arg_t nr   [%rsi],\r\n\t\t\t\t\t __syscall_arg_t arg1 [%rdx],\r\n\t\t\t\t\t __syscall_arg_t arg2 [%rcx],\r\n\t\t\t\t\t __syscall_arg_t arg3 [%r8],\r\n\t\t\t\t\t __syscall_arg_t arg4 [%r9],\r\n\t\t\t\t\t __syscall_arg_t arg5 [SP+8],\r\n\t\t\t\t\t __syscall_arg_t arg6 [SP+16])  */\r\n\r\nENTRY (__syscall_cancel_arch)\r\n\t.globl __syscall_cancel_arch_start\r\n__syscall_cancel_arch_start:\r\n\r\n\t/* if (*cancelhandling & CANCELED_BITMASK)\r\n\t     __syscall_do_cancel()  */\r\n\tmov    (%rdi),%eax\r\n\ttestb  $TCB_CANCELED_BITMASK, (%rdi)\r\n\tjne    __syscall_do_cancel\r\n\r\n\t/* Issue a 6 argument syscall, the nr [%rax] being the syscall\r\n\t   number.  */\r\n\tmov    %rdi,%r11\r\n\tmov    %rsi,%rax\r\n\tmov    %rdx,%rdi\r\n\tmov    %rcx,%rsi\r\n\tmov    %r8,%rdx\r\n\tmov    %r9,%r10\r\n\tmov    8(%rsp),%r8\r\n\tmov    16(%rsp),%r9\r\n\tmov    %r11,8(%rsp)\r\n\tsyscall\r\n\r\n\t.globl __syscall_cancel_arch_end\r\n__syscall_cancel_arch_end:\r\n\tret\r\nEND (__syscall_cancel_arch)\r\n```\r\n\r\n::\r\n\r\n`__syscall_cancel` 함수에서 `__NR_read`값이 0으로 변경되는\r\n이유는 [x86_64 시스템콜 매크로](https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/x86_64/64/arch-syscall.h;h=dfc10d0c7e8a8f1e3cfc81c00096bec4d016b3f0;hb=HEAD)\r\n에 0으로 정의 되어있기 때문이다.  \r\n실제 시스템콜 호출코드를 보면 [레지스터](/wiki/register)에 인자값들을 세팅하고 마지막에 `syscall` 명령어로 시스템 콜을 호출한다.\r\n위 내용으로 Wrapping API(`glibc`)에서는 호출할 시스템콜 정보를 찾고 인자값을 레지스터에 적재하여 시스템콜을 호출하는 과정을 알 수 있다.\r\n\r\n또한 `syscall` 명령은 하드웨어 레벨에서 커널모드로 전환하며, 커널의 시스템콜을 호출하는 역할을 한다.\r\n\r\n### 시스템콜 인터페이스::system-call-interface\r\n\r\n앞서 `glibc`에서 각 인자 값을 레지스터에 저장하고, `syscall` 명령어로 시스템콜을 호출하기 까지 과정을 보았었다.\r\n이제 커널모드로 변경된 후 제어는 커널로 넘어가게 되는데, 이때 시스템콜 인터페이스를 통해 시스템콜을 호출한다.\r\n\r\n`x86` 아키텍쳐 64비트 리눅스의 시스템콜 인터페이스의 시작점은 `arch/x86/entry/entry_64.S` 파일이다.\r\n어셈블러로 작성된 이코드는 아래의 순서로 실행된다.\r\n\r\n::code-group\r\n\r\n```asm::1. entry_SYSCALL_64 레이블\r\nSYM_CODE_START(entry_SYSCALL_64)\r\n\tUNWIND_HINT_ENTRY\r\n\tENDBR\r\n\r\n\tswapgs\r\n\t/* tss.sp2 is scratch space. */\r\n\tmovq\t%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)\r\n\tSWITCH_TO_KERNEL_CR3 scratch_reg=%rsp\r\n\tmovq\tPER_CPU_VAR(pcpu_hot + X86_top_of_stack), %rsp\r\n```\r\n\r\n```asm::2. entry_SYSCALL_64_safe_stack 레이블\r\nSYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)\r\n\tANNOTATE_NOENDBR\r\n\r\n\t/* Construct struct pt_regs on stack */\r\n\tpushq\t$__USER_DS\t\t\t\t/* pt_regs->ss */\r\n\tpushq\tPER_CPU_VAR(cpu_tss_rw + TSS_sp2)\t/* pt_regs->sp */\r\n\tpushq\t%r11\t\t\t\t\t/* pt_regs->flags */\r\n\tpushq\t$__USER_CS\t\t\t\t/* pt_regs->cs */\r\n\tpushq\t%rcx\t\t\t\t\t/* pt_regs->ip */\r\n```\r\n\r\n```asm::3. entry_SYSCALL_64_after_hwframe 레이블\r\nSYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)\r\n\tpushq\t%rax\t\t\t\t\t/* pt_regs->orig_ax */\r\n\r\n\tPUSH_AND_CLEAR_REGS rax=$-ENOSYS\r\n\r\n\t/* IRQs are off. */\r\n\tmovq\t%rsp, %rdi\r\n\t/* Sign extend the lower 32bit as syscall numbers are treated as int */\r\n\t//시스템콜 번호 검증\r\n\tmovslq\t%eax, %rsi\r\n\r\n\t/* clobbers %rax, make sure it is after saving the syscall nr */\r\n\tIBRS_ENTER\r\n\tUNTRAIN_RET\r\n\tCLEAR_BRANCH_HISTORY\r\n\t\r\n\t...\r\n    //시스템콜 래퍼 함수 호출\r\n\tcall\tdo_syscall_64\t\t/* returns with IRQs disabled */\r\n\r\n    ..\r\n```\r\n\r\n::\r\n\r\n여기까지는 시스템콜 인터페이스에서 검증하는 코드였고, 이제 시스템콜 레퍼에서 실제 시스템콜을 호출하는 코드를 살펴보자.\r\n\r\n::code-group\r\n\r\n```c::common.c\r\nstatic __always_inline bool do_syscall_x64(struct pt_regs *regs, int nr)\r\n{\r\n\t/*\r\n\t * Convert negative numbers to very high and thus out of range\r\n\t * numbers for comparisons.\r\n\t */\r\n\tunsigned int unr = nr;\r\n\r\n\tif (likely(unr < NR_syscalls)) {\r\n\t\tunr = array_index_nospec(unr, NR_syscalls);\r\n\t\tregs->ax = x64_sys_call(regs, unr);\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n```\r\n\r\n```c::syscall_64.c\r\n#define __SYSCALL(nr, sym) __x64_##sym,\r\nconst sys_call_ptr_t sys_call_table[] = {\r\n#include <asm/syscalls_64.h>\r\n};\r\n#undef  __SYSCALL\r\n\r\n#define __SYSCALL(nr, sym) case nr: return __x64_##sym(regs);\r\nlong x64_sys_call(const struct pt_regs *regs, unsigned int nr)\r\n{\r\n\tswitch (nr) {\r\n\t#include <asm/syscalls_64.h>\r\n\tdefault: return __x64_sys_ni_syscall(regs);\r\n\t}\r\n};\r\n```\r\n\r\n::\r\n\r\n시스템콜 래퍼이다. 실제로 시스템콜을 매핑하는 코드는 빌드 타임에 동작으로 만들어진다.\r\n[`Makefile`](https://github.com/torvalds/linux/blob/v5.6/arch/x86/entry/syscalls/Makefile)에는 시스템콜 테이블에 대해 시스템콜로 연결하는 코드를\r\n생성하는 코드가 있다.\r\n[시스템 콜 테이블](https://github.com/torvalds/linux/blob/v5.6/arch/x86/entry/syscalls/syscall_64.tbl)에도 아래와 같이 나와있다.\r\n\r\n```text::syscall_64.tbl\r\n\r\n# The __x64_sys_*() stubs are created on-the-fly for sys_*() system calls\r\n#\r\n# The abi is \"common\", \"64\" or \"x32\" for this file.\r\n#\r\n0\tcommon\tread\t\t\tsys_read\r\n1\tcommon\twrite\t\t\tsys_write\r\n2\tcommon\topen\t\t\tsys_open\r\n...\r\n```\r\n\r\n즉 위에서 호출한 `__x64_sys_ni_syscall()` 함수는 전달하는 시스템 콜 번호로 시스템콜을 찾는다.\r\n시스템콜 함수이름은 `__x64_sys_*`로 시작하는데, 이는 빌드타임에 생성되는 코드이다. 읽기를 예로 들면 `__x64_sys_read()` 함수를 호출한다.\r\n\r\n`__x64_sys_read()` 함수는 실제로 정의되어 있지는 않지만 컴파일타임에 매크로를 통해 `SYSCALL_DEFINE3(read, ...)`으로 확장된다.\r\n결과적으로 아래의 코드를 호출하게된다.\r\n\r\n::code-group\r\n\r\n```c::SYSCALL_DEFINE3 함수\r\nSYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)\r\n{\r\n\treturn ksys_read(fd, buf, count);\r\n}\r\n```\r\n\r\n```c::ksys_read 함수\r\nssize_t ksys_read(unsigned int fd, char __user *buf, size_t count)\r\n{\r\n\tCLASS(fd_pos, f)(fd);\r\n\tssize_t ret = -EBADF;\r\n\r\n\tif (!fd_empty(f)) {\r\n\t\tloff_t pos, *ppos = file_ppos(fd_file(f));\r\n\t\tif (ppos) {\r\n\t\t\tpos = *ppos;\r\n\t\t\tppos = &pos;\r\n\t\t}\r\n\t\tret = vfs_read(fd_file(f), buf, count, ppos);\r\n\t\tif (ret >= 0 && ppos)\r\n\t\t\tfd_file(f)->f_pos = pos;\r\n\t}\r\n\treturn ret;\r\n}\r\n```\r\n\r\n::\r\n\r\n여기까지가 커널코드고 `ksys_read` 커널 함수 내부에서 파일을 읽는 실제 로직을 수행한다.\r\n커널함수의 결과는 시스템콜 인터페이스를 통해 다시 **사용자 프로그램으로 전달**된다.\r\n\r\n\r\n---\r\n\r\n\r\n## 시스템 콜의 유형::types-of-system-calls\r\n\r\n시스템콜은 다섯가지 중요한 유형으로 나눌 수 있다:\r\n\r\n1. 프로세스 제어\r\n2. 파일 조작\r\n3. 장치 관리\r\n4. 정보 유지\r\n5. 통신과 보호\r\n\r\n### 프로세스 제어::process-control\r\n\r\n* 생성(fork), 중지(abort), 종료(exit)\r\n* 적재(load), 실행(execute)\r\n* 프로세스 속성(attributes) 조회, 변경\r\n* 시간 대기\r\n* 이벤트 대기(wait event), 알림(signal event)\r\n* 메모리 할당 및 자유화\r\n\r\n### 파일 조작::file-manipulation\r\n\r\n* 파일 생성(create file), 삭제(delete file)\r\n* 열기(open), 닫기(close)\r\n* 읽기, 쓰기, 위치 변경(reposition)\r\n* 파일 속성 조회, 변경\r\n\r\n### 장치 관리::device-management\r\n\r\n* 장치 요청(request devices), 해제(release devices)\r\n* 읽기, 쓰기, 위치 변경(reposition)\r\n* 장치 속성(attributes) 조회, 변경\r\n* 장치의 논리적 부착(attach), 분리(detach)\r\n\r\n### 정보 유지::information-maintenance\r\n\r\n* 시간, 날짜 조회, 변경\r\n* 시스템 데이터 조회, 변경\r\n* 프로세스, 파일, 장치의 속성(attribute) 조회, 변경\r\n\r\n### 통신과 보호::communication-and-protection\r\n* 통신 연결 생성, 제거\r\n* 메세지 송신, 수신\r\n* 상태 정보 전달\r\n* 원격 장치의 부착(attach), 분리(detach)\r\n* 파일 권한 조회, 변경\r\n"
  },
  {
    "path": "/docs/computer-science/computer-structure/register",
    "header": {
      "layout": "wiki",
      "date": 1613481240000,
      "title": "레지스터 (Register)",
      "tags": [
        "Hardware",
        "CPU",
        "Register"
      ],
      "summary": "레지스터",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "컴퓨터",
        "하드웨어"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "세그먼트 레지스터 (Segment Register)",
            "title": "세그먼트 레지스터 (Segment Register)",
            "fragment": "root-0",
            "children": []
          }
        ]
      }
    },
    "description": "",
    "content": "\r\n## 세그먼트 레지스터 (Segment Register)\r\n\r\n세그먼트 레지스터는 메모리 주소를 논리적 단위로 나누어 관리하기 위한 레지스터이다.\r\n각 구역의 **시작점**을 가리키는 주소이며, 모두 16비트로 구성되어있다:\r\n\r\n* CS (Code Segment): 코드 영역\r\n* DS (Data Segment): 데이터 영역\r\n* SS (Stack Segment): 스택 영역\r\n* ES (Extra Segment): 보조 영역\r\n* FS: 추가 적인 보조영역 1\r\n* GS: 추가 적인 보조영역 2\r\n\r\n`FS`와 `GS`는 메모리 세그먼트의 추가적인 영역을 위해 `i386` 프로세서에서 도입되었지만, 64비트 Linux에서는 [메모리 페이징]() 기법이 추가되면서,\r\n`FS`와 `GS` 레지스터는 더이상 세그먼트에 사용되지않고, thread-local storage (TLS)또는 per-CPU를 위해 사용된다.\r\n\r\n**TLS (Thread Local Storage)와 per-CPU**\r\n\r\n| 용도      | 적용범위              | 사용처                           | 예                          |\r\n|---------|-------------------|-------------------------------|----------------------------|\r\n| TLS     | 스레드별로 고유한 데이터를 저장 | 사용자 공간에서 스레드기반 어플리케이션이나 라이브러리 | 쓰레드마다 독립적인 전역 변수 사용        |\r\n| per-CPU | CPU별로 고유한 데이터를 저장 | 운영체제 커널 수준                    | CPU별 통계, 커널 데이터구조, 리소스 사용량 |\r\n\r\n\r\n(작성중)\r\n"
  },
  {
    "path": "/docs/network/tcp-ip/data-link-layer",
    "header": {
      "layout": "post",
      "title": "데이터 링크 계층 (Data Link Layer)",
      "tags": [
        "Network",
        "Data Link Layer",
        "OSI",
        "OSI 7 Layer"
      ],
      "date": 1612531320000,
      "thumbnail": "/post/network/tcp-ip/data-link-layer/network-interface-card.png",
      "profile-image": "/post/profile/profile1.jpg",
      "current-company": "Cubic INC",
      "current-position": "SI Researcher",
      "summary": "데이터 링크 계층",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "네트워크",
        "TCP/IP"
      ],
      "images": [
        {
          "src": "/post/network/tcp-ip/data-link-layer/network-interface-card.png",
          "alt": "NIC"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "데이터 링크 계층이란?::what-is-data-link-layer",
            "title": "데이터 링크 계층이란?",
            "fragment": "what-is-data-link-layer",
            "children": []
          },
          {
            "rank": 2,
            "origin": "NIC::network-interface-card",
            "title": "NIC",
            "fragment": "network-interface-card",
            "children": []
          },
          {
            "rank": 2,
            "origin": "프레임 구조::frame-structure",
            "title": "프레임 구조",
            "fragment": "frame-structure",
            "children": []
          }
        ]
      }
    },
    "description": "데이터 링크는 물리계층 상위에 있고, 네트워크 프로토콜 관점에서 가장 기본이 되는 계층이다.\r\n데이터는 \"프레임\"으로 다루며 MAC 주소 체계를 사용하여 통신한다.",
    "content": "\r\n## 데이터 링크 계층이란?::what-is-data-link-layer\r\n\r\n**데이터 링크 계층**은 OSI 7 계층 중 두 번째 계층으로, [물리 계층](/docs/network/tcp-ip/physical-layer)에 데이터 전송을 지시할 수 있다.\r\n흔히 **L2**(Layer 2)라고도 불리며 L2에서는 MAC 주소를 기반으로 주소지정을 사용한다.  \r\n\r\nL2는 프레임 단위의 데이터를 전송하며, 신뢰성 있는 전송을 보장하기 위해 오류제어 및 흐름 제어를 수행한다.  \r\n대표적인 프로토콜 기술로는 `Ethernet`, `PPP(Point-to-Point Protocol)`, `HDLC(High-Level Data Link Control)` 등이 있다.  \r\n\r\nL2에는 Mac 주소 테이블이 있으며, 출발지 MAC을 테이블에 학습한다.\r\n\r\n## NIC::network-interface-card\r\n\r\n**NIC**(**N**etwork **I**nterface **C**ard)은 네트워크 장치로, 컴퓨터와 네트워크 간의 통신을 위한 하드웨어 장치이다.\r\n컴퓨터에서는 `NIC`이 L2 계층의 역할로 여러가지 처리를 수행한다.\r\n\r\n![NIC](/post/network/tcp-ip/data-link-layer/network-interface-card.png)\r\n:{ \"align\": \"center\", \"max-width\": \"400px\", \"description\": \"L2 계층을 수행하는 랜카드(NIC)\" }\r\n\r\n**NIC의 주요 특징**\r\n\r\n* 각 랜카드는 고유한 MAC 주소(48 Bit)를 가지고있다. (실제로 이 처리를 위해 [IEEE]()에서 관리한다.)\r\n* 데이터를 프레임 단위로 전송하고 수신\r\n* L1에서 받은 바이트 스트림을 검사하고 정상 적인 프레임이면 처리, 오류가 있으면 폐기한다.\r\n\r\n## 프레임 구조::frame-structure\r\n\r\n| Preamble |  SFD   | Destination MAC | Source MAC |  Type  |     Data     |  FCS   |\r\n|:--------:|:------:|:---------------:|:----------:|:------:|:------------:|:------:|\r\n| 7 Bytes  | 1Bytes |     6Bytes      |   6Bytes   | 2Bytes | 46~1500Bytes | 4Bytes |\r\n:{ \"type\": \"filled\" }\r\n\r\nL2에서는 각 데이터를 프레임으로 전송하며, 프레임은 위와 같은 구조로 이루어져있다.\r\n\r\n* **Preamble**: 수신측의 클록 동기화를 위해 사용 되며, 7번 반복된 byte로 구성된다. (예: 10101010(AA) * 7)\r\n* **SFD**(**S**tart **F**rame **D**elimiter): 프레임의 시작을 알리는 구분 값, 1byte로 구성된다. (예: 10101011(AB))\r\n* **Destination MAC**: 목적지 MAC 주소, 6byte로 구성된다.\r\n* **Source MAC**: 출발지 MAC 주소, 6byte로 구성된다.\r\n* **Type**: 데이터의 종류를 나타내는 값 이며, IPv4는 `0x0800`, IPv6은 `0x86DD`, ARP는 `0x0806`으로 구성된다.\r\n* **Data**: 실제 전송할 데이터, 최소 46byte에서 최대 1500bytes 까지 전송 가능하다.\r\n* **FCS**(**F**rame **C**heck **S**equence): 오류 검출을 위한 값으로, 4byte로 구성된다. 이 값은 프레임이 손상되었는지 아닌 지를 판단하는 체크섬으로 사용한다.\r\n  * 송신 장치(Sender Device)는 이 필드를 제외한 프레임의 포든 필드를 가져와 **CRC**(Cyclic Redundancy Check)라는 알고리즘으로 실행하고 결과로 FCS로 사용할 4byte 값을 생성하여 이 필드에 담는다.\r\n\r\nL2에서는 Data를 제외 한 모든 필드를 프레임 헤더라고 하며 `NIC`에서는 이 헤더를 분석하고, Data를 추출하여 상위 계층으로 전달한다.\r\n\r\n\r\n\r\n"
  },
  {
    "path": "/docs/network/tcp-ip/physical-layer",
    "header": {
      "layout": "post",
      "title": "물리 계층 (Physical Layer)",
      "tags": [
        "Network",
        "Physical Layer",
        "OSI",
        "OSI 7 Layer"
      ],
      "date": 1612468440000,
      "thumbnail": "/post/network/tcp-ip/physical-layer/pin-map-of-cable.png",
      "profile-image": "/post/profile/profile1.jpg",
      "current-company": "Cubic INC",
      "current-position": "SI Researcher",
      "summary": "물리 계층",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "네트워크",
        "TCP/IP"
      ],
      "images": [
        {
          "src": "/post/network/tcp-ip/physical-layer/utp-cable.png",
          "alt": "UTP 케이블"
        },
        {
          "src": "/post/network/tcp-ip/physical-layer/pin-map-of-cable.png",
          "alt": "케이블 핀맵"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "물리계층은 무엇인가?::what-is-physical-layer",
            "title": "물리계층은 무엇인가?",
            "fragment": "what-is-physical-layer",
            "children": []
          },
          {
            "rank": 2,
            "origin": "데이터 전송 방식::data-transfer-method",
            "title": "데이터 전송 방식",
            "fragment": "data-transfer-method",
            "children": []
          },
          {
            "rank": 2,
            "origin": "전송 매체별 역할::role-of-transmission-media",
            "title": "전송 매체별 역할",
            "fragment": "role-of-transmission-media",
            "children": []
          },
          {
            "rank": 2,
            "origin": "데이터 처리::data-processing",
            "title": "데이터 처리",
            "fragment": "data-processing",
            "children": []
          }
        ]
      }
    },
    "description": "네트워크 통신에서 물리 계층은 데이터를 전송하는 데 사용되는 하드웨어 장치와 전송 매체를 다룬다.\r\n흔히 이더넷, Wi-Fi, 블루투스, 광섬유 케이블 등이 있고 일반적으로 우리가 접하는 랜선(UTP)이다.",
    "content": "\r\n## 물리계층은 무엇인가?::what-is-physical-layer\r\n\r\n물리 계층은 OSI 7계층 중 가장 하위 계층으로, 데이터를 전송하는 데 사용되는 하드웨어 장치와 전송 매체를 다룬다.\r\n양끝 장치에서 전기 또는 빛을 이용해 데이터를 전달하며 데이터 전송의 물리적인 부분을 담당한다.\r\n\r\n## 데이터 전송 방식::data-transfer-method\r\n\r\n일반적으로 물리 계층은 이진 데이터를 전기신호 또는 빛 신호로 전달한다. 각 전송매체 마다 다르며 이는 아래와 같다:\r\n\r\n* **유선 매체**: 전기 신호를 사용하는 유선 매체로는 전화선, 케이블, 광섬유 케이블 등이 있다.\r\n* **무선 매체**: 무선 매체로는 라디오파, 마이크로파, 적외선, 블루투스, Wi-Fi 등이 있다.\r\n\r\n이더넷을 기준으로 예를 들면, 이더넷은 랜선(UTP)위에서 전달되며, 전기신호를 사용한다.\r\n전기신호는 [Bit](/wiki/bit)로 표현되며, 0과 1로 이루어진 데이터를 전달한다.\r\n\r\n![UTP 케이블](/post/network/tcp-ip/physical-layer/utp-cable.png)\r\n: { \"align\": \"center\", \"max-width\": \"400px\", \"description\": \"UTP 케이블\" }\r\n\r\n>UTP는 **U**nshielded **T**wisted **P**air의 약자로, 피복이 있는 작은 구리선들이 두 개씩 묶여 있는 케이블이다.\r\n: { \"type\": \"note\", \"icon\": \"info\" }\r\n\r\n각 페어로 데이터를 전송하거나 수신할 수 있는데 이는 아래와 같다:\r\n\r\n## 전송 매체별 역할::role-of-transmission-media\r\n\r\n[LAN]() 케이블은 총 8개의 회선이며,  4개의 페어로 구성되어 있다.\r\n\r\n이더넷 규격별 특징은 아래와 같다:\r\n\r\n1. 10BASE-T\r\n   * 속도: 각 페어당 10Mbps\r\n   * 변조방식: 멘체스터 인코딩(Manchester Encoding)\r\n   * 사용페어: 2쌍만 사용\r\n     * 1,2번 페어: 데이터 전송(TX)\r\n     * 3,6번 페어: 데이터 수신(RX)\r\n     * 4, 5번 & 7,8번 페어: 미사용\r\n2. 100BASE-TX\r\n   * 속도: 각 페어당 100Mbps\r\n   * 변조방식: MLT-3(4B/5B 인코딩 포함) \r\n   * 사용페어: 2쌍만 사용\r\n     * 1,2번 페어: 데이터 전송(TX)\r\n     * 3,6번 페어: 데이터 수신(RX)\r\n     * 4, 5번 & 7,8번 페어: 미사용\r\n3. 1000BASE-T\r\n   * 속도: 각 페어당 250Mbps *4 = 총 1Gbps\r\n   * 변조방식: PAM-5(4B/5B 인코딩 포함)\r\n   * 사용페어: 4쌍 모두 사용\r\n     * 모든 페어가 양방향 통신\r\n     * 각 페어가 송수신 동시 수행\r\n\r\n![케이블 핀맵](/post/network/tcp-ip/physical-layer/pin-map-of-cable.png)\r\n: { \"align\": \"center\", \"max-width\": \"600px\", \"description\": \"케이블 핀맵\" }\r\n\r\n## 데이터 처리::data-processing\r\n\r\n물리 계층은 [데이터 링크 계층](/docs/network/tcp-ip/data-link-layer)으로 받은 프레임을 트랜시버(Transceiver)를 이용해 비트 스트림으로 변환 및 직렬화하여 순차적으로 데이터를 전송한다.  \r\n예: 10101110(1바이트) -> 1, 0, 1, 0, 1, 1, 1, 0(8비트)\r\n\r\n이렇게 받은 비트들은 각 변조 방식으로 비트단위로 변조되어 전송된다.\r\n\r\n\r\n\r\n"
  },
  {
    "path": "/docs/computer-science/operating-system/operating-system",
    "header": {
      "layout": "post",
      "title": "Operating System (OS)",
      "tags": [
        "Operating System",
        "OS"
      ],
      "date": 1611141570000,
      "thumbnail": "/post/computer-science/operating-system.webp",
      "current-company": "Cubic INC",
      "current-position": "SI Researcher",
      "profile-image": "/post/profile/profile1.jpg",
      "summary": "컴퓨터 OS",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "컴퓨터",
        "operating-system"
      ],
      "images": [
        {
          "src": "/post/computer/traditional-system-structure-of-unix.png",
          "alt": "UNIX의 전통적인 시스템 구조"
        },
        {
          "src": "/post/computer/system-structure-of-linux.png",
          "alt": "Linux의 시스템 구조"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "컴퓨터의 구성::computer-structure",
            "title": "컴퓨터의 구성",
            "fragment": "computer-structure",
            "children": []
          },
          {
            "rank": 2,
            "origin": "운영체제의 구조::structure-of-os",
            "title": "운영체제의 구조",
            "fragment": "structure-of-os",
            "children": [
              {
                "rank": 3,
                "origin": "모놀리식 구조::monolithic-structure",
                "title": "모놀리식 구조",
                "fragment": "monolithic-structure",
                "children": []
              },
              {
                "rank": 3,
                "origin": "계층적 접근::layered-approach",
                "title": "계층적 접근",
                "fragment": "layered-approach",
                "children": []
              }
            ]
          },
          {
            "rank": 2,
            "origin": "운영체제의 동작 순서::workflow-of-os",
            "title": "운영체제의 동작 순서",
            "fragment": "workflow-of-os",
            "children": []
          },
          {
            "rank": 2,
            "origin": "운영체제의 역할::role-of-os",
            "title": "운영체제의 역할",
            "fragment": "role-of-os",
            "children": [
              {
                "rank": 3,
                "origin": "메모리 관리::memory-management",
                "title": "메모리 관리",
                "fragment": "memory-management",
                "children": []
              },
              {
                "rank": 3,
                "origin": "프로세스 관리::process-management",
                "title": "프로세스 관리",
                "fragment": "process-management",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "운영체제가 어떤일을 하는지를 알려면, 컴퓨터가 어떤 요소들로 구성되어 있는지를 이해 해야한다.\r\n각 요소의 구성과 이해관계 그리고 역할을 알아보자.",
    "content": "\r\n\r\n## 컴퓨터의 구성::computer-structure\r\n\r\n컴퓨터는 크게 응용프로그램, 운영체제, 하드웨어 계층으로 분류된다.\r\n이 문서에서는 응용프로그램을 제외하고 운영체제와 하드웨어에 대해 논한다.\r\n\r\n[CPU](/wiki/central-processing-unit)와 [입출력 장치]() 그리고 [메모리]()는 [시스템 버스]()를 통해 서로 연결되어 있으며, 버스의 종류에 따라 단방향 또는 양방향으로 신호를 보낸다.\r\n입출력 장치의 경우 메인보드 위에 사전에 만들어진 장치 컨트롤러를 운영체제의 장치 드라이버가 제어하며, 장치드라이버는 운영체제에 일관된 인터페이스를 제공한다.\r\nCPU와 장치컨트롤러는 병렬로 실행되기 떄문에 메모리에 접근하기위해 메모리 사이클을 두고 경쟁한다. 이 메모리에 순차적으로 접근하기 위해 메모리 컨트롤러는 메모리에 대한 액세스를 동기화한다.\r\n\r\n\r\n위에서 간단히 설명한 내용은 OS 내부의 커널과 시스템 프로그램에 의해 제어되며, 하드웨어의 경우 사전에 설계된 회로의 동작을 수행한다.\r\n\r\n## 운영체제의 구조::structure-of-os\r\n\r\n운영체제 같이 크고 복잡한 시스템은 쉽게 변경할 수 있으면서 올바르게 동작하려면 신중히 제작되어야 한다.\r\n일반적으로 한 개의 일관된 시스템보다는 작업을 작은 구성요소로 분할 하는 것이다. 각각의 모듈은 신중히 정의된 인터페이스와 기능들을 가지는 시스템의 일부가 되어야 한다.  \r\n\r\n예를 들어 `main()` 함수에 모든 코드를 넣는것 보다 필요한 기능을 올바른 인자와 반환값을 명시한 여러 함수로 분리하고 적재적소에 맞게 호출하는 것이다.  \r\n\r\n운영체제의 공통적인 구성요소들이 어떻게 연결되어 하나의 커널로 결합하는지 알아보자.\r\n\r\n### 모놀리식 구조::monolithic-structure\r\n\r\n가장 간단한 방법으로 프로그램을 만드는 방법은 한개의 구조없이 한곳에서 모든 것을 관리하는 것이다.\r\n\r\n**monolithic**[mɑ:nə│lɪθɪk]: 하나로된 거대한 덩어리\r\n이러한 한개의 구조를 `모놀리식 (monolithic)`이라고 한다. 즉 단일 주소 공간에서 실행되는 단일 바이너리 파일에 커널의 모든 기능을 넣는 것이다.\r\n\r\n`모놀리식 구조`라고 하는 이방법은 운영체제를 설계하는 일반적인 기법이다. 이러한 제한적인 구조를 가지는 운영체제는 최초의 UNIX 운영체제가 대표적인 예시이다.\r\n커널과 시스템 프로그램의 두 부분으로 구성된다.\r\n\r\n커널은 여러가지 인터페이스아 장치드라이버로 나뉘게 되는데, 이는 `UNIX`가 발전해 오면서 몇십년에 걸쳐 추가되고 확장 되었다.\r\n계층 별로 이루어져 있는 `UNIX` 운영체제는 [시스템 콜](/wiki/system-call) 인터페이스 아래와 하드웨어 위 모든 것이 커널이다. \r\n\r\n![UNIX의 전통적인 시스템 구조](/post/computer/traditional-system-structure-of-unix.png)\r\n:{ \"align\": \"center\", \"max-width\": \"400px\", \"description\": \"UNIX의 전통적인 시스템 구조\" }\r\n\r\n커널은 시스템 콜을 통해 `파일 시스템`, `CPU 스케줄링`, `메모리 관리` 등의 기능을 제공한다. **이러한 기능은 한나의 주소 공간으로 결합하기에는 너무 많은 기능이다.**\r\n\r\n`Linux` 운영체제는  `UNIX`에 기반을 두고 있으며 아래와 같은 유사한 구조로 구성된다.\r\n\r\n![Linux의 시스템 구조](/post/computer/system-structure-of-linux.png)\r\n:{ \"align\": \"center\", \"max-width\": \"400px\", \"description\": \"Linux의 시스템 구조\" }\r\n\r\n응용 프로그램은 일반적으로 커널의 시스템콜 인터페이스와 통신할 때 [`glibc` 표준 C 라이브러리](/wiki/system-call#api-and-system-call)를 사용한다.  \r\n`Linux` 커널은 단일 주소 공간에서 커널모드로 전부 실행된 다는 점에서 모놀리식이지만, 런타임에 커널을 정할 수 있는 [LKM]() 모듈식 설계를 갖추고 있다.\r\n\r\n이러한 단순한 구조라도 확장은 어렵지만 시스템 콜의 오버헤드가 거의 없고 커널안에서의 통신속도가 빠르다는 단점이 있다.\r\n따라서 모놀리식 커널의 단점에도 불구하고 속도와 효율성은 아직까지도 `UNIX`와 `Linux` 및 `Windows`에서 사용되는 것이 증명해준다.\r\n\r\n\r\n### 계층적 접근::layered-approach\r\n\r\n작성중...\r\n\r\n\r\n\r\n\r\n## 운영체제의 동작 순서::workflow-of-os\r\n\r\n컴퓨터의 전원을 켤 때 실행되는 부트스트랩 프로그램은 펌웨어이다.  \r\n부트스트랩 프로그램은 하드웨어 위에서 동작하며 `CPU`, `메모리` `저장장치` 등을 초기화 한다. 또한 운영체제를 로드하기 위해 부트로더를 실행하며, 이는 저장장치에서 메모리로 [Kernel]()(`커널`)을 적재한다.\r\n\r\n부트로더는 커널 실행에 필요한 초기설정(예: 커맨드라인 인자 전달 등)을 한뒤, 커널에 제어를 넘긴다. 이후에 커널은 시스템을 초기화하고 사용자 공간(user space)을 준비한다.\r\n각 시스템에서 사용 되는 부트로더는 여러종류가 있다.\r\n\r\n* GRUB (GNU GRUB):\r\n  * 리눅스/유닉스 시스템에서 사용되는 부트로더\r\n* LILO(Linux Loader)\r\n  * 과거 리눅스 시스템에서 사용되는 부트로더\r\n* Windows Boot Manager\r\n  * 윈도우 시스템에서 사용하는 부트로더\r\n* Android Bootloader\r\n  * 안드로이드 기기에서 사용되는 부트로더로, 리커버리모드와 운영체제를 실행한다.\r\n\r\n## 운영체제의 역할::role-of-os\r\n\r\n운영체제는 사용자 또는 시스템 프로그램이 올바르게 실행되기 위해 커널에서 다양한 관리를 아래와 같이 제공한다.\r\n\r\n* 메모리 관리\r\n* 프로세스 관리\r\n* 장치 드라이버\r\n* 파일 시스템\r\n* 네트워크 관리\r\n\r\n### 메모리 관리::memory-management\r\n\r\n### 프로세스 관리::process-management\r\n\r\n운영체제는 자원을 관리하지만, 아마 그중에서도 가장 중요한건 [프로세스]()에 대한 관리이다. 대표적으로 아래와 같다.\r\n\r\n* 사용자 프로세스와 시스템프로세스의 생성과 제거\r\n* `CPU`에 프로세스와 스레드 스케줄링\r\n* 프로세스의 일시중지(suspend) 와 재수행(resume)\r\n* 프로세스 동기화 기법 제공\r\n* 프로세스 간 통신(IPC) 제공\r\n\r\n위와 같은 처리를 위해 운영체제는 프로세스의 상태를 관리하며, 프로세스의 상태(process stats)는 `생성`, `준비`, `실행`, `대기`, `종료`로 나뉜다.\r\n이러한 상태는 아래처럼 나타낼 수 있다.\r\n```\r\n New\r\n  ↓\r\nReady ←→ Running → Terminated\r\n  ↑        ┆\r\nWaiting ←--╯\r\n```\r\n"
  },
  {
    "path": "/docs/algorithm/base58",
    "header": {
      "layout": "wiki",
      "title": "Base58 인코딩",
      "date": 1607085240000,
      "tags": [
        "Algorithm",
        "Encoding",
        "Base58"
      ],
      "summary": "Base58",
      "hide": true,
      "breadcrumbs": [
        "문서",
        "알고리즘"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "Base58란?::what-is-base58",
            "title": "Base58란?",
            "fragment": "what-is-base58",
            "children": []
          }
        ]
      }
    },
    "description": "",
    "content": "\r\n## Base58란?::what-is-base58\r\n\r\n**Base58** 인코딩은 주로 비트코인과 같은 암호화폐에서 사용되는 인코딩 방식으로, 숫자와 대소문자 알파벳을 이용하여 데이터를 표현하는 방법이다.  \r\n더블클릭으로 드래그해도 한번에 모든 문자열이 선택되며, 특정 문자들을 제외하여 혼동을 줄이고 사람이 읽고 쓰기 쉽게 설계되었다.\r\n\r\n위의 장점들은 다음과 같이 Base58의 문자집합을 보면 알수 있다:\r\n\r\n* 대문자 알파벳: `A ~ Z` (단 `I`와 `O`를 제외)\r\n* 소문자 알파벳: `a ~ z` (단 `l`을 제외)\r\n* 숫자: `1 ~ 9`\r\n\r\n육안으로 볼 때 혼동이 될 수 있는 문자들은 제외 되었으며, 이를 통해 사람이 쉽게 읽고 쓸 수 있도록 설계되었다.\r\n\r\n> 구성되는 값: 123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\r\n: "
  },
  {
    "path": "/docs/language/java/install-zulu-in-mac",
    "header": {
      "layout": "post",
      "title": "Azul System의 OpenJDK Zulu 설치하기",
      "tags": [
        "OpenJDK",
        "Azul System",
        "Zulu"
      ],
      "date": 1606922700000,
      "thumbnail": "/post/java/azul-java.webp",
      "profile-image": "/post/profile/profile1.jpg",
      "current-company": "Cubic INC",
      "current-position": "SI Researcher",
      "summary": "OpenJDK Zulu 설치",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "언어",
        "Java"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "macOS에서 Open JDK 설치",
            "title": "macOS에서 Open JDK 설치",
            "fragment": "root-0",
            "children": [
              {
                "rank": 3,
                "origin": "DMG Installer를 이용한 설치",
                "title": "DMG Installer를 이용한 설치",
                "fragment": "root-0-0",
                "children": []
              },
              {
                "rank": 3,
                "origin": "ZIP 또는 TAR.GZ로 설치",
                "title": "ZIP 또는 TAR.GZ로 설치",
                "fragment": "root-0-1",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "Zulu는 Azul System에서 제공하는 OpenJDK의 빌드이다.\r\nmacOS에서 설치하는 방법을 요약했다.",
    "content": "\r\n\r\n## macOS에서 Open JDK 설치\r\n\r\nMacOS는 일반적으로 `/Library/Java/JavaVirtualMachines` 하위 경로에 jdk를 저장하고 사용한다.\r\n\r\n\r\n### DMG Installer를 이용한 설치\r\n\r\n1. [Azul 다운로드](https://www.azul.com/downloads/?os=macos&_gl=1*dkdl9*_ga*MTQ0NjY0MDg1OS4xNjg4NjM4NTAz*_ga_42DEGWGYD5*MTcwNjc5MTg0NC40LjEuMTcwNjc5MjMwNy4yOC4wLjA.#zulu)에서 Azul Zulu를 위한 DMG Installer 다운로드\r\n2. 설치를 시작하기위해 파일 더블클릭하고, 설치 마법사 명령을 따르기\r\n\r\n기본 설치폴더는 다음과같다.\r\n\r\n```\r\n/Library/Java/JavaVirtualMachines/<zulu_folder>/Contents/Home\r\n```\r\n\r\n`<zulu_folder>` 플레이스 홀더는 그 버전과 Azul Zulu 패키지(JDK or JRE)의 타입을 말한다. \r\n\r\n| 패키지 |      Azul Zulu 폴더명      |     예시      |\r\n| :----: | :------------------------: | :-----------: |\r\n|  JDK   | `zulu-<major_version>.jdk` | `zulu-11.jdk` |\r\n|  JRE   | `zulu-<major_version>.jdk` | `zulu-11.jre` |\r\n:{ \"wrapper-class\": \"items-center\" }\r\n\r\n예를 들어, Azul Zulu JDK11을 위한 기본설치 폴더인경우:\r\n\r\n```\r\n/Library/Java/JavaVirtualMachines/zulu-11.jdk/Contents/Home\r\n```\r\n\r\n3. Azul zulu 설치를 확인하기위해 터미널 창에서 `java` 명령어를 실행한다.\r\n\r\n```bash\r\n$ java -version\r\n```\r\n\r\n다음과 같이 출력돼야 한다.  \r\n\r\n```\r\nopenjdk version \"11.0.11\" 2021-04-20 LTS\r\nOpenJDK Runtime Environment Zulu11.48+21-CA (build 11.0.11+9-LTS)\r\nOpenJDK 64-Bit Server VM Zulu11.48+21-CA (build 11.0.11+9-LTS, mixed mode)\r\n```\r\n\r\n### ZIP 또는 TAR.GZ로 설치\r\n\r\n1. [Azul 다운로드](https://www.azul.com/downloads/?os=macos)에서 TAR.GZ 또는 ZIP으로 Azul Zulu 다운로드\r\n\r\n2. **Finder** 실행 후 다운로드 폴더로 이동. 압축을 해제하기위해 더블클릭 한다. **사파리**에서 받았다면 자동으로 압축해제 된다.\r\n\r\n하지만, 압축해제하기 위해 아래처럼 한번의 명령어를 사용할 수도 있다.\r\n\r\nZIP 인 경우\r\n\r\n```bash\r\nunzip <zulu_package>.zip\r\n```\r\n\r\n   TAR.GZ 인 경우\r\n\r\n```\r\ntar -zxvf <zulu_package>.tar.gz\r\n```\r\n\r\n압축 해제한 폴더가 Zulu Azul 설치 폴더 이다.\r\n\r\n3. Azul Zulu 설치를 확인하기 위해, 터미널 창에서 다음의 커맨드를 실행한다.\r\n\r\n```bash\r\n$ <installation_folder>/bin/java -version\r\n```\r\n\r\n4. (선택사항) `<installation_folder>/bin/java` 을 `PATH` 환경변수에 추가하면, 특정한 전체 경로 없이 어디서는 `java` 를 실행할 수 있다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
  },
  {
    "path": "/docs/computer-science/computer-structure/central-processing-unit",
    "header": {
      "layout": "wiki",
      "date": 1597084440000,
      "title": "중앙처리장치 (CPU)",
      "tags": [
        "Hardware",
        "CPU"
      ],
      "summary": "CPU",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "컴퓨터",
        "하드웨어"
      ],
      "images": [
        {
          "src": "/post/computer/multicore-processor.png",
          "alt": "멀티코어 프로세서"
        },
        {
          "src": "/post/computer/cpu-core-structure.png",
          "alt": "CPU 코어"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "CPU란?::what-is-cpu",
            "title": "CPU란?",
            "fragment": "what-is-cpu",
            "children": []
          },
          {
            "rank": 2,
            "origin": "Core의 구조::core-structure",
            "title": "Core의 구조",
            "fragment": "core-structure",
            "children": [
              {
                "rank": 3,
                "origin": "Control Unit (제어장치)::control-unit",
                "title": "Control Unit (제어장치)",
                "fragment": "control-unit",
                "children": []
              },
              {
                "rank": 3,
                "origin": "Data Processing Unit (처리장치)::data-processing-unit",
                "title": "Data Processing Unit (처리장치)",
                "fragment": "data-processing-unit",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "",
    "content": "\r\n## CPU란?::what-is-cpu\r\n\r\n**C**entral **P**rocessing **U**nit (이하 `CPU`)는 컴퓨터의 모든 연산을 실행하거나 처리하는 핵심적인 제어장치이며 `중앙처리장치`라고도 말한다. \r\n컴퓨터에 필수적인 4대 주요기능(`기억`, `해석`, `연산`, `제어`)을 관리하는 가장 중요한 장치이다.\r\n1\r\n처리기, 프로세서 등 여러 이름이 있으며 컴퓨터에 따라 한개 또는 그 이상의 장치가 들어간다. 일반적으로는 프로세서 칩 한개를 의미 하지만, 엔지니어 입장에서는 몇개가 존재하든 처리를 하는 역할은 변하지 않기에 프로세서라고 그냥 말 할 수 도 있다.  \r\n\r\n![멀티코어 프로세서](/post/computer/multicore-processor.png)\r\n:{ \"max-width\": \"300px\", \"align\": \"center\", \"description\": \"멀티코어는 하나의 칩에 두개 이상의 코어를 가지는 설계를 의미한다.\" }\r\n\r\nCPU의 코어는 실질적으로 연산을 수행하는 장치이다. 코어 내에는 연산하는 과정에서 임시로 적제할 여러 레지스터를 갖고 있다.\r\n제조사별로 [캐시메모리]() 구조가 다르지만, 왼쪽의 경우는 `L2 캐시`는 프로세서 내에서 공유가 가능하다.  \r\n\r\n때문에 `Level 1 캐시(이하 L1)`에는 접근이 매우 빠르지만 반대로 L2는 경합으로 인해 접근에 대한 [클럭]() 동기화로 시스템 시간을 맞추어 순차적인 접근이 필요하기 때문에 `L1`에 비해 느리다.\r\n코어별로 `L2`를 내장하고 있는 CPU도 있고, L2 부터 공유하는 CPU도 있다.\r\n\r\n[인텔의 메모리 성능 요약](https://www.intel.com/content/www/us/en/developer/articles/technical/memory-performance-in-a-nutshell.html)에 따르면 간단한 차이는 아래와 같다.\r\n\r\n| 메모리      | 크기    | 시간     | 대역폭    |\r\n|----------|-------|--------|--------|\r\n| L1 cache | 32KB  | 1ns    | 1TB/s  |\r\n| L2 cache | 256KB | 4ns    | 1TB/s  |\r\n| L3 cache | 8MB < | 40ns < | 400GB/s | \r\n:{ \"align\": \"center\", \"description\": \"인텔 캐시메모리의 성능 비교표\" }\r\n\r\n## Core의 구조::core-structure\r\n\r\n![CPU 코어](/post/computer/cpu-core-structure.png)\r\n:{ \"align\": \"center\", \"max-width\": \"500px\", \"description\": \"중앙처리장치의 코어 구조\" }\r\n\r\nCPU Core 안에서는 크게 제어장치와 처리장치 두가지로 나뉜다.\r\n\r\n### Control Unit (제어장치)::control-unit\r\n\r\n제어장치는 `CPU`와 다른 주변 장치와의 데이터 흐름을 제어하며, 각 장치로 제어신호를 보내어 명령어를 실행하도록 한다.\r\nCPU의 [명령어 사이클]()을 제어하며, 명령어를 해독하고 실행하는 역할을 한다.\r\n\r\n**제어 장치에 속하는 대표적인 구성요소**\r\n\r\n1. [명령어 디코더 (Instruction Decoder)]()\r\n    * 명령어를 해독하고, 필요한 작업을 결정한다.\r\n2. [제어 신호 생성기 (Control Signal Generator)]()\r\n    * 명령어를 해독한 결과에 따라 제어 신호를 생성한다.\r\n3. [인터럽트 컨트롤러 (Interrupt Controller)]()\r\n    * 인터럽트가 발생하면, 해당 인터럽트를 처리한다.\r\n4. [클럭 발생기 (Clock Generator)]()\r\n    * CPU의 클럭을 생성한다.\r\n5. [타이밍 신호 발생기 (Timing Signal Generator)]()\r\n    * 클럭 발생기로 부터 주기신호를 받아 작업 흐름을 나눈다.\r\n6. [명령어 사이클 제어기 (Instruction Cycle Controller)]()\r\n    * 타이밍 신호를 받아 명령어 실행 순서를 관리한다.\r\n\r\n### Data Processing Unit (처리장치)::data-processing-unit\r\n\r\n처리장치는 제어장치가 명령어를 해독하고, 실행할 작업을 결정하면, 실제로 데이터를 처리하는 장치이다.\r\n\r\n**제어 장치에 속하는 대표적인 구성요소**\r\n\r\n1. [산술 논리 연산 장치 (Arithmetic And Logical Unit)]()\r\n    * 산술(사칙: +, −, ✕, ÷)연산과 논리(AND, OR, NOT 등)연산을 처리한다.\r\n2. [부동소수점 연산 장치 (Floating Point Unit)]()\r\n    * 실수 데이터 연산을 처리한다.\r\n3. [레지스터 (Register)]()\r\n    * 데이터를 저장하고, 연산에 필요한 데이터를 임시로 저장한다.\r\n4. [캐시 메모리 (Cache Memory)]()\r\n    * 데이터를 빠르게 접근하기 위한 임시 저장소이다.\r\n5. [파이프 라인 (Pipeline)]()\r\n    * 명령어를 여러 단계로 나누어 병렬로 처리한다.\r\n"
  },
  {
    "path": "/docs/computer-science/computer-structure/direct-memory-access",
    "header": {
      "layout": "wiki",
      "date": 1596374520000,
      "title": "Direct Memory Access (DMA)",
      "tags": [
        "Hardware",
        "DMAC",
        "Direct Memory Access Controller"
      ],
      "summary": "DMA",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "컴퓨터",
        "하드웨어"
      ],
      "images": [
        {
          "src": "/post/computer/data-transfer-between-memory-and-io-device.png",
          "alt": "메모리와 I/O 장치간의 데이터 전송"
        },
        {
          "src": "/post/computer/dma-request.png",
          "alt": "DMA 요청"
        },
        {
          "src": "/post/computer/cpu-and-io-devices.png",
          "alt": "시스템버스로 연결되어 있는 각 장치들"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "DMA란 무엇인가?::what-is-dma",
            "title": "DMA란 무엇인가?",
            "fragment": "what-is-dma",
            "children": []
          },
          {
            "rank": 2,
            "origin": "DMA는 어떻게 사용되는가?::how-dma-used-for",
            "title": "DMA는 어떻게 사용되는가?",
            "fragment": "how-dma-used-for",
            "children": [
              {
                "rank": 3,
                "origin": "DMA 동작 순서::sequence-of-dma",
                "title": "DMA 동작 순서",
                "fragment": "sequence-of-dma",
                "children": []
              },
              {
                "rank": 3,
                "origin": "DMA 동작모드::mode-of-dma",
                "title": "DMA 동작모드",
                "fragment": "mode-of-dma",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "",
    "content": "\r\n## DMA란 무엇인가?::what-is-dma\r\n\r\nDMA는 `IO 장치`와 `메모리`간의 데이터 전송을 위한 기술이다.\r\n\r\n정확히는 모든 I/O장치는 아니고, 대용량 데이터 전송을 목적으로 하는 하드웨어와 연결되어있다.  \r\n저장 장치의 경우 `HDD/SSD`, `CD/DVD` 그리고 멀티미디어의 경우 `그래픽 카드(GPU)`, `사운드 카드` 등이 있다.\r\n\r\n[`PIO`](/wiki/programmed-io)방식에서는 [CPU](/wiki/central-processing-unit)가 데이터를 한 워드 또는 바이트마다 전송하기 때문에, 속도가 빠른 **I/O 장치**의 경우 CPU의 실제 프로세스 작업 시간을 줄여 다른 작업을 수행하는데 방해가된다.  \r\n이를 해결하기위해 등장한 DMA 기술은 `I/O 장치에서 메모리`로 또는 `메모리에서 I/O 장치`로 데이터를 CPU의 개입없이 전송하여 CPU의 부담을 줄여준다.\r\n\r\n![메모리와 I/O 장치간의 데이터 전송](/post/computer/data-transfer-between-memory-and-io-device.png)\r\n:{ \"max-width\": \"400px\", \"align\": \"center\", \"wrapper-class\": \"justify-center\", \"description\": \"메모리와 I/O 장치간의 데이터 전송\" }\r\n\r\n## DMA는 어떻게 사용되는가?::how-dma-used-for\r\n\r\n**D**irect **M**emory **A**cess **C**ontroller (이하 `DMAC`)는 하드웨어 장치로서, [메모리]() 입출력 장치간의 데이터 전송을 DMA 기술로서 관리하는 장치이다.\r\n\r\n\r\n### DMA 동작 순서::sequence-of-dma\r\n\r\n장치 A에서 장치 B로 `DMA` 요청이 들어왔다는 가정하에, 순서를 설명하자면 다음과 같다.\r\n\r\n1. 장치 컨트롤러는 `DMAC`과 물리적으로 연결 되어있는 신호선에  DMA Request(`DMA 요청`)을 보낸 후 `DMAC`에서 요청을 받아들이면, 장치 컨트롤러로 DMA Acknowledge(`DMA 승인`) 신호를 보낸다.\r\n\r\n   ![DMA 요청](/post/computer/dma-request.png)\r\n   :{ \"max-width\": \"400px\", \"align\": \"center\", \"description\": \"장치 컨트롤러의 DMA 요청\" }\r\n\r\n2. 데이터를 전송하기 전에 각 장치에 명령을 전달한다.\r\n\r\n   * 데이터를 읽기위해 디스크 컨트롤러로 `주소 신호`(컨트롤러로 부터 전달받은 읽을 로컬버퍼 주소)와 `제어 신호` (읽기 명령)을 보낸다.  \r\n   또한 메모리에는 `주소 신호`(전달받은 메모리에 쓰기 주소)와 `제어신호`(쓰기 명령)을 보내면 데이터를 전송할 준비가 완료 된다.\r\n\r\n3. `DMAC`는 데이터를 전송할 시스템 버스의 소유권을 얻기위해 CPU에게 제어 버스로 `Bus Request(BR)` 신호를 전송한다. CPU는 `Bus Grant`신호를 전송하여 버스 사용을 허가한다.\r\n\r\n   ![시스템버스로 연결되어 있는 각 장치들](/post/computer/cpu-and-io-devices.png)\r\n   :{ \"max-width\": \"400px\", \"align\": \"center\", \"description\": \"시스템 버스와 연결된 각 장치들\" }\r\n\r\n   * 실제로는 I/O 장치의 컨트롤러와 연결되어 있으며, `BR`과 `BG` 모두 제어버스를 통해 전달된다. 각 장치마다 데이터를 준비하는 과정이 다르긴 하지만, 장치 A(HDD)에서 장치 B(RAM)으로 데이터를 전송하는 과정에서 데이터를 준비는 다음과 같다.\r\n   먼저 `CPU`가 디스크 읽기요청을 하드디스크 [드라이버]()로 전송한다. 이때 디스크의 읽을 섹터번호([LBA]()) 와 읽을 양, 쓰기가 필요한 메모리 주소 등을 전달한다.  \r\n\r\n   * 디스크 드라이버는 전달받은 정보를 이용해 데이터를 읽고, 디스크 컨트롤러 로컬버퍼에 데이터를 임시로 저장한다. 그리고 데이터를 읽을준비가 완료되면, `DMAC`으로 `DMA 요청`을 전송한다.\r\n   `DMAC`은 시스템 제어를 위해 `CPU`에게 `BR`을 보내고, `CPU`는 `BG`를 보낼어 제어 승인을 하며, 타임아웃을 정하여 [타이머](/wiki/interrupt#timer)를 설정한다. \r\n\r\n   > 만약 타임아웃이 발생한다면 타이머는 인터럽트를 발생시켜 CPU에게 알린다.\r\n   :{ \"type\": \"caution\", \"icon\": \"warning-octagon\" }  \r\n\r\n   * `BG`를 받는 경우 즉시 회로가 연결되어 시스템버스의 소켓특성으로 데이터가 전달된다.\r\n\r\n4. 데이터 전송제어를 모두 마친 `DMAC`은 `CPU`에게 시스템 버스의 소유권을 반환한다.\r\n   * 이 경우 [인터럽트](/wiki/interrupt)를 발생시켜 CPU에 작업완료를 알려 버스소유권을 반납한다. \r\n\r\n### DMA 동작모드::mode-of-dma\r\n\r\n**사이클 스틸링(Cycle Stealing)**\r\n\r\n`Cycle Stealing(이하 CS)`는 데이터를 Word 단위로 전송한다. 작은 단위의 데이터를 전송할 때 워드단위로 처리되기 때문에, 잦은 인터럽트가 발생된다.\r\n따라서 DMA에 의한 인터럽트로 CPU `Cycle`을 훔치게 된다. (실제로 옛날의 컴퓨터 구조에서는 DMA 사용시 회로를 막아버림으로써 `Cycle`을 훔쳤다.) \r\n\r\n**버스트 모드(Bust mode)**\r\n\r\n`Bust Mode`는 더큰 데이터를 DMA 할 때 사용되며 메모리의 Block 단위(`4KB`, `8KB`, `64KB`)로 처리된다.  \r\n블록단위 전송으로서 인터럽트가 발생되기 때문에, 성능향상에 큰이점을 준다.\r\n"
  },
  {
    "path": "/docs/computer-science/computer-structure/interrupt",
    "header": {
      "layout": "wiki",
      "title": "CPU와 인터럽트 (Interrupt)",
      "date": 1596269400000,
      "tags": [
        "Operating System",
        "Interrupt"
      ],
      "summary": "인터럽트",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "컴퓨터",
        "하드웨어"
      ],
      "images": [
        {
          "src": "/post/computer/move-unit.png",
          "alt": "캐릭터의 이동"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "인터럽트는 무엇인가?::what-is-interrupt",
            "title": "인터럽트는 무엇인가?",
            "fragment": "what-is-interrupt",
            "children": []
          },
          {
            "rank": 2,
            "origin": "인터럽트 서비스 루틴::interrupt-service-routine",
            "title": "인터럽트 서비스 루틴",
            "fragment": "interrupt-service-routine",
            "children": []
          },
          {
            "rank": 2,
            "origin": "인터럽트의 매커니즘::mechanism-of-interrupt",
            "title": "인터럽트의 매커니즘",
            "fragment": "mechanism-of-interrupt",
            "children": []
          },
          {
            "rank": 2,
            "origin": "타이머::timer",
            "title": "타이머",
            "fragment": "timer",
            "children": []
          }
        ]
      }
    },
    "description": "",
    "content": "\r\n## 인터럽트는 무엇인가?::what-is-interrupt\r\n\r\ninterrupt `[ˌɪntəˈrʌpt]`\r\n1. (말·행동을) 방해하다[중단시키다/가로막다]\r\n2. (무엇을 잠깐) 중단시키다\r\n\r\n사전 상의 `interrupt`(이하 인터럽트)는 위와 같은 어떤 행동이나 흐름을 중단시키는 의미로 등재 되어있다.\r\n컴퓨터에서도 인터럽트는 어떤 흐름을 중지하는 역할을 한다.\r\n\r\n[CPU](/wiki/central-processing-unit)는 순차적으로 명령어를 처리한다. 하지만 예상치못하거나 긴급한상황에 의도적으로 특별한 처리를 해야한다.\r\n예를 들어 스타크래프트나 리그오브레전드처럼 3인칭시점에서 마우스로 지면을 클릭하는 경우, 해당위치로 캐릭터가 이동한다.\r\n이 경우 이동이 끝나지 않아도, 우리는 새로운 위치를 클릭하여 방향을 바꿀수도있다. \r\n\r\n![캐릭터의 이동](/post/computer/move-unit.png)\r\n:{ \"align\": \"center\", \"max-width\": \"300px\", \"description\": \"눈꽃 시비르의 방향을 조작하는 프로겐 선수\" }\r\n\r\n이 처럼 CPU가 명령을 실행하는중에도 긴급하거나, 실시간 처리가 필요한경우 IRQ를 통해, CPU에 인터럽트 신호를 보내 우선적으로 처리를 수행할 수 있다.\r\n\r\n> **I**nterrupt **R**e**Q**uest Line는 인터럽트 요청을 받을수있는 인터럽트 버스이다 이는 하드웨어에서 각 장치까지 물리적으로 연결된 신호선이다.\r\n:{ \"type\": \"note\", \"icon\": \"info\"}\r\n\r\n## 인터럽트 서비스 루틴::interrupt-service-routine\r\n\r\n**I**nterrupt **S**ervice **R**outine (이하 ISR)은 다른말로 Interrupt Handler(인터럽트 핸들러)라고도 한다.\r\n`ISR`은 인터럽트를 처리하기위한 어떤 일련의 프로세스이다. `IRQ`를 통해 `CPU`로 인터럽트 신호를 보내면(CPU의 인터럽트), CPU는 하던 일을 중단하고 ISR이 있는 주소로 실행을 옮긴다.\r\n그리고 `ISR`이 실행된후 다시 원래 연산을 재개한다. ISR은 인터럽트 번호 테이블로 구성되어있다. 이는 시스템마다 다를수 있고 콜백루틴 방식으로 처리된다.\r\n\r\n인터럽트 원인에 따라 처리되는 ISR이 별도로 있으며,이는 [커널(kernel)]()에 존재한다. \r\n인터럽트가 발생되는 원인은 일반적으로 `하드웨어 리셋`, `정해진 메모리 외부 참조`, `0으로 나누기` 등 여러 예외가 존재한다.\r\n\r\n인터럽트가 발생(*raise*)하면 `ISR`의 주소를 Interrupt Vector(이하 인터럽트 벡터)라고 하는 배열을 인터럽트 요청과 함께 장치 고유번호로 인덱싱한다.\r\n또한 `CPU`는 인터럽트를 포착(*catch*)하면 현재 실행 중이던 작업을 중단하고 `ISR`로 전송(*dispatch*)하면 루틴을 실행해야하기 때문에 실행중인 작업의 레지스터 값들을 스택에 저장하여 상태를 보존한다.\r\n이러한 값들에는 [프로그램 카운터(이하 PC)](), [스택 포인터]() 등 범용 레지스터 들이 포함된다. \r\n\r\n| 벡터 번호  | 설명                 |\r\n|--------|--------------------|\r\n| 0      | 나눗셈 에러             |\r\n| 1      | 디버그 예외             |\r\n| 2      | Null 인터럽터          |\r\n| ...    |\r\n| 18     | 기기 검사              |\r\n| 19~31  | (Intel에서 예약, 사용금지) |\r\n| 32~255 | Maskale 인터럽트       |\r\n:{ \"description\": \"표 1: Intel Processor 이벤트-벡터\", \"align\": \"center\" }\r\n\r\n`ISR`이 실행되는 동안에는 프로세서의 레지스터 값을 변경할수 있기때문에, `ISR`이 끝나기전에 인터럽트를 지우고(*clear*) 스택에 저장해 두었던 레지스터 값들을 다시 복원 하여 CPU가 인터럽트 발생 전 상태로 되돌아 갈수 있게 레지스터 값을 원복한다.\r\n`ISR`실행 후 인터럽트 요청에서 받았았던 복귀 주소를 `PC`로 적재하여 인터럽트 발생시점부터 실행을 옮겨 중단되었던 연산을 다시 시작한다.\r\n\r\n실제로는 인터럽트 벡터의 주소 개수보다 많은 장치가 있기 때문에, `인터럽트 체인` 방식을 사용한다.   \r\n이는 벡터의 각 요소를 핸들럭 목록을 체인으로 묶어, 처리할수 있는 핸들러를 찾을 떄까지 하나씩 호출하는 방법이다.\r\n\r\n위에서 `표1`에서 0~31까지는 각 루틴에 대한 마스킹이 이미 되어있기때문에 `Non Maskable Interrupt`라고 하며 예약된 루틴이고, 32부터는 Maskable 이므로 그외 인터럽트를 처리하기 위해 사용된다.\r\n\r\n> 인터럽트 우선순위 레벨 (Interrupt Priority Level *이하 `IPL`)  \r\n> `IPL`은 인터럽트 별로 우선 순위를 정하여, 인터럽트 처리에도 우선순위를 둘 수 있다.  \r\n> `IPL`은 순위에 따라 처리를 연기하거나, 순위가 더높은 인터럽트가 실행을 선점 할 수 도있다.  \r\n: { \"type\": \"note\", \"icon\": \"info\" }\r\n\r\n\r\n## 인터럽트의 매커니즘::mechanism-of-interrupt\r\n\r\n인터럽트는 CPU연산 중 신호를 받아 `ISR`을 실행한다고 하였다. 하지만 컴퓨터는 동기순차회로이기 때문에 순차적으로 연산이 이루어져야 한다.\r\n때문에, CPU가 하나의 명령어 실행이 완료될 때마다 IRQ를 감지하여 인터럽트 번호를 읽어 이 번호를 인터럽트 벡터의 인덱스로 사용하고, `ISR`로 점프하여 인덱스와 관련된 주소에서 실행을 시작한다.\r\n인터럽트 처리후 복원까지 수행하면 `return_from_interrupt` 명령어로 CPU를 인터럽트 전 실행상태로 되돌린다.\r\n\r\n> 폴링 (Polling)  \r\n> CPU가 주기적으로 장치의 상태를 직접확인하고, 상태에따라 처리하는 방식이다.  \r\n> 이는 장치컨트롤러와 연관이이 있는데, CPU와 병렬로 실행되는 장치컨트롤러는 내부의 로컬버퍼와 장치간 데이터의 전송을 담당한다.  \r\n> 장치에서 입력이있다면, 로컬버퍼로 데이터를 이동시키고 상태 레지스터의 값을 변경한다. 여기서 CPU는 장치컨트롤러의 상태 레지스터를 주기적으로 확인하여, 상태가 변경되었는지 확인하며 로컬버퍼의 데이터를 읽어와 처리한다.  \r\n> 이러한 방식은 CPU가 주기적으로 장치의 상태를 확인하기 때문에, CPU의 부하가 높아지고, 실시간 처리에 적합하지 않다. 이때 전송하는 빈도를 폴링 레이트라고한다.  폴링레이트가 높을때 입력이 많은경우 CPU의 부하가 높아지는 이유가 이것 때문이다.  \r\n:{ \"icon\": \"warning-diamond\", \"type\": \"warning\" }\r\n\r\n## 타이머::timer\r\n\r\n타이머는 설정한 시간이 지났을때 인터럽트를 발생시킬수 있는 장치이다. \r\n예컨데 사용자 프로그램이 무한루프에 빠지거나, 시스템 서비스 호출에 실패하여, 제어가 운영체제로 복귀하지않는 경우에를 대비해 설정할 수 있다.\r\n\r\n대표 적인 예가 [DMA](/wiki/direct-memory-access)이다. DMA는 CPU의 개입없이 메모리와 I/O장치간 데이터를 전송하는 기술이다.\r\nDMAC이 입출력 장치간 데이터 전송을 관장하는경우 데이터 버스에 대한 제어권를 얻게 되는데, CPU가 제어권을 넘기는 시점에 타이머를 설정하여, 지정된 시간까지 DMA가 모두 이루어지지 않는 경우 인터럽트를 발생시킨다. \r\n"
  },
  {
    "path": "/docs/software-design/visitor-pattern",
    "header": {
      "layout": "post",
      "title": "비지터 패턴 (Visitor Pattern)",
      "tags": [
        "Visitor Pattern",
        "Design Pattern",
        "Software Design"
      ],
      "date": 1593857040000,
      "thumbnail": "/post/software-design/visitor-pattern-intro.svg",
      "profile-image": "/post/profile/profile0.jpg",
      "current-company": "Cubic INC",
      "current-position": "SI Researcher",
      "summary": "비지터 패턴",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "소프트웨어 설계"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "핵심 구성요소::key-components",
            "title": "핵심 구성요소",
            "fragment": "key-components",
            "children": []
          },
          {
            "rank": 2,
            "origin": "예제::example",
            "title": "예제",
            "fragment": "example",
            "children": [
              {
                "rank": 3,
                "origin": "도형::shape-processing",
                "title": "도형",
                "fragment": "shape-processing",
                "children": []
              },
              {
                "rank": 3,
                "origin": "파일 시스템::file-system",
                "title": "파일 시스템",
                "fragment": "file-system",
                "children": []
              }
            ]
          },
          {
            "rank": 2,
            "origin": "적용::applicability",
            "title": "적용",
            "fragment": "applicability",
            "children": []
          },
          {
            "rank": 2,
            "origin": "장단점::pros-and-cons",
            "title": "장단점",
            "fragment": "pros-and-cons",
            "children": []
          }
        ]
      }
    },
    "description": "Visitor Pattern(방문자 패턴)은 공통적인 요소들에 대해 각기 다른 작업을 수행하는 기능을 분리하는 디자인 패턴이다.",
    "content": "\r\n\r\n## 핵심 구성요소::key-components\r\n\r\n* **Visitor**: 방문하여 처리할 객체의 인터페이스를 정의한다.\r\n* **Element**: 방문자를 받아들이는 객체의 인터페이스를 정의한다.\r\n* **Client**: 적절한 Visitor의 구현을 생성하고, `Element` 객체를 생성하여 `Visitor` 인터페이스를 수락한다.\r\n\r\n```mermaid\r\n---\r\nconfig:\r\n    class:\r\n        hideEmptyMembersBox: true\r\n---\r\nclassDiagram\r\n    class Visitor {\r\n        +visit(Element element)\r\n    }\r\n    class ConcreteVisitor {\r\n        +visit(Element element)\r\n    }\r\n    class Element {\r\n        +accept(Visitor visitor)\r\n    }\r\n    class ConcreteElement {\r\n        +accept(Visitor visitor)\r\n    }\r\n    Visitor <|-- ConcreteVisitor\r\n    Element <|-- ConcreteElement\r\n    Visitor <..> Element\r\n```\r\n\r\n## 예제::example\r\n\r\n비지터 패턴을 살펴보기 전에 이해할 구성 요소간 역할과 책임:\r\n\r\n* **Visitor**: 방문하여 처리할 객체의 인터페이스\r\n    * **역할**: 요소에 방문에 대해 처리한다.\r\n    * **책임**: 어떤 요소가 수락했는지 알 수 없기 때문에, 수락을 가정하고 처리를 수행한다.\r\n* **Element**: 방문자를 받아들이는 객체의 인터페이스\r\n    * **역할**: 방문자를 수락한다.\r\n    * **책임**: 방문자를 수락하면, 방문자가 객체를 사용할 수 있도록 제공해야 한다.\r\n\r\n### 도형::shape-processing\r\n\r\n여러가지의 도형이 존재한다. 이 도형은 `Square`, `Circle`, `Triangle`이 있다.\r\n도형의 넒이를 계산하려면 각 도형에 계산 공식을 정의할 수 도 있다. 하지만, `SVG`로 출력하려는 경우 해당 도형에는 `SVG`를 출력하는 비즈니스 로직을 추가 해야한다.\r\n\r\n하지만, 도형 넒이 계산 공식과 `SVG` 출력 로직은 도형과는 관계 없는 행위기 때문에, 비즈니스 구현은 내부에서 이루어질 필요가 없다.\r\n\r\n> 이를 이용해 도형의 `넒이`와 `SVG`를 출력하는 기능은 외부에서 Visitor Pattern으로 구현할 수 있다.\r\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\" }\r\n\r\n> 비즈니스 구현에대한 수락은 `Element` 객체가 할 수 있기 때문에, 선택적으로 구현할 수 있다.\r\n:{ \"type\": \"warning\", \"icon\": \"warning-diamond\" }\r\n\r\n**Visitor**\r\n\r\n::code-group\r\n\r\n```java::방문자\r\npublic interface Visitor {\r\n    void visit(Square square);\r\n    void visit(Circle circle);\r\n    void visit(Triangle triangle);\r\n}\r\n```\r\n\r\n```java::넓이계산 방문자\r\npublic class AreaCalculator implements ShapeVisitor {\r\n\r\n    private double total = 0.0;\r\n\r\n    public double getTotal() {\r\n        return total;\r\n    }\r\n\r\n    @Override\r\n    public void visitSquare(Square square) {\r\n        total += square.getSide() * square.getSide();\r\n    }\r\n\r\n    @Override\r\n    public void visitCircle(Circle circle) {\r\n        total += Math.PI * circle.getRadius() * circle.getRadius();\r\n    }\r\n\r\n    @Override\r\n    public void visitTriangle(Triangle triangle) {\r\n        total += 0.5 * triangle.getBase() * triangle.getHeight();\r\n    }\r\n}\r\n```\r\n\r\n```java::SVG 변환 방문자\r\npublic class SVGRenderer implements ShapeVisitor {\r\n    private String svg = \"\";\r\n\r\n    public String getSvg() {\r\n        return svg;\r\n    }\r\n\r\n    @Override\r\n    public void visitSquare(Square square) {\r\n        this.svg += String.format(\"<rect width=\\\"%d\\\" height=\\\"%d\\\" />\", square.getSide(), square.getSide());\r\n    }\r\n\r\n    @Override\r\n    public void visitCircle(Circle circle) {\r\n        this.svg += String.format(\"<circle r=\\\"%d\\\" />\", circle.getRadius());\r\n    }\r\n\r\n    @Override\r\n    public void visitTriangle(Triangle triangle) {\r\n        this.svg += String.format(\"<polygon points=\\\"0,0 %d,0 %d, %d\\\" />\", triangle.getBase(), triangle.getBase() /2, triangle.getHeight());\r\n    }\r\n}\r\n```\r\n\r\n::\r\n\r\n**Element**\r\n\r\n::code-group\r\n\r\n```java::도형 요소\r\npublic interface Shape {\r\n    void accept(Visitor visitor);\r\n}\r\n```\r\n\r\n```java::사각형 요소\r\npublic class Square implements Shape {\r\n\r\n    private final int side;\r\n\r\n    public Square(int side) {\r\n        this.side = side;\r\n    }\r\n\r\n    public int getSide() {\r\n        return side;\r\n    }\r\n\r\n    @Override\r\n    public void accept(ShapeVisitor visitor) {\r\n        visitor.visitSquare(this);\r\n    }\r\n}\r\n```\r\n\r\n```java::원 요소\r\npublic class Circle implements Shape {\r\n\r\n    private final int radius;\r\n\r\n    public Circle(int radius) {\r\n        this.radius = radius;\r\n    }\r\n\r\n    public int getRadius() {\r\n        return radius;\r\n    }\r\n\r\n    @Override\r\n    public void accept(ShapeVisitor visitor) {\r\n        visitor.visitCircle(this);\r\n    }\r\n}\r\n```\r\n\r\n```java::삼각형 요소\r\npublic class Triangle implements Shape {\r\n\r\n    private final int base;\r\n    private final int height;\r\n\r\n    public Triangle(int base, int height) {\r\n        this.base = base;\r\n        this.height = height;\r\n    }\r\n\r\n    public int getBase() {\r\n        return base;\r\n    }\r\n\r\n    public int getHeight() {\r\n        return height;\r\n    }\r\n\r\n    @Override\r\n    public void accept(ShapeVisitor visitor) {\r\n        visitor.visitTriangle(this);\r\n    }\r\n}\r\n```\r\n\r\n::\r\n\r\n**Client**\r\n\r\n```java::클라이언트 코드\r\nShape [] shapes = new Shape[] {\r\n    new Circle(10),\r\n    new Square(20),\r\n    new Triangle(10, 20)\r\n};\r\n\r\nAreaCalculator areaCalculator = new AreaCalculator();\r\nSVGRenderer svgRenderer = new SVGRenderer();\r\n\r\nfor (Shape shape : shapes) {\r\n    shape.accept(areaCalculator);\r\n    shape.accept(svgRenderer);\r\n}\r\n\r\nSystem.out.println(\"totalArea = \" + areaCalculator.getTotal());\r\nSystem.out.println(\"svg = \" + svgRenderer.getSvg());\r\n```\r\n\r\n```text::결과\r\ntotalArea = 814.1592653589794\r\nsvg = <circle r=\"10\" /><rect width=\"20\" height=\"20\" /><polygon points=\"0,0 10,0 5, 20\" />\r\n```\r\n\r\n위 같은 상황으로 처리에 대한 책임을 `Visitor`에게 위임하고, `Element`는 `Visitor`를 수락하여 처리를 수행한다.\r\n또한 아래와 같이 유연하게 흐름을 바꿀수도 있다.\r\n\r\n```java::✅ 요소가 수락해도 미처리\r\n@Override\r\npublic void visitPentagon(Pentagon pentagon) {\r\n    //다각형은 만들지 않는다.\r\n}\r\n```\r\n\r\n```java::✅ 모든 방문자를 수락하지 않거나, 특정 방문자만 수락\r\n@Override\r\npublic void accept(ShapeVisitor visitor) {\r\n    if (visitor instanceof SVGRenderer) {\r\n        visitor.visitPentagon(this);   \r\n    }\r\n}\r\n```\r\n\r\n> 처리에대한 책임은 `Visitor`에게 있기 때문에, `Vistor`에서 `Element`를 구별하는 것이 좋다.\r\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\" }\r\n\r\n### 파일 시스템::file-system\r\n\r\n파일 시스템에는 `파일`과 `디렉토리`가 있다.  \r\n파일의 정보를 출력하려면 각 파일에 대한 정보를 출력하는 비즈니스 로직을 추가 해야한다. 파일 크기를 구하려는 경우 해당 파일에는 파일 크기를 출력하는 비즈니스 로직을 추가 해야한다.\r\n\r\n파일 출력과 파일들 크기 계산은 파일과는 관계 없는 행위기 때문에, 비즈니스 구현은 내부에서 이루어질 필요가 없다.\r\n\r\n**Visitor**\r\n\r\n::code-group\r\n\r\n```java::방문자\r\npublic interface FileSystemVisitor {\r\n    void visit(File file);\r\n    void visit(Directory directory);\r\n}\r\n```\r\n\r\n```java::파일 출력\r\npublic class FileListPrinterVisitor implements FileSystemVisitor {\r\n\r\n    @Override\r\n    public void visit(File file) {\r\n        System.out.println(\"File: \" + file.getName() + \", Size: \" + file.getSize() + \" bytes\");\r\n    }\r\n\r\n    @Override\r\n    public void visit(Directory directory) {\r\n        System.out.println(\"Directory: \" + directory.getName());\r\n        for (var child : directory.getChildren()) {\r\n            child.accept(this);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n```java::파일 크기계산\r\npublic class SizeCalculatorVisitor implements FileSystemVisitor {\r\n    private long totalSize = 0;\r\n\r\n\r\n    @Override\r\n    public void visit(File file) {\r\n        this.totalSize += file.getSize();\r\n    }\r\n\r\n    @Override\r\n    public void visit(Directory directory) {\r\n        // 디렉토리 자체의 처리는 필요 없음\r\n        for (var child : directory.getChildren()) {\r\n            child.accept(this);\r\n        }\r\n    }\r\n\r\n    public long getTotalSize() {\r\n        return this.totalSize;\r\n    }\r\n}\r\n```\r\n\r\n::\r\n\r\n> 도형 예제와 다르게 `visit` 메서드를 오버로딩 하였다. 이는 오버로딩이 제공되는 언어에서는 다형성을 이용하여 처리할 수 있다.\r\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\" }\r\n\r\n**Element**\r\n\r\n::code-group\r\n\r\n```java::요소\r\npublic interface FileSystemElement {\r\n    void accept(FileSystemVisitor visitor);\r\n}\r\n```\r\n\r\n```java::파일\r\npublic class File implements FileSystemElement {\r\n\r\n    private final String name;\r\n    private final long size;\r\n\r\n    public File(String name, long size) {\r\n        this.name = name;\r\n        this.size = size;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public long getSize() {\r\n        return this.size;\r\n    }\r\n\r\n    @Override\r\n    public void accept(FileSystemVisitor visitor) {\r\n        visitor.visit(this);\r\n    }\r\n}\r\n```\r\n\r\n```java::디렉토리\r\npublic class Directory implements FileSystemElement {\r\n    private final String name;\r\n    private final List<FileSystemElement> children = new ArrayList<>();\r\n\r\n    public Directory(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void addChild(FileSystemElement child) {\r\n        children.add(child);\r\n    }\r\n\r\n    public List<FileSystemElement> getChildren() {\r\n        return children;\r\n    }\r\n\r\n    @Override\r\n    public void accept(FileSystemVisitor visitor) {\r\n        visitor.visit(this);\r\n    }\r\n}\r\n```\r\n\r\n::\r\n\r\n**Client**\r\n\r\n```java::클라이언트 코드\r\n// 파일 시스템 구조 생성\r\nDirectory root = new Directory(\"root\");\r\nDirectory documents = new Directory(\"documents\");\r\nDirectory pictures = new Directory(\"pictures\");\r\n\r\nroot.addChild(documents);\r\nroot.addChild(pictures);\r\n\r\ndocuments.addChild(new File(\"visitor-pattern.md\", 42366));\r\ndocuments.addChild(new File(\"composite-pattern.md\", 32456));\r\n\r\npictures.addChild(new File(\"visitor-pattern-intro.png\", 83456));\r\npictures.addChild(new File(\"visitor-pattern-diagram.svg\", 23456));\r\n\r\n//크기 계산 Visitor 사용\r\nSizeCalculatorVisitor sizeVisitor = new SizeCalculatorVisitor();\r\nroot.accept(sizeVisitor);\r\nSystem.out.println(\"Total Size: \" + sizeVisitor.getTotalSize() + \" bytes\");\r\n\r\n// 파일 목록 출력 Visitor 사용\r\nFileListPrinterVisitor printerVisitor = new FileListPrinterVisitor();\r\nroot.accept(printerVisitor);\r\n```\r\n\r\n```text::결과\r\nTotal Size: 181734 bytes\r\nDirectory: root\r\nDirectory: documents\r\nFile: visitor-pattern.md, Size: 42366 bytes\r\nFile: composite-pattern.md, Size: 32456 bytes\r\nDirectory: pictures\r\nFile: visitor-pattern-intro.png, Size: 83456 bytes\r\nFile: visitor-pattern-diagram.svg, Size: 23456 bytes\r\n```\r\n\r\n## 적용::applicability\r\n\r\n`Visitor` 패턴은 다음과 같은 경우에 사용할 수 있다.\r\n\r\n* 객체들을 순회하며, 다양한 작업을 수행해야 하는 경우\r\n* 객체의 구조와 작업을 분리하고 싶은 경우\r\n\r\n## 장단점::pros-and-cons\r\n\r\n**장점**\r\n\r\n* [개방/폐쇄 원칙](): 다른 클래스를 변경하지 않으면서 해당 클래스의 객체와 작동할 수 있는 새로운 처리를 추가할 수 있다.\r\n* [단일 책임 원칙](): 같은 행동의 여러 버전을 같은 클래스로 나눌 수 있다.\r\n* 비지터 객체는 다양한 객체들과 작업하면서 유용한 정보를 축적할 수 있다. 이것은 객체 트리와 같은 복잡한 객체 구조를 순회하여 이 구조의 각 객체에 비지터 패턴을 적용하려는 경우에 유용하다.\r\n\r\n**단점**\r\n\r\n* 클래스가 요소 계층구조에 추가되거나 제거될 때마다 모든 비지터를 업데이트해야 한다.\r\n* 비지터들은 함께 작업해야 하는 요소들의 비공개 필드들 및 메서드들에 제한적인 기능에 대해 확장이 필요할 수 있다.\r\n"
  },
  {
    "path": "/docs/software-design/command-pattern",
    "header": {
      "layout": "post",
      "title": "커맨드 패턴 (Command Pattern)",
      "tags": [
        "Command Pattern",
        "Design Pattern",
        "Software Design"
      ],
      "date": 1592386440000,
      "thumbnail": "/post/software-design/command-pattern-intro.svg",
      "profile-image": "/post/profile/profile0.jpg",
      "current-company": "Cubic INC",
      "current-position": "SI Researcher",
      "summary": "커맨드 패턴",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "소프트웨어 설계"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "핵심 구성요소::key-components",
            "title": "핵심 구성요소",
            "fragment": "key-components",
            "children": []
          },
          {
            "rank": 2,
            "origin": "예제::example",
            "title": "예제",
            "fragment": "example",
            "children": [
              {
                "rank": 3,
                "origin": "주문 처리 시스템::example-1",
                "title": "주문 처리 시스템",
                "fragment": "example-1",
                "children": []
              },
              {
                "rank": 3,
                "origin": "게임 컨트롤러::example-2",
                "title": "게임 컨트롤러",
                "fragment": "example-2",
                "children": []
              }
            ]
          },
          {
            "rank": 2,
            "origin": "적용::applicability",
            "title": "적용",
            "fragment": "applicability",
            "children": []
          },
          {
            "rank": 2,
            "origin": "장단점::pros-and-cons",
            "title": "장단점",
            "fragment": "pros-and-cons",
            "children": []
          }
        ]
      }
    },
    "description": "커맨드 패턴은 처리 명령을 독립적인 실행가능 객체로 만들어, 일괄적으로 취소 또는 실행을 할 수 있도록 하는 디자인 패턴이다.\r\n\r\n또한, 이 명령의 처리를 지연시키거나, 대기열에 넣을 수 있도록 하여 처리할 수 있다.",
    "content": "\r\n## 핵심 구성요소::key-components\r\n\r\n* **Command**: 명령을 나타내는 인터페이스/추상 클래스\r\n* **ConcreteCommand**: 실제 명령을 나타내는 구상 클래스\r\n* **Invoker**: 명령을 실행하는 객체\r\n* **Receiver**: 명령의 수신자\r\n* **Client**: ConcreteCommand 객체를 생성하고 Invoker 객체에게 전달하는 객체\r\n\r\n```mermaid\r\n---\r\nconfig:\r\n    class:\r\n        hideEmptyMembersBox: true\r\n---\r\nclassDiagram\r\n    direction LR\r\n    class Command {\r\n        <<interface>>\r\n        +execute(): void\r\n        +undo(): void\r\n    }\r\n    class ConcreteCommand {\r\n        -receiver: Receiver\r\n    }    \r\n    class Invoker {\r\n        -commands: List~Command~\r\n        +executeCommand(Command command): void\r\n        +undoLastCommand(): void\r\n    }\r\n    class Receiver {\r\n        ...\r\n        +feature1(): void\r\n        +feature2(): void\r\n    }\r\n    class Client {\r\n        \r\n    }\r\n    ConcreteCommand ..|> Command\r\n    Client ..> ConcreteCommand\r\n    Client ..> Receiver\r\n    Client ..> Invoker\r\n    Invoker --> Command\r\n    ConcreteCommand --> Receiver\r\n```\r\n\r\n## 예제::example\r\n\r\n예제를 통해 커맨드 패턴을 살펴보기 전에, 다음의 역할과 책임을 명심하자.\r\n\r\n* `Invoker`\r\n  * **역할**: 명령 호출자 객체이며, 명령을 목록을 관리한다.\r\n  * **책임**: 명령을 실행하거나 취소한다.\r\n* `Command`\r\n  * **역할**: 명령의 구현이며, 비즈니스 논리 객체중 하나에게 호출을 전달한다.\r\n  * **책임**: 명령에 대한 실행과 취소를 `Receiver` 객체를 이용해 수행한다.\r\n* `Receiver`\r\n  * **역할**: 외부에서 호출을 전달받는다.\r\n  * **책임**: 전달 받은 호출에대한 비즈니스 로직을 수행한다.\r\n* `Client`\r\n  * **역할**: 실제 명령을 `Invoker`에게 전달한다.\r\n  * **책임**: 실제 명령을 생성하여 `Invoker`와 연결하며, 실행흐름을 제어한다.\r\n\r\n\r\n### 주문 처리 시스템::example-1\r\n\r\n주문 처리에 대한 시스템을 만들고자 한다.\r\n구매하는 상품에대한 주문이있고, 해당 주문에 대하여 생성하거나 변경하는 기능을 만들어보자. \r\n\r\n**Command**\r\n\r\n수행하려는 주문 행위에 단위의 명령을 구현한다.\r\n\r\n::code-group\r\n\r\n```java::주문 명령\r\npublic interface OrderCommand {\r\n\r\n    void execute();\r\n\r\n    void undo();\r\n}\r\n```\r\n\r\n```java::주문생성 명령\r\npublic class CreateOrderCommand implements OrderCommand {\r\n\r\n    private final OrderManager receiver;\r\n    private final Order order;\r\n\r\n    public CreateOrderCommand(OrderManager receiver, Order order) {\r\n        this.receiver = receiver;\r\n        this.order = order;\r\n    }\r\n\r\n    @Override\r\n    public void execute() {\r\n        this.receiver.createOrder(order);\r\n    }\r\n\r\n    @Override\r\n    public void undo() {\r\n        this.receiver.cancelOrder(order);\r\n    }\r\n}\r\n```\r\n\r\n```java::주문변경 명령\r\npublic class UpdateOrderCommand implements OrderCommand {\r\n\r\n    private OrderManager receiver;\r\n    private Order order;\r\n    private OrderStatus previousOrder;\r\n    private OrderStatus newStatus;\r\n\r\n    public UpdateOrderCommand(OrderManager receiver, Order order, OrderStatus newStatus) {\r\n        this.receiver = receiver;\r\n        this.order = order;\r\n        this.newStatus = newStatus;\r\n        this.previousOrder = order.getStatus();\r\n    }\r\n\r\n    @Override\r\n    public void execute() {\r\n        receiver.updateOrderStatus(order, newStatus);\r\n    }\r\n\r\n    @Override\r\n    public void undo() {\r\n        receiver.updateOrderStatus(order, previousOrder);\r\n    }\r\n}\r\n```\r\n\r\n::\r\n\r\n**Invoker**\r\n\r\n주문처리 행위에대한 명령들을 관리하며, 실행하거나 취소할 수 있다.\r\n\r\n```java::주문 처리에 대한 호출자\r\npublic class OrderCommandInvoker {\r\n    private final List<OrderCommand> commands = new ArrayList<>();\r\n\r\n    public void executeCommand(OrderCommand command) {\r\n        command.execute();\r\n        commands.add(command);\r\n    }\r\n\r\n    public void undoLastCommand() {\r\n        if (!commands.isEmpty()) {\r\n            OrderCommand lastCommand = commands.remove(commands.size() - 1);\r\n            lastCommand.undo();\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n**Receiver**\r\n\r\n`Invoker`가 호출하는 `Command`에 대한 실제 비즈니스 로직을 수행한다.\r\n\r\n```java::주문 처리의 수신자\r\npublic class OrderManager {\r\n    private List<Order> orders = new ArrayList<>();\r\n\r\n    public void createOrder(Order order) {\r\n        orders.add(order);\r\n        System.out.println(\"Order created: \" + order.getOrderId());\r\n    }\r\n\r\n    public void cancelOrder(Order order) {\r\n        orders.remove(order);\r\n        System.out.println(\"Order cancelled: \" + order.getOrderId());\r\n    }\r\n\r\n    public void updateOrderStatus(Order order, OrderStatus status) {\r\n        order.setStatus(status);\r\n        System.out.println(\"Order \" + order.getOrderId() + \" status updated to: \" + status);\r\n    }\r\n\r\n    public List<Order> getOrders() {\r\n        return orders;\r\n    }\r\n}\r\n```\r\n\r\n**Client**\r\n\r\n전반적인 실행흐름을 제어하며, `Command`를 생성하여 Invoker에게 전달한다.\r\n\r\n```java::클라이언트 코드\r\nOrderManager receiver = new OrderManager();\r\nOrderCommandInvoker invoker = new OrderCommandInvoker();\r\n\r\n//Create Command\r\nProduct laptop = new Product(\"Laptop\", 999.99);\r\nProduct phone = new Product(\"Phone\", 499.00);\r\n\r\n//CreateOrder\r\nOrder order = new Order(List.of(laptop, phone));\r\n\r\n//Create Order Command\r\nCreateOrderCommand createCommand = new CreateOrderCommand(receiver, order);\r\ninvoker.executeCommand(createCommand);\r\n\r\n//Update Order Command\r\nUpdateOrderCommand updateCommand = new UpdateOrderCommand(receiver, order, OrderStatus.SHIPPED);\r\ninvoker.executeCommand(updateCommand);\r\n\r\n//undo last command\r\ninvoker.undoLastCommand();\r\n```\r\n\r\n### 게임 컨트롤러::example-2\r\n\r\n간단한 슈퍼마리오 게임을 만드려고한다.\r\n앞으로 또는 뒤로 가거나 점프를 할 수 있으며, 공격도 가능하다.\r\n\r\n**Command**\r\n\r\n게임 컨트롤러에서 수행할 있는 명령들을 `Command`로 추상화하여 구현한다.\r\n\r\n::code-group\r\n\r\n\r\n```java::게임 명령\r\npublic interface Command {\r\n\r\n    void execute();\r\n    void undo();\r\n}\r\n```\r\n\r\n```java::점프 명령\r\npublic class JumpCommand implements Command {\r\n    private GameCharacter receiver;\r\n    \r\n    public JumpCommand(GameCharacter receiver) {\r\n        this.receiver = receiver;\r\n    }\r\n\r\n    @Override\r\n    public void execute() {\r\n        this.receiver.jump();\r\n    }\r\n\r\n    @Override\r\n    public void undo() {\r\n        System.out.println(\"Jump command undone\");\r\n    }\r\n}\r\n```\r\n\r\n```java::이동 명령\r\npublic class MoveCommand implements Command {\r\n    private GameCharacter receiver;\r\n\r\n    public MoveCommand(GameCharacter character) {\r\n        this.receiver = character;\r\n    }\r\n\r\n    @Override\r\n    public void execute() {\r\n        receiver.moveForWard();\r\n    }\r\n\r\n    @Override\r\n    public void undo() {\r\n        receiver.moveBack();\r\n    }\r\n}\r\n```\r\n\r\n```java::공격 명령\r\npublic class AttackCommand implements Command {\r\n\r\n    private GameCharacter receiver;\r\n\r\n    public AttackCommand(GameCharacter receiver) {\r\n        this.receiver = receiver;\r\n    }\r\n\r\n    @Override\r\n    public void execute() {\r\n        receiver.attack();\r\n    }\r\n\r\n    @Override\r\n    public void undo() {\r\n        System.out.println(\"Attack command undone\");\r\n    }\r\n}\r\n```\r\n\r\n::\r\n\r\n**Invoker**\r\n\r\n사용자(`Client`)와 인터페이스 할 수 있는 컨트롤러이다.\r\n실제 명령을 호출하거나, 취소하며 명령들을 관리한다.\r\n\r\n```java::게임 컨트롤러\r\npublic class GameController {\r\n    private Command[] buttons = new Command[3];\r\n    private List<Command> commandHistory = new ArrayList<>();\r\n\r\n    public void setCommand(int slot, Command command) {\r\n        buttons[slot] = command;\r\n    }\r\n\r\n    public void pressButton(int slot) {\r\n        if (buttons[slot] != null) {\r\n            buttons[slot].execute();\r\n            commandHistory.add(buttons[slot]);\r\n        }\r\n    }\r\n\r\n    public void undoLastCommand() {\r\n        if (!commandHistory.isEmpty()) {\r\n            Command lastCommand = commandHistory.remove(commandHistory.size() - 1);\r\n            lastCommand.undo();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**Receiver**\r\n\r\n외부에서 전달되는 명령을 수행하는 주체적인 객체 자체이다.\r\n게임 캐릭터이며, 실제 비즈니스 로직을 수행한다. 캐릭터는 스스로 움직이지는 않지만, 외부 명령에 대해 캡슐화하여 이에 맞는 동작을 스스로 판단하여 수행한다.\r\n\r\n\r\n```java::캐릭터\r\npublic class GameCharacter {\r\n\r\n    private final String name;\r\n    private int positionX = 0;\r\n    private int positionY = 0;\r\n\r\n    public GameCharacter(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public void moveForWard() {\r\n        this.positionX += 1;\r\n        System.out.println(name + \" moved forward to position X: \" + this.positionX);\r\n    }\r\n\r\n    public void moveBack() {\r\n        this.positionX -= 1;\r\n        System.out.println(name + \" moved back to position X: \" + this.positionX);\r\n    }\r\n\r\n    public void jump() {\r\n        positionY += 2;\r\n        System.out.println(name + \" jumped to height Y: \" + positionY);\r\n        // 중력으로 인해 다시 내려옴\r\n        positionY = 0;\r\n    }\r\n\r\n    public void attack() {\r\n        System.out.println(name + \" performed attack!\");\r\n    }\r\n}\r\n```\r\n\r\n**Client**\r\n\r\n```java::클라이언트 코드\r\n// Receiver 생성\r\nGameCharacter mario = new GameCharacter(\"Mario\");\r\n\r\n// Commands 생성\r\nCommand moveCommand = new MoveCommand(mario);\r\nCommand jumpCommand = new JumpCommand(mario);\r\nCommand attackCommand = new AttackCommand(mario);\r\n\r\n// Invoker 설정\r\nGameController controller = new GameController();\r\ncontroller.setCommand(0, moveCommand);  // 버튼 0: 이동\r\ncontroller.setCommand(1, jumpCommand);  // 버튼 1: 점프\r\ncontroller.setCommand(2, attackCommand); // 버튼 2: 공격\r\n\r\n// 게임 플레이 시뮬레이션\r\nSystem.out.println(\"=== Game Start ===\");\r\ncontroller.pressButton(0); // 이동\r\ncontroller.pressButton(1); // 점프\r\ncontroller.pressButton(2); // 공격\r\n\r\nSystem.out.println(\"\\n=== Undo Last Action ===\");\r\ncontroller.undoLastCommand(); // 마지막 명령 취소\r\n```\r\n\r\n> 커맨드 패턴은 각 구성요소 간 역할(전달, 실행, 관리)을 분리하여 객체간 결합도를 낮추어 유연한 구조로 명령들을 수행할 수 있다.\r\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\" }\r\n\r\n\r\n## 적용::applicability\r\n\r\n커맨드 패턴의 구성 요소는 결합도를 낮추기위해 존재하지만, 가장 큰 이점은 각 명령이 독립적으로 실행가능한 객체로 만들어진다는 것이다.  \r\n\r\n이는, `Receiver` 스스로는 수행될 명령을 알 필요가 없으며, 내부 의존 객체에 대해서 상태를 변경할 수 있는 인터페이스만 제공하면, `Command`에서 확장하여 기능을 만들어 사용할 수 도 있기 때문이다.  \r\n\r\n이 확장을 이용해, 독립적으로 행위의 단위를 추상화 하여 명령을 수행 하거나 취소 한다. `Client`는 이러한 단순화된 명령을 필요에 맞게 호출자에게 전달만 한다면, `Invoker`는 명령을 실행하거나 취소하는 역할만 수행하면 된다.\r\n\r\n커맨드 패턴은 작업들의 실행을 **예약**하거나, 큐잉(Queueing)할 수 있으며, **로그**를 남기거나 **복구**할 수 있는 기능을 제공하기 때문에, **직렬화된 실행 단위의 구조**에서 사용하기 적합하다. \r\n\r\n\r\n## 장단점::pros-and-cons\r\n\r\n**장점**\r\n\r\n* [단일 책임 원칙](): 작업을 호출하는 클래스들을 수행하는 클래스들로 부터 분리할 수 있다.\r\n* [개방/폐쇄 원칙](): 기존 클라이언트 코드를 손상하지 않고 앱에 새 커맨드들을 도입할 수 있다.\r\n* 실행 취소또는 재실행을 구현할 수 있다.\r\n* 작업들의 지연된 실행을 구현할 수있다.\r\n* 간단한 커맨드들의 집합을 복잡한 커맨드로 조합할 수 있다\r\n\r\n**단점**\r\n\r\n* 발송자와 수신자 사이에 추가 클래스를 도입하여 코드 복잡성이 증가할 수 있다.\r\n"
  },
  {
    "path": "/docs/software-design/bridge-pattern",
    "header": {
      "layout": "post",
      "title": "브릿지 패턴 (Bridge Pattern)",
      "tags": [
        "Bridge Pattern",
        "Design Pattern",
        "Software Design",
        "OCP",
        "SRP"
      ],
      "date": 1592191020000,
      "thumbnail": "/post/software-design/bridge-pattern-intro.svg",
      "profile-image": "/post/profile/profile0.jpg",
      "current-company": "Cubic INC",
      "current-position": "SI Researcher",
      "summary": "브릿지 패턴",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "소프트웨어 설계"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "핵심 구성요소::key-components",
            "title": "핵심 구성요소",
            "fragment": "key-components",
            "children": []
          },
          {
            "rank": 2,
            "origin": "예제::example",
            "title": "예제",
            "fragment": "example",
            "children": [
              {
                "rank": 3,
                "origin": "멀티 미디어 플레이어::-player-example",
                "title": "멀티 미디어 플레이어",
                "fragment": "-player-example",
                "children": []
              },
              {
                "rank": 3,
                "origin": "메세지 발송 시스템::message-sender-example",
                "title": "메세지 발송 시스템",
                "fragment": "message-sender-example",
                "children": []
              }
            ]
          },
          {
            "rank": 2,
            "origin": "적용::applicability",
            "title": "적용",
            "fragment": "applicability",
            "children": []
          },
          {
            "rank": 2,
            "origin": "장단점::pros-and-cons",
            "title": "장단점",
            "fragment": "pros-and-cons",
            "children": []
          }
        ]
      }
    },
    "description": "브릿지 패턴은 구현부와 추상부를 분리하여 각각 독립적으로 변형할 수 있도록 하는 패턴이다.\r\n이 패턴은 각각의 독립된 클래스로 구성하여 서로 연결하여 사용할 수 있도록 한다.",
    "content": "\r\n## 핵심 구성요소::key-components\r\n\r\n- **Abstraction**: 기능의 구현을 위한 인터페이스를 정의한다.\r\n- **RefinedAbstraction**: Abstraction 인터페이스를 구현하여 기능을 확장한다.\r\n- **Implementor**: 실제 동작의 구현부를 정의한다.\r\n- **ConcreteImplementor**: Implementor 인터페이스를 구현하여 실제 동작을 수행한다.\r\n- **Client**: Bridge 패턴을 사용하는 클래스이다.\r\n\r\n먼저 Bridge 패턴을 사용하기 위해 선언한 핵심 구성요소는 아래와 같은 관계로 구성된다.\r\n\r\n```mermaid\r\nclassDiagram\r\n    class Abstraction {\r\n        <<abstract>>\r\n        -Implementor implementor\r\n        +changeImplementor(Implementor implementor)\r\n        +feature1()\r\n        +feature2()\r\n    }\r\n    class RefineAbstraction {\r\n        +feature1()\r\n        +feature2()\r\n    }\r\n    class Implementor {\r\n        <<interface>>\r\n        +method1()\r\n        +method2()\r\n        +method3()\r\n    }\r\n    class ConcreteImplementorA {\r\n        +method1()\r\n        +method2()\r\n        +method3()\r\n    }\r\n    class ConcreteImplementorB {\r\n        +method1()\r\n        +method2()\r\n        +method3()\r\n    }\r\n    RefineAbstraction --|> Abstraction\r\n    ConcreteImplementorA ..|> Implementor\r\n    ConcreteImplementorB ..|> Implementor\r\n    Abstraction --> Implementor\r\n```\r\n\r\n각각의 구현부(Implementor)와 추상부(Abstraction)라는 Bridge 통해 연결되어 사용자에게 제공 된다.  \r\n**또한 구현부는 런타임에 언제든지 변경할 수 있기 때문에 추상부만 참조하는 유연한 구조를 가지고 있다.**\r\n위의 다이어그램을 보면 추상부를 추가하고 싶다면 정제된 추상부(RefineAbstraction)를 추가하여 구현하면 되며, 구현부를 추가하고 싶다면, 실제 구현부(ConcreteImplementor)를 추가하여 구현하면 된다.\r\n\r\n## 예제::example\r\n\r\n`Bridge Pattern`을 알아보기 위해 다음과 같은 예제를 살펴보자.\r\n\r\n### 멀티 미디어 플레이어::-player-example\r\n\r\n다양한 장치의 미디어 플레이어를 구현하려 한다.\r\n또한 각각의 장치에서는 미디어 플레이어의 기능을 확장하여 동영상 플레이어와 음악 플레이어를 구현하려 한다.\r\n\r\n이들 간에 공통적인 기능을 추상화하여 구현하고, 각각의 플레이어들은 이를 구현하여 사용한다.\r\n\r\n\r\n**Implementor**\r\n\r\n공통적인 기능을 추상화하여 구현한다.\r\n\r\n::code-group\r\n\r\n```java::PlayerImplementor.java\r\npublic interface PlayerImplementor {\r\n\r\n    //파일명을 받아 플레이 한다.\r\n    void playFile(String filename);\r\n\r\n    //일시정지\r\n    void stopPlayback();\r\n\r\n    //코덱을 로드한다.\r\n    void loadCodec(String codec);\r\n}\r\n```\r\n\r\n```java::WindowsPlayer.java\r\npublic class WindowsPlayer implements PlayerImplementor {\r\n\r\n    @Override\r\n    public void playFile(String filename) {\r\n        loadCodec(\"Windows DirectShow\");\r\n        System.out.println(\"Playing \" + filename + \" using Windows media player\");\r\n    }\r\n\r\n    @Override\r\n    public void stopPlayback() {\r\n        System.out.println(\"Stopping playback on Windows\");\r\n    }\r\n\r\n    @Override\r\n    public void loadCodec(String codec) {\r\n        System.out.println(\"Loading \" + codec + \" codec on Windows\");\r\n    }\r\n}\r\n```\r\n\r\n```java::MacPlayer.java\r\npublic class MacPlayer implements PlayerImplementor {\r\n    @Override\r\n    public void playFile(String filename) {\r\n        loadCodec(\"Apple QuickTime\");\r\n        System.out.println(\"Playing \"+ filename + \" using QuickTime Player\");\r\n    }\r\n\r\n    @Override\r\n    public void stopPlayback() {\r\n        System.out.println(\"Stopping playback on MacOS\");\r\n    }\r\n\r\n    @Override\r\n    public void loadCodec(String codec) {\r\n        System.out.println(\"Loading \" + codec + \" codec on MacOS\");\r\n    }\r\n}\r\n```\r\n\r\n::\r\n\r\n**Abstraction**\r\n\r\nImplementor 인터페이스를 참조하여 기능을 확장한다.\r\n\r\n::code-group\r\n\r\n```java::MediaPlayer.java\r\npublic abstract class MediaPlayer {\r\n\r\n    protected PlayerImplementor implementor;\r\n\r\n    public MediaPlayer(PlayerImplementor implementor) {\r\n        this.implementor = implementor;\r\n    }\r\n\r\n    public abstract void play(String filename);\r\n    public abstract void stop();\r\n}\r\n```\r\n\r\n```java::VideoPlayer.java\r\npublic class VideoPlayer extends MediaPlayer {\r\n\r\n    public VideoPlayer(PlayerImplementor implementor) {\r\n        super(implementor);\r\n    }\r\n\r\n    @Override\r\n    public void play(String filename) {\r\n        System.out.println(\"Video Player:\");\r\n        implementor.playFile(filename);\r\n    }\r\n\r\n    @Override\r\n    public void stop() {\r\n        System.out.println(\"Video Player:\");\r\n        implementor.stopPlayback();\r\n    }\r\n}\r\n```\r\n\r\n```java::MusicPlayer.java\r\npublic class MusicPlayer extends MediaPlayer {\r\n\r\n    public MusicPlayer(PlayerImplementor implementor) {\r\n        super(implementor);\r\n    }\r\n\r\n    @Override\r\n    public void play(String filename) {\r\n        System.out.println(\"Music Player:\");\r\n        implementor.playFile(filename);\r\n    }\r\n\r\n    @Override\r\n    public void stop() {\r\n        System.out.println(\"Music Player:\");\r\n        implementor.stopPlayback();\r\n    }\r\n}\r\n```\r\n\r\n::\r\n\r\n\r\n**Client**\r\n\r\n클라이언트에서는 실제로 각각의 독립된 컴포넌트를 이용해, 다양한 기능으로 확장하여 사용할 수 있다.\r\n\r\n::code-group\r\n\r\n```java::MacOS의 음악 플레이어 예제\r\nPlayerImplementor macPlayer = new MacPlayer();\r\nMediaPlayer macMusicPlayer = new MusicPlayer(macPlayer);\r\n\r\nmacMusicPlayer.play(\"music.mp3\");\r\nmacMusicPlayer.stop();\r\n```\r\n\r\n```java::Windows의 동영상 플레이어 예제\r\nPlayerImplementor windowsPlayer = new WindowsPlayer();\r\nMediaPlayer windowsVideoPlayer = new VideoPlayer(windowsPlayer);\r\n\r\nwindowsVideoPlayer.play(\"video.mp4\");\r\nwindowsVideoPlayer.stop();\r\n```\r\n\r\n::\r\n\r\n\r\n#### 추가적인 요구사항::additional-requirements\r\n\r\n위의 기능이 경우 추상부와 구현부는 명백하게 독립적으로 동작한다.\r\n만약 현재의 상황에서 AppPlayer 가 추가된다면 어떨까? BlueStack 앱에 대해 확장할 수있는 코드를 아래와 같이 추가할 수있다.\r\n\r\n\r\n::code-group\r\n\r\n```java::AndroidAppPlayer.java\r\npublic abstract class AndroidAppPlayer extends MediaPlayer {\r\n\r\n    public AndroidAppPlayer(PlayerImplementor implementor) {\r\n        super(implementor);\r\n    }\r\n    \r\n    protected void emulateVirtualMachine() {\r\n        System.out.println(\"Emulating Android Virtual Machine\");\r\n    }\r\n}\r\n```\r\n\r\n```java::BlueStackAppPlayer.java\r\npublic class BlueStackAppPlayer extends AndroidAppPlayer {\r\n\r\n    public BlueStackAppPlayer(PlayerImplementor implementor) {\r\n        super(implementor);\r\n    }\r\n\r\n    @Override\r\n    public void play(String filename) {\r\n        super.emulateVirtualMachine();\r\n        System.out.println(\"App Player:\");\r\n        implementor.playFile(filename);\r\n    }\r\n\r\n    @Override\r\n    public void stop() {\r\n        System.out.println(\"App Player:\");\r\n        implementor.stopPlayback();\r\n    }\r\n}\r\n```\r\n\r\n```java::Windows의 BlueStack 앱 플레이어 예제\r\n\r\nPlayerImplementor windowsPlayer = new WindowsPlayer();\r\nMediaPlayer windowsBlueStackPlayer = new BlueStackAppPlayer(windowsPlayer);\r\n\r\nwindowsBlueStackPlayer.play(\"app.apk\");\r\nwindowsBlueStackPlayer.stop();\r\n```\r\n\r\n::\r\n\r\n\r\n### 메세지 발송 시스템::message-sender-example\r\n\r\n공통 구현부로는 메세징 플랫폼이 존재한다.\r\n이 구현부를 확장하여 메세지 전송에 대한 추상적인 부분을 확장한다.\r\n\r\n**Implementor**\r\n\r\n구현부로서 다음의 기능을 공통화한다.\r\n\r\n1. 실제 메세지 전송\r\n2. 수신인 검증\r\n3. 메세지 설정 세팅\r\n\r\n::code-group\r\n\r\n```java::MessageSenderImplementor.java\r\npublic interface MessageSenderImplementor {\r\n\r\n    void sendMessage(String message, String recipient);\r\n    boolean validateRecipient(String recipient);\r\n    void configureSettings(Map<String, String> settings);\r\n}\r\n```\r\n\r\n```java::EmailPlatform.java\r\npublic class EmailPlatform implements MessageSenderImplementor {\r\n\r\n    @Override\r\n    public void sendMessage(String message, String recipient) {\r\n        if (validateRecipient(recipient)) {\r\n            System.out.println(\"Sending email to \" + recipient);\r\n            System.out.println(\"Email content: \" + message);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean validateRecipient(String recipient) {\r\n        return recipient.matches(\"^[A-Za-z0-9+_.-]+@(.+)$\");\r\n    }\r\n\r\n    @Override\r\n    public void configureSettings(Map<String, String> settings) {\r\n        System.out.println(\"Configuring email settings: \" + settings);\r\n    }\r\n}\r\n```\r\n\r\n```java::SMSPlatform.java\r\npublic class SMSPlatform implements MessageSenderImplementor {\r\n\r\n    @Override\r\n    public void sendMessage(String message, String recipient) {\r\n        if (validateRecipient(recipient)) {\r\n            System.out.println(\"Sending SMS to \" + recipient);\r\n            System.out.println(\"SMS content: \" + message);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public boolean validateRecipient(String recipient) {\r\n        return recipient.matches(\"^\\\\d{10}$\");\r\n    }\r\n\r\n    @Override\r\n    public void configureSettings(Map<String, String> settings) {\r\n        System.out.println(\"Configuring SMS settings: \" + settings);\r\n    }\r\n}\r\n```\r\n\r\n::\r\n\r\n**Abstraction**\r\n\r\n추상부로서 구현부의 기능을 확장하여 긴급 메세지, 일반 메세지 등을 처리할 수 있는 메세지 전송자를 구현한다.\r\n\r\n\r\n::code-group\r\n\r\n```java::MessageSender.java\r\npublic abstract class MessageSender {\r\n    protected MessageSenderImplementor implementor;\r\n\r\n    protected MessageSender(MessageSenderImplementor implementor) {\r\n        this.implementor = implementor;\r\n    }\r\n\r\n    protected void changeImplementor(MessageSenderImplementor implementor) {\r\n        this.implementor = implementor;\r\n    }\r\n\r\n    public abstract void send(String message, String recipient);\r\n}\r\n```\r\n\r\n```java::UrgentMessageSender.java\r\npublic class UrgentMessageSender extends MessageSender {\r\n\r\n    public UrgentMessageSender(MessageSenderImplementor implementor) {\r\n        super(implementor);\r\n    }\r\n\r\n    @Override\r\n    public void send(String message, String recipient) {\r\n        message = \"[URGENT] \" + message;\r\n        implementor.sendMessage(message, recipient);\r\n    }\r\n}\r\n```\r\n\r\n```java::RegalarMessageSender.java\r\npublic class RegularMessageSender extends MessageSender {\r\n\r\n    public RegularMessageSender(MessageSenderImplementor implementor) {\r\n        super(implementor);\r\n    }\r\n\r\n    @Override\r\n    public void send(String message, String recipient) {\r\n        implementor.sendMessage(message, recipient);\r\n    }\r\n}\r\n```\r\n\r\n::\r\n\r\n**Client**\r\n\r\n클라이언트에서는 실제로 각각의 독립된 컴포넌트를 이용해, 다양한 기능으로 확장하여 사용할 수 있다.\r\n\r\n```java::메세지 발송 예제\r\nMap<String, String> emailSettings = new HashMap<>();\r\nemailSettings.put(\"smtp\", \"smtp.gmail.com\");\r\nemailSettings.put(\"port\", \"587\");\r\n\r\nMap<String, String> smsSettings = new HashMap<>();\r\nsmsSettings.put(\"api_key\", \"your_api_key\");\r\nsmsSettings.put(\"provider\", \"twilio\");\r\n\r\n\r\nMessageSenderImplementor emailPlatform = new EmailPlatform();\r\nMessageSenderImplementor smsPlatform = new EmailPlatform();\r\n\r\nemailPlatform.configureSettings(emailSettings);\r\nsmsPlatform.configureSettings(smsSettings);\r\n\r\nMessageSender urgentEmailSender = new UrgentMessageSender(emailPlatform);\r\nMessageSender regularSMSSender = new RegularMessageSender(smsPlatform);\r\n\r\nurgentEmailSender.send(\"Server is down!\", \"admin@company.com\");\r\nregularSMSSender.send(\"Hello, how are you?\", \"+1234567890\");\r\n```\r\n\r\n## 적용::applicability\r\n\r\n> 브릿지 패턴은 여러 변형을 가진 모놀리식 클래스를 분리하여 각각의 독립적인 클래스로 나누고 다양한 확장 기능을 구조화하여 연결하기 위해 사용한다.\r\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\" }\r\n\r\n어떤 기능 정의하는 클래스가 거대해질 수록 작동 방식이 복잡해지고, 유지보수 및 확장이 어려워진다.\r\n한곳에 있는 코드는 다른 코드에 영향을 미치기 쉽기 때문에, 이를 분리하여 독립적으로 관리할 수 있도록 하는것이 좋다.\r\n\r\n브릿지 패턴을 사용하면, 모놀리식 클래스를 여러 클래스 계층구조로 나눌수있다. 그런 다음 각 계층구조의 클래스들을 다른 계층구조들에 있는 클래스들과는 독립적으로 변경할 수 있다.\r\n이 접근 방식은 코드의 유지관리를 단순화하고 기존코 드가 손상될 위험을 최소화한다.\r\n\r\n\r\n## 장단점::pros-and-cons\r\n\r\n**장점**\r\n\r\n* 플랫폼 독립적인 클래스들과 앱들을 만들 수 있다.\r\n* 클라이언트 코드는 상위 수준의 추상화를 통해 작동하며, 플랫폼 세부 정보에 노출 되지 않는다.\r\n* [개방/폐쇄 원칙](): 새로운 추상화 들과 구현들을 상호 독립적으로 도입할 수 있다.\r\n* [단일 책임 원칙](): 추상화의 상위수준 논리와 구현의 플랫폼 세부 정보에 집중할 수 있다.\r\n\r\n**단점**\r\n\r\n* 결합도가 높은 클래스에 패턴을 적용하면 코드를 더 복잡하게 만들 수 있다.\r\n"
  },
  {
    "path": "/docs/software-design/adapter-pattern",
    "header": {
      "layout": "post",
      "title": "어댑터 패턴 (Adapter Pattern)",
      "tags": [
        "Adapter Pattern",
        "Design Pattern"
      ],
      "date": 1591960620000,
      "thumbnail": "/post/software-design/adapter-pattern-intro.svg",
      "profile-image": "/post/profile/profile0.jpg",
      "current-company": "Cubic INC",
      "current-position": "SI Researcher",
      "summary": "어댑터 패턴",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "소프트웨어 설계"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "구성요소",
            "title": "구성요소",
            "fragment": "root-0",
            "children": []
          },
          {
            "rank": 2,
            "origin": "예제",
            "title": "예제",
            "fragment": "root-1",
            "children": [
              {
                "rank": 3,
                "origin": "상황",
                "title": "상황",
                "fragment": "root-1-0",
                "children": []
              },
              {
                "rank": 3,
                "origin": "구성요소 정의",
                "title": "구성요소 정의",
                "fragment": "root-1-1",
                "children": []
              },
              {
                "rank": 3,
                "origin": "사용",
                "title": "사용",
                "fragment": "root-1-2",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "어댑터 패턴은 직접적으로 바로 사용이 불가능한 클래스를 사용할 수 있도록 하는 패턴이다.\r\n이 패턴은 기존의 클래스를 수정하지 않고, 새로운 클래스를 생성하여 기존의 클래스를 사용할 수 있도록 한다.",
    "content": "\r\n## 구성요소\r\n\r\n- Target: 어댑터 패턴을 사용하기 위한 인터페이스를 정의한다.\r\n- Adapter: Target 인터페이스를 구현하여 기존의 클래스를 사용할 수 있도록 한다.\r\n- Adaptee: 어댑터 패턴을 사용하기 위한 기존의 클래스이다.\r\n- Client: Adapter 패턴을 사용하는 클래스이다.\r\n\r\n## 예제\r\n\r\n먼저 Adapter 패턴을 사용하기 위해 선언한 핵심 구성요소는 아래와 같은 클래스들로 구성된다.\r\n\r\n### 상황\r\n\r\n기존에 사용하던 결제 시스템이 있다고 가정하자. 이 결제 시스템은 `Payment` 인터페이스를 구현하고 있다.\r\n하지만, 새로운 결제수단으로 PayPal을 사용하고자 한다. PayPal은 `PayPalAPI` 클래스를 사용하여 결제를 처리한다.\r\n이를 위해 추가적인 코드의 작성이 필요한 상황이다.\r\n\r\n\r\n### 구성요소 정의 \r\n\r\n::code-group\r\n\r\n```Payment.java\r\npublic interface Payment {\r\n\r\n    void processPayment(double amount);\r\n\r\n    PaymentStatus checkStatus(String paymentId);\r\n}\r\n\r\n```\r\n```PayPalAPI.java\r\npublic class PayPalAPI {\r\n\r\n    public void makePayment(PayPalPaymentRequest request) {\r\n        System.out.println(\"Making PayPal payment of \" + request.getAmount());\r\n    }\r\n\r\n    public PayPalPaymentStatus getPaymentStatus(PaypalTransactionId txId) {\r\n        return PayPalPaymentStatus.SUCCESS;\r\n    }\r\n}\r\n```\r\n```PayPalAdapter.java\r\npublic class PaypalAdapter implements Payment {\r\n\r\n    private final PayPalAPI payPalAPI;\r\n\r\n    public PaypalAdapter(PayPalAPI payPalAPI) {\r\n        this.payPalAPI = payPalAPI;\r\n    }\r\n\r\n    @Override\r\n    public void processPayment(double amount) {\r\n        PayPalPaymentRequest request = new PayPalPaymentRequest(amount);\r\n        payPalAPI.makePayment(request);\r\n    }\r\n\r\n    @Override\r\n    public PaymentStatus checkStatus(String paymentId) {\r\n        PaypalTransactionId txId = new PaypalTransactionId(paymentId);\r\n        PayPalPaymentStatus paymentStatus = payPalAPI.getPaymentStatus(txId);\r\n\r\n        return convertPayPalStatus(paymentStatus);\r\n    }\r\n    ...\r\n}\r\n```\r\n```PaymentProcessor.java\r\npublic class PaymentProcessor {\r\n\r\n    private final Payment paymentSystem;\r\n\r\n    public PaymentProcessor(Payment paymentSystem) {\r\n        this.paymentSystem = paymentSystem;\r\n    }\r\n\r\n    public void process(Order order) {\r\n        paymentSystem.processPayment(order.getTotal());\r\n        //결제상태 확인\r\n        PaymentStatus paymentStatus = paymentSystem.checkStatus(\"AE2D123-12\");\r\n        System.out.println(\"Payment status: \" + paymentStatus);\r\n\r\n    }\r\n}\r\n```\r\n\r\n::\r\n\r\n위의 코드로 어댑터 패턴의 핵심 구성요소를 설명하면 다음과 같다.\r\n\r\n* Target: Payment.java\r\n* Adapter: PaypalAdapter.java\r\n* Adaptee: PayPalAPI.java\r\n* Client: PaymentProcessor.java\r\n\r\n그리고 예시를 위해 추가적인 데이터가 아래와 같이 있다고 가정 한다.\r\n\r\n::code-group\r\n```PayPalPaymentRequest.java\r\n//페이팔 결제 요청정보\r\npublic class PayPalPaymentRequest {\r\n\r\n    private final double amount;\r\n\r\n    public PayPalPaymentRequest(double amount) {\r\n        this.amount = amount;\r\n    }\r\n\r\n    public double getAmount() {\r\n        return amount;\r\n    }\r\n}\r\n```\r\n\r\n```PaypalTransactionId.java\r\n//페이팔 결제 ID\r\npublic class PaypalTransactionId {\r\n\r\n    private final String txId;\r\n\r\n    public PaypalTransactionId(String txId) {\r\n        this.txId = txId;\r\n    }\r\n\r\n    public String getTxId() {\r\n        return txId;\r\n    }\r\n}\r\n```\r\n\r\n```Order.java\r\n//주문 정보\r\npublic class Order {\r\n\r\n    private final double total;\r\n\r\n    public Order(double total) {\r\n        this.total = total;\r\n    }\r\n\r\n    public double getTotal() {\r\n        return total;\r\n    }\r\n}\r\n```\r\n::\r\n\r\n위 정보를 조합하면 각 클래스간 역할 및 관계는 다음과 같다.\r\n\r\n```mermaid\r\n---\r\ntitle: 새로운 페이팔 결제수단에 대해 대응 가능한 어댑터 패턴\r\nconfig:\r\n    class:\r\n        hideEmptyMembersBox: true\r\n---\r\nclassDiagram\r\n    class Payment {\r\n        +processPayment(double amount): void\r\n        +checkStatus(String paymentId): PaymentStatus\r\n    }\r\n    class LegacyPayment {\r\n        +processPayment(double amount): void\r\n        +checkStatus(String paymentId): PaymentStatus\r\n    }\r\n    class PayPalAPI {\r\n        +makePayment(PayPalPaymentRequest request): void\r\n        +getPaymentStatus(PaypalTransactionId txId): PayPalPaymentStatus\r\n    }\r\n    class PaypalAdapter {\r\n        -payPalAPI: PayPalAPI\r\n        +processPayment(double amount): void\r\n        +checkStatus(String paymentId): PaymentStatus\r\n    }\r\n    class PaymentProcessor {\r\n        +process(Order order): void\r\n    }\r\n    class PayPalPaymentRequest {\r\n        -amount: double\r\n        +getAmount(): double\r\n    }\r\n    class PaypalTransactionId {\r\n        -value: String\r\n        +getTxId(): String\r\n    }\r\n    class PayPalPaymentStatus {\r\n        SUCCESS\r\n        PENDING\r\n        FAILED\r\n        REFUND_SUCCESS\r\n        CANCELLED\r\n    }\r\n    class PaymentStatus {\r\n        PENDING\r\n        COMPLETED\r\n        FAILED\r\n        REFUNDED\r\n        CANCELLED\r\n    }\r\n    class Order {\r\n        +getTotal(): double\r\n    }\r\n    Payment <|-- PaypalAdapter\r\n    Payment <|-- LegacyPayment\r\n    PaypalAdapter --> PayPalAPI\r\n    PaymentProcessor --> Payment\r\n    PaymentProcessor --> Order\r\n    PayPalAPI --> PayPalPaymentRequest\r\n    PayPalAPI --> PaypalTransactionId\r\n```\r\n\r\nAdapter 패턴의 사용으로 새로운 결제수단이 추가되어도 기존의 결제처리 로직을 변경하지 않고 사용할 수 있다.\r\n* PayPalAdapter는 Payment 인터페이스를 구현하여 내부적으로 PayPalAPI를 사용하며, 기존 결제에 대한 행동에는 변화가 없다.\r\n* Payment 역할을 그대로 수행하며 내부적으로 실제 처리과정만 다를 뿐이다.\r\n\r\n### 사용\r\n\r\n```java\r\nOrder order = new Order(100.0);\r\n\r\nPaymentProcessor processor = LocalDate.now().isBefore(LocalDate.of(2021, 4, 13))\r\n        ? new PaymentProcessor(new LegacyPayment())\r\n        : new PaymentProcessor(new PaypalAdapter(new PayPalAPI()));\r\n\r\nprocessor.process(order);\r\n```\r\n\r\n> 예를들어 `2021-04-13` 부터 PayPal 결제로만 서비스를 제공한다고 가정하면, 위와 같이 사용할 수 있다.\r\n:{ \"type\": \"tip\", \"icon\": \"info\" }\r\n"
  },
  {
    "path": "/docs/algorithm/base64",
    "header": {
      "layout": "wiki",
      "title": "Base64 인코딩",
      "date": 1572945900000,
      "tags": [
        "Algorithm",
        "Encoding",
        "Base64"
      ],
      "summary": "Base64",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "알고리즘"
      ],
      "images": [
        {
          "src": "/post/algorithm/base64/index-table.png",
          "alt": "Base64 테이블"
        },
        {
          "src": "/post/algorithm/base64/encoding.png",
          "alt": "Base64 인코딩"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "Base64란?::what-is-base64",
            "title": "Base64란?",
            "fragment": "what-is-base64",
            "children": []
          },
          {
            "rank": 2,
            "origin": "Base64 변환 방법::how-to-convert",
            "title": "Base64 변환 방법",
            "fragment": "how-to-convert",
            "children": []
          },
          {
            "rank": 2,
            "origin": "사용되는 이유::why-use-base64",
            "title": "사용되는 이유",
            "fragment": "why-use-base64",
            "children": []
          }
        ]
      }
    },
    "description": "",
    "content": "\r\n## Base64란?::what-is-base64\r\n\r\n**Base64**는 이진 데이터를 6비트씩 끊어서 문자로 변환하는 인코딩 방식이다.\r\n60년대 후반에서 70년대 초반, 최초의 이메일 시스템은 7bit ASCII 문자만 전송할 수 있었다. 이는 [SMTP]()(**S**imple **M**ail **T**ransfer **P**rotocol)가 7bit ASCII 기반으로 설계되었기 때문이다.\r\n\r\n하지만 실제 데이터는 대부분 8bit 바이너리 형식이였고, 여기에 실행 파일, 이미지, 비디오 등이 포함 된다. 이 8bit 데이터를 7bit 채널로 전송하기 위한 해결책이 필요했고, \r\n이 문제를 해결하기위해 1987년 PSRG(**P**rivacy and **S**ecurity **R**esearch **G**roup)에서 Base64 인코딩 방식을 제안했다.\r\n\r\nBase64는 3바이트(24bit)의 바이너리 데이터를 4개의 6bit 유닛으로 변환하며, 다음의 특징을 같는다:\r\n* 6비트는 0-63까지의 값을 표현 할 수 있음\r\n* 이 64개의 값을 ASCII 문자로 매핑(A-Z, a-z, 0-9, +, /)\r\n* 패딩이 필요한 경우 `=` 문자를 사용\r\n\r\n## Base64 변환 방법::how-to-convert\r\n\r\n![Base64 테이블](/post/algorithm/base64/index-table.png)\r\n:{ \"align\": \"center\", \"max-width\": \"300px\", \"description\": \"Base64 인덱스 테이블\" }\r\n\r\nBase64는 64진법의 의미를 갖고 있으며 위의 64개의 테이블 데이터로 매핑한다. 원본 데이터를 6비트씩 끊어서 해당 테이블의 인덱스로 변환하며, 부족한 공간은 패딩 문자인 `=`로 채운다.\r\n\r\n![Base64 인코딩](/post/algorithm/base64/encoding.png)\r\n:{ \"align\": \"center\", \"description\": \"Base64 인코딩\" }\r\n\r\n예를 들어 `JPA`, `JP`, `J` 문자열들을 각각 Base64로 인코딩하면 위와 같다. `JPA`는 3바이트 이므로 4개의 6비트로 딱맞게 변환된다.\r\n\r\n반대로 `JP`와 `J`는 3바이트가 아니므로 패딩 문자인 `=`로 채워진다. 이때 비어있는 비트에 대해서 `A` 또는 `=`로 변환 될지는 바이트 범위 내에 있는지에 따라 다르다.\r\n`JP`는 6비트로 쪼개었을때 3번째 그룹이 0으로 채워져있지만, 두번째 바이트 범위내에 있으므로 `A`로 변환된다.\r\n\r\n하지만 `JP`의 4번째 그룹, `J`의 3번째 4번째 그룹은 모두 바이트 범위에 없으므로 패딩 문자인 `=`로 채워진다.\r\n\r\n> 패딩 문자 =는 Base64 인코딩시에만 사용되며, Base64 디코딩시에는 무시된다.\r\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\" }\r\n\r\n## 사용되는 이유::why-use-base64\r\n\r\nBase64는 이진 데이터를 텍스트 데이터로 변한 되어 전송하기 때문에, 시스템간 데이터 손실을 방지하거나 특수 문자나 제어문자 없이 문자만으로 전송이 가능하다.\r\n또한 ASCII 문자만 사용하기 때문에 인코딩 문제에서 자유로워 모든 시스템에서 안전하게 처리가 가능하다.\r\n\r\n데이터가 조금 커지는 단점이 있지만, [RFC4648](https://datatracker.ietf.org/doc/html/rfc4648)에 표준화 되어있고 구현이 간단하기에 많은 프로토콜에서 사용되고 있다."
  },
  {
    "path": "/docs/algorithm/insertion-sort",
    "header": {
      "layout": "post",
      "title": "Insertion Sort (삽입 정렬)",
      "tags": [
        "Java",
        "Algorithm",
        "Sort",
        "Insertion Sort"
      ],
      "date": 1572945900000,
      "thumbnail": "/post/algorithm/insertion-sort/intro.png",
      "current-company": "Computer Academy",
      "current-position": "Student",
      "summary": "삽입 정렬",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "알고리즘"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "소개::intro",
            "title": "소개",
            "fragment": "intro",
            "children": []
          },
          {
            "rank": 2,
            "origin": "설명::how-to-make-insertion-sort",
            "title": "설명",
            "fragment": "how-to-make-insertion-sort",
            "children": []
          },
          {
            "rank": 2,
            "origin": "예제코드::example-code",
            "title": "예제코드",
            "fragment": "example-code",
            "children": []
          }
        ]
      }
    },
    "description": "정렬 방식중 하나인, 삽입 정렬에 대해 알아보자.",
    "content": "\r\n\r\n## 소개::intro\r\n\r\n🌸 삽입정렬은 배열을 순회하며, 삽입할 위치를 찾고 요소들을 **한단계씩 밀어** 해당 위치에 삽입하며 정렬하는 알고리즘 이다.\r\n삽입정렬 또한 선택정렬과 마찬가지로 정렬된 부분과 정렬되지 않은 부분으로 나뉜다.\r\n\r\n> **한단계씩 밀어** 라는 말은 `[ 1 ][ 3 ][ 2 ]` 에서 2라는 요소를 임시로 빼고 1 과 3사이에 들어갈공간을 만들기 위해 뺀 2의 자리로 3을 한 단계밀어,\r\n> `[ 1 ][    ][ 3 ]` 처럼 빈 공간을 만든 다는 의미이다.\r\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\"}\r\n\r\n---\r\n\r\n## 설명::how-to-make-insertion-sort\r\n\r\n순회 인덱스 i: 3 (0, 1, 2는 요소가 1, 4, 7이므로 정렬이되어 있으므로, 넘어간다.)\r\n\r\n[1, 4, `7`, 3, 2, 5] → [1, 4, **3**, `7`, 2, 5]\r\n\r\n> 삽입정렬은 지나온 요소들과 비교하여 밀면서 정렬해 나간다. 위 배열에서 1, 4, 7 요소는 정렬 되있기 때문에,\r\n> `j`는 (j = i - 1, 현재 3) 0이 될때까지 계속 순회하며 이전값과 비교하여 정렬 대상인지 아닌지를 판단한다.\r\n:{ \"type\": \"note\", \"icon\": \"info\"}\r\n\r\n순회 인덱스 i: 3\r\n\r\n> 한번의 정렬이 끝났으니 `j`를 감소시켜 또다시 이전 요소 (3과 4)를 비교하여 정렬대상이 되었다.\r\n> i는 현재 3이지만 `i` 이전의 인덱스를 가진 요소들은 정렬되지 않았기 때문에 `j`를 감소시켜가며 끝까지 정렬한다.\r\n:{ \"type\": \"note\", \"icon\": \"info\"}\r\n\r\n* 순회 인덱스 i: 3\r\n* 내부 순회 인덱스 j: 2 → 내부 순회 인덱스 j: 1\r\n\r\n[1, `4`, 3, 7, 2, 5] → [1, **3**, `4`, 7, 2, 5]\r\n\r\n> 내부 순회 인덱스를 줄여가며 정렬을 하였고 현재 내부 순회 인덱스(`j`)인 1에대한 요소(3)가 비교할 인덱스 0에대한 요소(1)과 정렬되어있다고 판단 하기에,\r\n> j는 더이상 감소시키지 않는다. 따라서 `i`를 다시 증가시키며 이과정을 반복하여 정렬한다.\r\n> 이후의 과정은 아래와 같다.\r\n:{ \"type\": \"note\", \"icon\": \"info\"}\r\n\r\n* 순회 인덱스 i: 4\r\n* 내부 순회 인덱스 j: 3 (i - 1)\r\n\r\n[1, 3, 4, `7`, **2**, 5] -> [1, 3, 4, **2**, `7`, 5]  \r\n\r\n* 순회 인덱스 i: 4\r\n* 내부 순회 인덱스 j: 2 (j--)\r\n\r\n[1, 3, `4`, **2**, 7, 5] -> [1, 3, **2**, `4`, 7, 5]\r\n\r\n* 순회 인덱스 i: 4\r\n* 내부 순회 인덱스 j: 1 (j--)\r\n\r\n[1, `3`, **2**, 4, 7, 5] -> [1, **2**, `3`, 4, 7, 5]  \r\n\r\n* 순회 인덱스 i: 5\r\n* 내부 순회 인덱스 j: 4 (j - 1)\r\n\r\n[1, 2, 3, 4, `7`, **5**] -> [1, 2, 3, 4, **5**, `7`]  \r\n\r\n* 정렬 결과\r\n\r\n[1, 2, 3, 4, 5, 7]\r\n\r\n> 모든 정렬을 수행했으므로 정렬이 완료되었다.\r\n:{ \"type\": \"tip\", \"icon\": \"check-circle\"}\r\n\r\n## 예제코드::example-code\r\n\r\n* 예제코드는 생각 보다 단순하다. 아래와 같이 배열을 순회하는 i가 있고, `array[1..i]`에서 정렬을 하는 방식이다.\r\n\r\n```java::InsertionSort.java\r\npublic class InsertionSort {\r\n    \r\n    public static void sort(int [] array) {\r\n\r\n        for (int i = 1; i < array.length; i++) {\r\n            int current = array[i];\r\n            int j = i - 1;\r\n\r\n            while(array[j + 1] < array[j]) {\r\n                array[j + 1] = array[j];\r\n                array[j--] = current;\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n"
  },
  {
    "path": "/docs/software-design/class-diagram",
    "header": {
      "layout": "post",
      "title": "클래스 다이어그램",
      "tags": [
        "UML",
        "Class Diagram"
      ],
      "date": 1571376300000,
      "thumbnail": "/post/software-design/uml/class-diagram-intro.png",
      "profile-image": "/post/profile/profile0.jpg",
      "current-company": "Computer Academy",
      "current-position": "Student",
      "summary": "클래스 다이어그램",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "소프트웨어 설계"
      ],
      "images": [
        {
          "src": "/post/software-design/uml/relationship-line.png",
          "alt": "클래스 다이어그램의 관계 선"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "관계를 나타내는 화살표::relationship-line",
            "title": "관계를 나타내는 화살표",
            "fragment": "relationship-line",
            "children": [
              {
                "rank": 3,
                "origin": "Associations (연관)::associations",
                "title": "Associations (연관)",
                "fragment": "associations",
                "children": []
              },
              {
                "rank": 3,
                "origin": "Inheritances (상속)::inheritances",
                "title": "Inheritances (상속)",
                "fragment": "inheritances",
                "children": []
              },
              {
                "rank": 3,
                "origin": "Realizations (실체화)::realizations",
                "title": "Realizations (실체화)",
                "fragment": "realizations",
                "children": []
              },
              {
                "rank": 3,
                "origin": "Dependencies (의존)::dependencies",
                "title": "Dependencies (의존)",
                "fragment": "dependencies",
                "children": []
              },
              {
                "rank": 3,
                "origin": "Aggregations (집합)::aggregations",
                "title": "Aggregations (집합)",
                "fragment": "aggregations",
                "children": []
              },
              {
                "rank": 3,
                "origin": "Compositions (합성)::compositions",
                "title": "Compositions (합성)",
                "fragment": "compositions",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "소프트 웨어에서는 각 객체와 객체 간의 관계를 표현하기 위해 클래스 다이어그램을 사용한다. \r\n\r\n클래스 다이어그램은 클래스의 속성과 메서드를 표현하고, 클래스 간의 관계를 표현한다. \r\n클래스 다이어그램은 객체 지향 프로그래밍에서 가장 많이 사용되는 다이어그램 중 하나이다.\r\n\r\n클래스 다이어그램의 구성요소를 알아보자.",
    "content": "\r\n\r\n## 관계를 나타내는 화살표::relationship-line\r\n\r\n![클래스 다이어그램의 관계 선](/post/software-design/uml/relationship-line.png)\r\n:{ \"align\": \"center\", \"max-width\": \"400px\", \"description\": \"클래스간의 관계를 나타내는 Relationship Line\" }\r\n\r\n클래스 다이어그램에서는 클래스간 관계를 나타내는 화살표를 사용한다.\r\n각 관계를 나타내는 의미를 알아보자.\r\n\r\n### Associations (연관)::associations\r\n\r\n*한 모델 요소의 인스턴스들이 다른 모델 요소의 인스턴스들과 연결되었다는 것을 나타낸다.*\r\n\r\n**단방향 연관 관계**\r\n\r\n```mermaid\r\nclassDiagram\r\n    direction LR\r\n    class Student {\r\n        -name: String\r\n    }\r\n    class Teacher {\r\n        -name: String\r\n        -children: List~Student~\r\n        +check(Student student): void\r\n    }\r\n    Teacher --> Student\r\n```\r\n\r\n\r\n이 다이어 그램은 학생과 선생님의 관계를 나타낸다. 선생님은 학생들을 관리하기 위해 항상 참조한다.\r\n하지만, 학생은 선생님이 관심 없기 때문에 신경을 안쓰므로 학생은 선생님을 참조하지 않는다.\r\n이는 단방향 관계이다.\r\n\r\n**양방향 연관관계**\r\n\r\n```mermaid\r\nclassDiagram\r\n    direction LR\r\n    class Child {\r\n        -name: String\r\n        -parent: Parent\r\n    }\r\n    class Parent {\r\n        -name: String\r\n        -child: Child\r\n    }\r\n    Child <--> Parent\r\n```\r\n\r\n하지만 반대로 자식과 부모의 관계는 양방향 관계이다. 부모는 자식과, 자식은 부모와 가족이기 때문에 서로를 참조한다.\r\n\r\n> 이처럼 단방향 또는 양방향으로 어떤 모델의 인스턴스를 참조하는 관계를 `연관관계`라고 한다.\r\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\" }\r\n\r\n> 연관 관계는 참조하려는 객체를 내부적으로 갖고 있어야한다.\r\n:{ \"type\": \"note\", \"icon\": \"info\" }\r\n\r\n\r\n### Inheritances (상속)::inheritances\r\n\r\n*한 클래스가 다른 클래스의 특성을 상속받았다는 것을 나타낸다.*\r\n\r\n이는 구현과는 다르며, 상속은 클래스 간의 관계를 나타낸다.\r\n\r\n```mermaid\r\nclassDiagram\r\n    direction LR\r\n    class Animal {\r\n        <<abstract>>\r\n        -name: String\r\n        +eat(): void\r\n    }\r\n    class Dog {\r\n        -legs: int\r\n        +bark(): void\r\n    }\r\n    class BorderCollie {\r\n        -intelligence: int\r\n    }\r\n    Animal <|-- Dog\r\n    Dog <|-- BorderCollie\r\n```\r\n\r\n이 다이어그램은 `Animal` 클래스가 `Dog` 클래스에 상속되고, `Dog` 클래스가 `BorderCollie` 클래스에 상속되는 상속 관계를 나타낸다.\r\n\r\n> 상속은 `interface`가 아닌 `Abstract Class` 또는 일반 `Class` 에서만 사용할 수 있다.\r\n:{ \"type\": \"note\", \"icon\": \"info\" }\r\n\r\n\r\n### Realizations (실체화)::realizations\r\n\r\n*한 클래스가 인터페이스를 구현했다는 것을 나타낸다.*\r\n\r\n다른말로 `implementation` 이라고도 한다. 즉 구현하여 실체화하는 경우를 의미한다.\r\n\r\n```mermaid\r\nclassDiagram\r\n    class Mammal {\r\n        <<interface>>\r\n        +breastfeed(): void\r\n    }\r\n    class Dog {\r\n        +breastfeed(): void\r\n    }\r\n    class Human {\r\n        +breastfeed(): void\r\n    }\r\n    Mammal <|.. Dog\r\n    Mammal <|.. Human\r\n```\r\n\r\n포유류는 젖을 먹여 새끼를 키우는 동물을 일컷는 말이다. 포유류는 분류를 하기 위해 나눈 개념이기 때문에 실체가 아니다.\r\n이를 실체화 하기위해 `Dog`와 `Human` 클래스가 `Mammal` 인터페이스를 구현하고 있다.\r\n\r\n> `Realization`/`Implementation` 관계는 `interface`를 구현하는 클래스에 사용된다.\r\n:{ \"type\": \"note\", \"icon\": \"info\" }\r\n\r\n\r\n### Dependencies (의존)::dependencies\r\n\r\n*한 클래스가 다른 클래스에 의존하는것을 의미한다.*\r\n\r\n```mermaid\r\nclassDiagram\r\n    direction LR\r\n    class A {\r\n        +use(B b): void\r\n    }\r\n    class B {\r\n        +doSomeThing(): void\r\n    }\r\n    A ..> B\r\n```\r\n\r\n> 어떤 행위를 할 때 다른 클래스를 필요로 하는 경우 `의존`관계에 해당된다.\r\n:{ \"type\": \"note\", \"icon\": \"info\" }\r\n\r\n### Aggregations (집합)::aggregations\r\n\r\n*한 클래스가 다른 클래스를 소유하고 있다는 것을 나타낸다.*\r\n\r\n> `집합` 관계는 `연관` 관계와 유사하지만, 의미론적으로 다르다.\r\n:{ \"type\": \"important\", \"icon\": \"warning-octagon\" }\r\n\r\n\r\n```mermaid\r\nclassDiagram\r\n    direction LR\r\n    class Professor {\r\n        -name: String\r\n    }\r\n    class Department {\r\n        -professors: ~List~ Professor\r\n    }\r\n    Department o-- Professor\r\n```\r\n\r\n만약 교수가 학과에 속해있다면, 이러한 관계를 `집합` 관계라고 한다. **필드로 갖고 있다는 개념이 비슷하지만,** \r\n연관 관계에서는 **참조**를 의미하고 집합 관계에서는 **소유**를 의미한다.\r\n\r\n\r\n### Compositions (합성)::compositions\r\n\r\n*한 클래스가 다른 클래스에 종속하고 있다는 것을 나타낸다.*\r\n\r\n> `합성` 관계는 `집합` 관계와 유사하지만, 의미론적으로 다르다. **Aggregation**은 독립적 이지만, **Composition**은 종속적이다.\r\n:{ \"type\": \"important\", \"icon\": \"warning-octagon\" }\r\n\r\n```mermaid\r\nclassDiagram\r\n   Human *-- Heart\r\n   Human *-- Brain\r\n   Human *-- Organ\r\n\r\n   class Human {\r\n       -Heart heart\r\n       -Brain brain\r\n       -List~Organ~ organs\r\n       +Human()\r\n   }\r\n   class Heart {\r\n   }\r\n   class Brain {\r\n   }\r\n   class Organ {\r\n   }\r\n```\r\n\r\n만약 사람이 심장, 뇌, 장기를 가지고 있다면, 각각의 구성요소는 사람에 종속적이다. 이러한 종속들의 집합을 `합성` 관계라고 한다.\r\n또한 집합 관계에선 참조되는 필들에게 일부 작업을 위임한다. \r\n\r\n> 집합 관계/합성은 많은 디자인패턴의 핵심 원칙이다.\r\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\" }\r\n\r\n> **공유 불가능**: `합성` 관계에서는 한 객체의 부분이 다른객체에 속할 수 없고, 부분 객체가 여러 객체에 동시에 속할 수 없다. 또한 부분 객체의 독립적인 재사용이 불가능하다.\r\n:{ \"type\": \"caution\", \"icon\": \"x-circle\" }\r\n"
  },
  {
    "path": "/docs/data-structure/hash",
    "header": {
      "layout": "post",
      "title": "해시 (Hash)",
      "tags": [
        "Data Structure",
        "Hash"
      ],
      "date": 1570217400000,
      "profile-image": "/post/profile/profile0.jpg",
      "thumbnail": "/post/data-structure/hash/index.png",
      "current-company": "Computer Academy",
      "current-position": "Student",
      "summary": "해시",
      "expose-images": true,
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "자료구조"
      ],
      "images": [
        {
          "src": "/post/data-structure/hash/hash-index.png",
          "alt": "해시 인덱스"
        },
        {
          "src": "/post/data-structure/hash/hash-collision.png",
          "alt": "해시 충돌"
        },
        {
          "src": "/post/data-structure/hash/hash-chaining.png",
          "alt": "체이닝"
        },
        {
          "src": "/post/data-structure/hash/hash-linear-probing.png",
          "alt": "선형 탐사"
        },
        {
          "src": "/post/data-structure/hash/hash-quadratic-probing.png",
          "alt": "제곱 탐사"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "해시란?::what-is-hash",
            "title": "해시란?",
            "fragment": "what-is-hash",
            "children": []
          },
          {
            "rank": 2,
            "origin": "해시 충돌::hash-collision",
            "title": "해시 충돌",
            "fragment": "hash-collision",
            "children": []
          },
          {
            "rank": 2,
            "origin": "해시 충돌 해결 방법::how-to-solve-hash-collision",
            "title": "해시 충돌 해결 방법",
            "fragment": "how-to-solve-hash-collision",
            "children": [
              {
                "rank": 3,
                "origin": "1. 체이닝::chaining",
                "title": "1. 체이닝",
                "fragment": "chaining",
                "children": []
              },
              {
                "rank": 3,
                "origin": "2. 개방 주소법::open-addressing",
                "title": "2. 개방 주소법",
                "fragment": "open-addressing",
                "children": []
              }
            ]
          }
        ]
      }
    },
    "description": "hash는 프랑스어 hacher [aʃe]: 썰다/다지다 에서 유래한 단어로, 잘게 다져서 요리하는 음식을 말한다.  \r\n\r\n컴퓨터 과학에서는 잘게 다진 데이터를 저장한다는 의미로 hash라는 용어를 사용한다.",
    "content": "\r\n\r\n## 해시란?::what-is-hash\r\n\r\n[hash](https://en.wikipedia.org/wiki/Hash_(food))는 프랑스어 hacher [aʃe]: 썰다/다지다 에서 유래한 단어로, 잘게 다져서 요리하는 음식을 말한다. \r\n대표적인 예로 감자를 잘게 다져서 튀김으로 만드는 해시 브라운이 있다. 이러한 문맥으로 컴퓨터 과학에서 잘게 다져 저장하는 의미로 hash라는 용어를 사용한다.\r\n\r\n`hash`에서는 빠질 수 없는 `Hash Function`이 있는데, 이는 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수이다.  \r\n예를 들어 Java의 경우 아래와 같은 해시함수가 존재한다.\r\n\r\n```java::자바의 해시함수\r\nstatic final int hash(Object key) {\r\n    int h;\r\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\r\n}\r\n```\r\n\r\nJava의 내용은 관련이 없지만 설명을 위해 hashCode도 같이 보는것이 좋다.  \r\n먼저 `hashCode`를 얻는 방법은 아래와 같다. `UTF-16`의 경우 `Latin-1`의 상위 집합이지만, 한글과 같은 문자 때문에 필요하고 2byte 처리로 `hashCode`를 만든다. \r\n\r\n::code-group\r\n```java::Latin-1\r\npublic static int hashCode(byte[] value) {\r\n    int h = 0;\r\n    for (byte v : value) {\r\n        h = 31 * h + (v & 0xff);\r\n    }\r\n    return h;\r\n}\r\n```\r\n```java::UTF-16\r\npublic static int hashCode(byte[] value) {\r\n    int h = 0;\r\n    int length = value.length >> 1;\r\n    for (int i = 0; i < length; i++) {\r\n        h = 31 * h + getChar(value, i);\r\n    }\r\n    return h;\r\n}\r\n```\r\n::\r\n아무튼 일반적으로 `😂`이나 `앨리스`와 같은 값으로 해싱을 하지는 않으니, 대부분 `Latin-1`을 사용한다는 가정하에 설명한다.  \r\n여기서 \"Alice\"라는 문자열과 \"Bob\"이라는 문자열이 입력으로 들어온다면 다음의 과정으로 해시값을 얻을 수 있다.\r\n\r\n::code-group\r\n```text::\"Alice\"의 해시코드\r\n1. 'A' (처음)\r\nh = 31 * 0 + 65 = 65\r\n\r\n2. 'l' (두번째)\r\nh = 31 * 65 + 108\r\nh = 2015 + 108 = 2123\r\n\r\n3. 'i' (세번째)\r\nh = 31 * 2123 + 105\r\nh = 65813 + 105 = 65918\r\n\r\n4. 'c' (네번째)\r\nh = 31 * 65918 + 99\r\nh = 2043458 + 99 = 2043557\r\n\r\n5. 'e' (마지막)\r\nh = 31 * 2043557 + 101\r\nh = 63350267 + 101 = 63350368\r\n```\r\n```text::\"Bob\"의 해시코드\r\n1. 'B' (처음)\r\nh = 31 * 0 + 66 = 66\r\n\r\n2. 'o' (두번째)\r\nh = 31 * 66 + 111\r\nh = 2046 + 111 = 2157\r\n\r\n3. 'b' (마지막)\r\nh = 31 * 2157 + 98\r\nh = 66867 + 98 = 66965\r\n```\r\n::\r\n\r\n결과적으로 `63350368`과 `66965`라는 해시코드가 나온다. 이 값으로 hash function을 돌리면 아래처럼 처리된다.\r\n\r\n::code-group\r\n```text::\"Alice\": hash(63350368)\r\n1) hashCode를 2진수로 변환\r\n63350182 = 0000 0011 1110 0011 0110 1011 1000 0110\r\n\r\n2) h >>> 16 (상위 16비트를 하위 16비트로)\r\n0000 0000 0000 0000 0000 0011 1110 0011\r\n\r\n3) XOR 연산 (^)\r\n0000 0011 1110 0011 0110 1011 1000 0110  (원래 해시코드)\r\n0000 0000 0000 0000 0000 0011 1110 0011  (>>> 16한 값)\r\n----------------------------------------\r\n0000 0011 1110 0011 0110 1000 0110 0101  (최종 해시값) 66063397 (십진수)\r\n```\r\n```text::\"Bob\": hash(66965)\r\n1) hashCode를 2진수로 변환\r\n66965 = 0000 0000 0000 0001 0000 0101 1000 0101\r\n\r\n2) h >>> 16 (상위 16비트를 하위 16비트로)\r\n0000 0000 0000 0000 0000 0000 0000 0001\r\n\r\n3) XOR 연산 (^)\r\n0000 0000 0000 0001 0000 0101 1000 0101  (원래 해시코드)\r\n0000 0000 0000 0000 0000 0000 0000 0001  (>>> 16한 값)\r\n----------------------------------------\r\n0000 0000 0000 0001 0000 0101 1000 0100  (최종 해시값) 66964 (십진수)\r\n```\r\n::\r\n\r\n최종적으로 `Alice`는 `66063523`, `Bob`은 `66964`라는 해시값을 얻을 수 있다.\r\n이렇게 얻어진 해시값을 통해 데이터를 저장하거나 검색할 수 있다.\r\n\r\n> Hash 값은 데이터를 저장하거나 검색하기 위해 사용되는 인덱스를 만들 수 있다.\r\n:{ \"type\": \"tip\", \"icon\": \"check-circle\" }\r\n\r\n## 해시 충돌::hash-collision\r\n\r\n`Java` 에서는 `hash` 값으로 테이블 인덱스를 구할 때 `(n - 1) & hash`로 만든다.\r\n`n`은 테이블의 크기이며 초기값은 16(`1 << 4`)이다. `Alice`라는 문자열로 인덱스를 계산하면 아래와 같다.\r\n\r\n::code-group\r\n```text::\"Alice\"의 해시 인덱스\r\n0000 0000 0000 0000 0000 0000 0000 1111 (n - 1 = 15)\r\n0000 0011 1111 1010 1011 0101 0000 0101 (hash: 66063397\r\n----------------------------------------\r\n0000 0000 0000 0000 0000 0000 0000 0101 (최종 인덱스: 5)\r\n```\r\n```text::\"Bob\"의 해시 인덱스\r\n0000 0000 0000 0000 0000 0000 0000 1111 (n - 1 = 15)\r\n0000 0000 0000 0001 0000 0101 1000 0100 (hash: 66964)\r\n----------------------------------------\r\n0000 0000 0000 0000 0000 0000 0000 0100 (최종 인덱스: 4)\r\n```\r\n::\r\n\r\n![해시 인덱스](/post/data-structure/hash/hash-index.png)\r\n:{ \"align\": \"center\", \"max-width\": \"400px\", \"description\": \"Alice와 Bob의 해시 인덱스\" }\r\n\r\n이렇게 계산된 인덱스는 현재 테이블의 크기와 해시값에 따라 생성되므로 예측하기 어려우며, 간혹 같은 인덱스를 생성하는 경우가 발생하는데, 이를 **해시 충돌**이라고 한다.\r\n\r\n![해시 충돌](/post/data-structure/hash/hash-collision.png)\r\n:{ \"description\": \"해시 충돌\" }\r\n\r\n**해시 충돌**은 해시들이 어떤 계산된 값에 의해 생성된 테이블 인덱스가 같은 경우를 말한다.\r\n해시 값이 다르더라도, 가리키는 테이블 인덱스가 같은 경우 이미 다름값이 저장이 되어있기 때문에, 충돌이 발생한다.\r\n\r\n이런 충돌 문제를 해결하기 위해 여러가지 방법들이 고안 되었다.\r\n\r\n## 해시 충돌 해결 방법::how-to-solve-hash-collision\r\n\r\n### 1. 체이닝::chaining\r\n\r\n![체이닝](/post/data-structure/hash/hash-chaining.png)\r\n:{ \"description\": \"노드를 연결 리스트로 묶는 체이닝\" }\r\n\r\n**체이닝**은 해시 충돌이 발생하면, 같은 테이블에 [연결 리스트](/docs/data-structure/linked-list)로 연결하는 방식이다.\r\n\r\n해시 충돌이 자주 발생 하는것은 아니지만, 종종 발생한다. 이렇게 해시 충돌이 발생하면 해당 인덱스로 연결된 연결 리스트에서 데이터를 찾아야 한다.\r\n같은 해시 인덱스에 대해 데이터가 저장된곳을 `버킷(Bucket)`이라고 하는데, 이 버킷에는 데이터가 많아질수록 성능이 저하된다.\r\n\r\n`Java`의 경우 체이닝 방식을 쓰지만, 버킷의 성능을 개선하기 위해 8(`threshold`)개 까지는 선형 탐색을 하지만, \r\n그 이상은 트리(`Red Black`) 구조로 변경하여 이진 탐색으로 성능을 향상시키며 개수가 줄어들면 다시 연결 리스트로 바꿔 선형 탐색을 한다.\r\n\r\n> `Java` 이외에도 `C++`, `C#`등 다양한 언어에서도 체이닝 방식을 사용한다.\r\n:{ \"type\": \"tip\", \"icon\": \"check-circle\" }\r\n\r\n### 2. 개방 주소법::open-addressing\r\n\r\n개방 주소법은 해시 충돌이 발생할 때, 비어있는 다른 버킷을 찾아 데이터를 저장하는 방식이다.\r\n여기서 **비어있는 다른 주소**에 대해 접근하는 것이기 때문에 `개방 주소법`이라고 하며 이 주소를 찾는 것을, `탐사(probing)`이라고 한다.\r\n\r\n개방 주소법은 [체이닝](#chaining)과 다르게, 버킷에 한개의 정보만 저장할수 있다.\r\n따라서 버킷이 차게 되면, 다른 버킷을 찾아 저장해야 한다. 이때 버킷은 현재 해시 인덱스와 관련이 없는 다른 버킷을 찾게된다.\r\n\r\n개방 주소법에는 세가지 방법이 있다.\r\n\r\n#### 2-1. 선형 탐사\r\n\r\n![선형 탐사](/post/data-structure/hash/hash-linear-probing.png)\r\n:{ \"align\": \"center\", \"max-width\": \"400px\", \"description\": \"선형 탐사로 새로운 정보를 테이블에 추가\" }\r\n\r\n첫 번째로 **선형 탐사**는 해시로 계산된 인덱스가 이미 사용중이라면, 다음 인덱스로 이동하여 저장하는 방식이다.\r\n이러한 방식은 지속적으로 다음 버킷을 찾기 때문에, 실제 해당 인덱스에 연결되어야 하는 데이터가 또 다른 버킷을 탐사해야하므로 한곳에 데이터가 모이게 된다.\r\n\r\n이렇게 데이터가 모이는 현상을 군집화(`clustering`)라고 하며, \r\n해시충돌로 다음 버킷을 계속 찾아다니는 선형 탐사는 군집화가 발생할 가능성이 높다.\r\n\r\n#### 2-2. 제곱 탐사 (이차 탐사)\r\n\r\n![제곱 탐사](/post/data-structure/hash/hash-quadratic-probing.png)\r\n:{ \"align\": \"center\", \"max-width\": \"250px\", \"description\": \"제곱 탐사로 새로운 정보를 테이블에 추가\" }\r\n\r\n두 번째로 **제곱 탐사**는 `선형 탐사`의 군집화를 보완하기 위해 나온 기법이다.\r\n이 기법은 **N + M^2^**(`N: 원본 인덱스`, `M: 탐색 차수`)로 다음 버킷을 찾는다. \r\n\r\n예를 들어 다음과 위 이미지와 같이 계산된 인덱스가 5인 경우, 5번 버킷에는 이미 데이터가 있기 때문에 첫번째 탐사 인덱스로 (**5 + 1^2^** = 6)으로 이동한다.\r\n\r\n지속적으로 버킷이 사용중이라면 아래처럼 인덱스가 계산된다.\r\n\r\n1. 5 + 1^2^ = 6\r\n2. 5 + 2^2^ = 9\r\n3. 5 + 3^2^ = 14\r\n4. 5 + 4^2^ = 21\r\n\r\n이러한 제곱탐사는 선형탐사보다는 군집화가 적게 발생하지만, 여전히 군집화가 발생할 수 있다.\r\n\r\n#### 2-3. 이중 해싱\r\n\r\n세 번째로 **이중 해싱**은 해싱 인덱스를 구하는 해시 함수에서 두번의 해싱으로 연산한다.\r\n앞서 `해시 함수`는 해시 값을 구하는 함수라고 설명하였지만, 여기서는 해시 인덱스를 구하는 함수도 `해시 함수`라고 칭할 수 있다.\r\n\r\n이중 해싱에서 해시 함수는 다음과 같다.\r\n\r\n전체 해시 함수: **h(k, i) = (h~1~(k) + i * h~2~(k)) % m**\r\n* h~1~(k) = k % m\r\n* h~2~(k) = PRIME - (k % PRIME)\r\n\r\n> k: 키값, i: 충돌 횟수 (0, 1, 2, ...), m: 테이블 크기, PRIME: 소수\r\n:{ \"type\": \"tip\", \"icon\": \"check-circle\" }\r\n\r\n> `PRIME`은  h~2~(k)가 0이 되는 것을 방지하고, 모든 버킷을 골고루 방문하기 위해 사용한다.\r\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\" }\r\n\r\n예를 들어 키값(해시 값)이 `14`, 테이블의 크기가 `13` 그리고 `PRIME`이 7이라고 가정한다면 아래와 같은 과정으로 인덱스를 구할 수 있다.\r\n\r\n```text\r\nh~1~(14) = 14 % 13 = 1\r\nh~2~(14) = 7 - (14 % 7) = 7 - 0 = 7\r\n\r\n// h(14, i) = (h~1~(14) + i * h~2~(14)) % 13\r\ni=0: (1 + 0 * 7) % 13 = 1 //첫 번째 위치\r\ni=1: (1 + 1 * 7) % 13 = 8 //두 번째 위치\r\ni=2: (1 + 2 * 7) % 13 = 2 //세 번째 위치\r\n```\r\n이런 식으로 테이블 크기에 맞게 적절한 분포를 할수 있다. 하지만, 이중 해싱은 선형 탐사나 제곱 탐사보다는 성능이 좋지만, PRIME을 찾는 것이 어렵다.\r\n만약 키값(해시 값)이 `23`, 테이블의 크기가 `10` 그리고 `PRIME`이 7이라고 가정한다면 아래와 같은 과정으로 순환이 발생한다.\r\n\r\n```text\r\nh₁(23) = 23 % 10 = 3\r\nh₂(23) = 7 - (23 % 7) = 7 - 2 = 5\r\n\r\n// h(23, i) = (h₁(23) + i * h₂(23)) % 10 \r\ni=0: (3 + 0 * 5) % 10 = 3 //첫 번째 위치\r\ni=1: (3 + 1 * 5) % 10 = 8 //두 번째 위치\r\ni=2: (3 + 2 * 5) % 10 = 3 //세 번째 위치\r\n```\r\n\r\n`3`과 `8`인덱스에 대해 순환이 발생하며, 올바른 처리를 하지못한다. 이중해싱은 균등분포에 가장 적합하지만,\r\n이중 해싱은 항상 두번의 해싱이 필요하며, 적절한 PRIME을 찾는 것이 어렵기 떄문에 **선현 탐사**나 **제곱 탐사**보다는 자주 사용되지 않는다.\r\n\r\n> 이외에도 해시충돌 해결 방법은 `로빈 후드 해싱`, `분리 연결법`, `동적 해시`등이 있다.\r\n:{ \"type\": \"note\", \"icon\": \"info\" }\r\n"
  },
  {
    "path": "/docs/data-structure/queue",
    "header": {
      "layout": "post",
      "title": "큐 (Queue)",
      "tags": [
        "Data Structure",
        "Queue"
      ],
      "date": 1570217400000,
      "profile-image": "/post/profile/profile0.jpg",
      "thumbnail": "/post/data-structure/queue/index.png",
      "current-company": "Computer Academy",
      "current-position": "Student",
      "summary": "큐",
      "expose-images": true,
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "자료구조"
      ],
      "images": [
        {
          "src": "/post/data-structure/queue/index.png",
          "alt": "큐"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "큐란?::what-is-queue",
            "title": "큐란?",
            "fragment": "what-is-queue",
            "children": []
          },
          {
            "rank": 2,
            "origin": "큐의 필수기능 구현::core-operations",
            "title": "큐의 필수기능 구현",
            "fragment": "core-operations",
            "children": []
          },
          {
            "rank": 2,
            "origin": "큐의 구현::implementation",
            "title": "큐의 구현",
            "fragment": "implementation",
            "children": []
          }
        ]
      }
    },
    "description": "Queue는 무엇인가 기다리는 행렬을 의미한다.  \r\n선입선출(FIFO, First In First Out)로 데이터를 관리하는 Queue를 알아보자.",
    "content": "\r\n\r\n## 큐란?::what-is-queue\r\n\r\n![큐](/post/data-structure/queue/index.png)\r\n:{ \"description\": \"큐의 enqueue 와 dequeue\" }\r\n\r\n**Queue** 자료구조는 [배열](/docs/data-structure/array)로도 구현할 수 있고, [연결 리스트](/docs/data-structure/linked-list)로도 간단하게 구현할 수 있다.\r\n위 이미지와 같이 `Queue`는 먼저 들어온 요소가 먼저 나올 수 있는 선입선출(FIFO, First In First Out)의 자료구조이다.\r\n\r\n`Queue`에는 값을 넣을수 있는 `enqueue`와 값을 꺼낼 수 있는 `dequeue`를 구현한다.\r\n\r\n이는 대략적으로 아래와 같은 구조를 가진다.\r\n\r\n```text\r\n//노드\r\nclass Node<T> is\r\n    T data\r\n    Node<T> next\r\n    \r\n//연결 리스트\r\nclass Queue<T> is\r\n    Node<T> front\r\n    Node<T> rear\r\n    int size\r\n    \r\n    method is_empty(): boolean\r\n    method peek(): T\r\n    method enqueue(T item)\r\n    method dequeue(): T\r\n```\r\n\r\n\r\n## 큐의 필수기능 구현::core-operations\r\n\r\n* 값 추가 (enqueue)\r\n\r\n```text\r\nmethod enqueue(T item) is\r\n    Node<T> newNode = new Node<>(item)\r\n    if is_empty() then\r\n        front = newNode // 큐가 비어있다면 새로운 노드로 front를 설정\r\n    else\r\n        rear.next = newNode //요소가 있다면, rear의 다음 노드로 설정\r\n    rear = newNode\r\n    size++\r\n```\r\n\r\n* 값 제거 (dequeue)\r\n\r\n```text\r\nmethod dequeue(): T is\r\n    if is_empty() then\r\n        throw EmptyQueueException\r\n    T item = front.data // front의 데이터를 가져온다.\r\n    front = front.next // front를 다음 노드로 설정\r\n    \r\n    // front가 null이면 rear도 null로 설정\r\n    if (front == null) then\r\n        rear = null\r\n    \r\n    size--\r\n    return item\r\n```\r\n\r\n* 공백 확인 (is_empty)\r\n\r\n```text\r\nmethod is_empty(): boolean is\r\n    return size == 0\r\n```\r\n\r\n* 값 확인 (peek)\r\n\r\n```text\r\nmethod peek(): T is\r\n    if is_empty() then\r\n        throw EmptyQueueException\r\n    return front.data\r\n```\r\n\r\n## 큐의 구현::implementation\r\n\r\n::code-group\r\n```cpp::c++\r\nusing namespace std;\r\n\r\ntemplate <typename T>\r\nclass Queue {\r\nprivate:\r\n    struct Node {\r\n        T data;\r\n        Node *next;\r\n        explicit Node(const T &data): data(data), next(nullptr) {}\r\n    };  \r\n    Node *front;\r\n    Node *rear;\r\n    size_t size;\r\n\r\npublic:\r\n    Queue(): front(nullptr), rear(nullptr), size(0) {}\r\n    ~Queue() {\r\n        while (!is_empty()) {\r\n            dequeue();\r\n        }\r\n    }\r\n    bool is_empty() const {\r\n        return size == 0;\r\n    }\r\n    void enqueue(T data) {\r\n        Node *newNode = new Node(data);\r\n        if (is_empty()) {\r\n            front = newNode;\r\n        } else {\r\n            rear->next = newNode;\r\n        }\r\n        rear = newNode;\r\n        size++;\r\n    }\r\n    T dequeue() {\r\n        if (is_empty()) throw underflow_error(\"Queue is empty!\");\r\n        Node* temp = front;\r\n        front = front->next;\r\n        T data = temp->data;\r\n        delete temp;\r\n\r\n        if (front == nullptr) rear = nullptr;\r\n\r\n        size--;\r\n        return data;\r\n    }\r\n    T peek() const {\r\n        if (is_empty()) throw underflow_error(\"Queue is empty!\");\r\n        return front->data;\r\n    }\r\n    friend ostream& operator<<(ostream& os, const Queue& q) {\r\n        os << \"[\";\r\n        Node* temp = q.front;\r\n        while (temp != nullptr) {\r\n            os << temp->data;\r\n            if (temp->next != nullptr) os << \", \";\r\n            temp = temp->next;\r\n        }\r\n\r\n        os << \"]\";\r\n        return os;\r\n    }\r\n};\r\n```\r\n```java::java\r\npublic class Queue<T> {\r\n    private class Node {\r\n        T data;\r\n        Node next;\r\n        Node(T data) {\r\n            this.data = data;\r\n            this.next = null;\r\n        }\r\n    }\r\n    private Node front;\r\n    private Node rear;\r\n    private int size;\r\n\r\n    public Queue() {\r\n        front = null;\r\n        rear = null;\r\n        size = 0;\r\n    }\r\n\r\n    public boolean isEmpty() {\r\n        return size == 0;\r\n    }\r\n\r\n    public void enqueue(T data) {\r\n        Node newNode = new Node(data);\r\n        if (isEmpty()) {\r\n            front = newNode;\r\n        } else {\r\n            rear.next = newNode;\r\n        }\r\n        rear = newNode;\r\n        size++;\r\n    }\r\n\r\n    public T dequeue() {\r\n        if (isEmpty()) throw new RuntimeException(\"Queue is empty!\");\r\n        Node temp = front;\r\n        front = front.next;\r\n        T data = temp.data;\r\n        temp = null;\r\n\r\n        if (front == null) rear = null;\r\n\r\n        size--;\r\n        return data;\r\n    }\r\n\r\n    public T peek() {\r\n        if (isEmpty()) throw new RuntimeException(\"Queue is empty!\");\r\n        return front.data;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(\"[\");\r\n        Node temp = front;\r\n        while (temp != null) {\r\n            sb.append(temp.data);\r\n            if (temp.next != null) sb.append(\", \");\r\n            temp = temp.next;\r\n        }\r\n        sb.append(\"]\");\r\n        return sb.toString();\r\n    }\r\n}    \r\n```\r\n::\r\n\r\n"
  },
  {
    "path": "/docs/data-structure/linked-list",
    "header": {
      "layout": "post",
      "title": "연결 리스트 (Linked List)",
      "tags": [
        "Data Structure",
        "Linked List"
      ],
      "date": 1569358380000,
      "profile-image": "/post/profile/profile0.jpg",
      "thumbnail": "/post/data-structure/linked-list/index.png",
      "current-company": "Computer Academy",
      "current-position": "Student",
      "summary": "연결 리스트",
      "expose-images": true,
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "자료구조"
      ],
      "images": [
        {
          "src": "/post/data-structure/linked-list/node.png",
          "alt": "노드"
        },
        {
          "src": "/post/data-structure/linked-list/index.png",
          "alt": "연결 리스트"
        },
        {
          "src": "/post/data-structure/linked-list/add-to-linked-list.png",
          "alt": "연결 리스트 추가"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "연결리스트란?::what-is-linked-list",
            "title": "연결리스트란?",
            "fragment": "what-is-linked-list",
            "children": []
          },
          {
            "rank": 2,
            "origin": "연결 리스트의 필수기능 구현::core-operations",
            "title": "연결 리스트의 필수기능 구현",
            "fragment": "core-operations",
            "children": []
          },
          {
            "rank": 2,
            "origin": "연결 리스트의 구현::implementation",
            "title": "연결 리스트의 구현",
            "fragment": "implementation",
            "children": []
          }
        ]
      }
    },
    "description": "연결 리스트는 여러개의 노드가 연결된 자료구조로, 값의 변경(삽입, 삭제)이 용이하다.\r\n배열과 다르게 각 노드를 연결하는 방식이라 크기가 동적으로 변할 수 있다.",
    "content": "\r\n\r\n## 연결리스트란?::what-is-linked-list\r\n\r\n::text-wrapping\r\n![노드](/post/data-structure/linked-list/node.png)\r\n\r\n연결 리스트는 노드를 사용하여 구현하는데, 노드란 어떤 자료구조를 구성하기 위해 사용되는 각 요소를 의미한다. 값을 래핑하는 역할을 한다.  \r\n\r\n사용하려는 자료 구조에 따라 노드를 연결하기위해 next, prev 등의 포인터를 사용한다.\r\n\r\n::{ \"align\": \"left\", \"max-width\": \"80px\" }\r\n\r\n일반적으로 연결 리스트에서는 노드에 `next` 포인터(다른 노드를 참조)를 추가하여 구현한다.\r\n\r\n![연결 리스트](/post/data-structure/linked-list/index.png)\r\n:{ \"description\": \"연결 리스트\" }\r\n\r\n연결 리스트는 이미지처럼 노드의 `next` 필드가 다음 노드를 참조하고 있다. \r\n따라서 값을 추가 할때 마다 현재의 최상위 노드와 새로운 노드를 연결해줘야 한다.\r\n\r\n이는 대략적으로 다음과 같은 구조가 된다.\r\n```text\r\n//노드\r\nclass Node<T> is\r\n    T data\r\n    Node<T> next\r\n    \r\n//연결 리스트\r\nclass LinkedList<T> is\r\n    Node<T> head;\r\n    Node<T> tail;\r\n    ...\r\n```\r\n\r\n연결 리스트에 새로운 값을 추가하려면 새로운 노드의 `next`를 `head`로 설정하고, `head`를 새로운 노드로 설정한다.\r\n\r\n![연결 리스트 추가](/post/data-structure/linked-list/add-to-linked-list.png)\r\n:{ \"description\": \"연결 리스트에 새로운 노드를 추가\" }\r\n\r\n반대로 제거할 때도, `head`를 다음 노드로 설정하고, 제거할 노드를 해제한다.\r\n\r\n> 연결 리스트는 여러 종류가 있지만, 단방향의 경우 `head`는 가장 마지막에 들어온 요소를 의미한다.\r\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\" }\r\n\r\n\r\n## 연결 리스트의 필수기능 구현::core-operations\r\n\r\n* 값 추가 (push_back)\r\n\r\n```text\r\nmethod push_back(Item item) is\r\n    Node newNode = new Node(item)\r\n    newNode.next = head\r\n    head = newNode\r\n    \r\n    size++;\r\n```\r\n\r\n* 값 제거 (pop_back)\r\n\r\n```text\r\nmethod pop_back(): Item is\r\n    if is_empty() then\r\n        throw EmptyListException\r\n    \r\n    Node temp = head\r\n    Item item = temp.data\r\n    head = temp.next\r\n    \r\n    size--;\r\n    \r\n    return item\r\n```\r\n\r\n* 공백 확인 (is_empty)\r\n\r\n```text\r\nmethod is_empty(): boolean is\r\n    return size == 0\r\n```\r\n\r\n## 연결 리스트의 구현::implementation\r\n\r\n**Node Class**\r\n::code-group\r\n\r\n```cpp::c++\r\ntemplate <typename U>\r\nstruct Node {\r\n    U data;\r\n    Node *next;\r\n\r\n    explicit Node(const U& data): data(data), next(nullptr) {}\r\n};\r\n```\r\n\r\n```java::java\r\npublic class Node<T> {\r\n    public T data;\r\n    public Node<T> next;\r\n\r\n    public Node(T data) {\r\n        this.data = data;\r\n        this.next = null;\r\n    }\r\n}\r\n```\r\n::\r\n\r\n**LinkedList Class**\r\n\r\n::code-group\r\n```cpp::c++\r\ntemplate <typename T>\r\nclass LinkedList {\r\nprivate:\r\n    Node<T>* head;\r\n    size_t size;\r\npublic:\r\n    LinkedList(): head(nullptr), size(0) {}\r\n    ~LinkedList();\r\n    void push_back(T value);\r\n    T pop_back();\r\n    bool is_empty() const;\r\n    friend ostream& operator<<(ostream& os, const LinkedList<T>& list) {\r\n        os << \"[\";\r\n        Node<T>* current = list.head;\r\n        while (current != nullptr) {\r\n            os << current->data;\r\n            current = current->next;\r\n            if (current != nullptr) {\r\n                os << \", \";\r\n            }\r\n        }\r\n        os << \"]\";\r\n        return os;\r\n    }\r\n};\r\n```\r\n```java::java\r\npublic class LinkedList<T> {\r\n    private Node<T> head;\r\n    private int size;\r\n\r\n    public LinkedList() {\r\n        head = null;\r\n        size = 0;\r\n    }\r\n\r\n    ...\r\n\r\n    @Override\r\n    public String toString() {\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(\"[\");\r\n        Node<T> current = head;\r\n        while (current != null) {\r\n            sb.append(current.data);\r\n            current = current.next;\r\n            if (current != null) {\r\n                sb.append(\", \");\r\n            }\r\n        }\r\n        sb.append(\"]\");\r\n        return sb.toString();\r\n    }\r\n}\r\n```\r\n::\r\n\r\n\r\n**push_back 구현**\r\n::code-group\r\n```cpp::c++\r\ntemplate<typename T>\r\nvoid LinkedList<T>::push_back(T value) {\r\n    auto* newNode = new Node<T>(value);\r\n    newNode->next = head;\r\n    head = newNode;\r\n\r\n    size ++;\r\n}\r\n```\r\n```java::java\r\npublic void pushBack(T value) {\r\n    Node<T> newNode = new Node<>(value);\r\n    newNode.next = head;\r\n    head = newNode;\r\n\r\n    size++;\r\n}\r\n```\r\n::\r\n\r\n**pop_back 구현**\r\n\r\n::code-group\r\n```cpp::c++\r\ntemplate<typename T>\r\nT LinkedList<T>::pop_back() {\r\n    if (is_empty()) throw underflow_error(\"The linked list is empty\");\r\n    auto* current = head;\r\n    T value = current->data;\r\n    head = current->next;\r\n    delete current;\r\n    size --;\r\n    return value;\r\n\r\n}\r\n```\r\n```java::java\r\npublic T popBack() {\r\n    if (isEmpty()) throw new EmptyListException();\r\n\r\n    Node<T> current = head;\r\n    T value = current.data;\r\n    head = current.next;\r\n    size--;\r\n\r\n    return value;\r\n}\r\n```\r\n::\r\n\r\n**is_empty 구현**\r\n\r\n::code-group\r\n```cpp::c++\r\ntemplate<typename T>\r\nbool LinkedList<T>::is_empty() const {\r\n    return size == 0;\r\n}\r\n```\r\n```java::java\r\npublic boolean isEmpty() {\r\n    return size == 0;\r\n}\r\n```\r\n::\r\n\r\n**클라이언트 코드**\r\n\r\n```cpp\r\nLinkedList<int> list;\r\n\r\nlist.push_back(2);\r\ncout << \"add new \" << 2 << \": \" << list << endl;\r\n\r\nlist.push_back(7);\r\ncout << \"add new \" << 7 << \": \" << list << endl;\r\n\r\nlist.push_back(5);\r\ncout << \"add new \" << 5 << \": \" << list << endl;\r\n\r\nint removed = list.pop_back();\r\ncout << \"remove \" << removed << \": \" << list << endl;\r\nlist.push_back(4);\r\ncout << \"add \" << 4 << \": \" << list << endl;\r\n\r\ncout << list << endl;\r\n```\r\n\r\n**결과**\r\n\r\n```text\r\nadd new 2: [2]\r\nadd new 7: [7, 2]\r\nadd new 5: [5, 7, 2]\r\nremove 5: [7, 2]\r\nadd 4: [4, 7, 2]\r\n[4, 7, 2]\r\n```\r\n"
  },
  {
    "path": "/docs/data-structure/stack",
    "header": {
      "layout": "post",
      "title": "스택 (Stack)",
      "tags": [
        "Data Structure",
        "Array"
      ],
      "date": 1568037180000,
      "profile-image": "/post/profile/profile0.jpg",
      "thumbnail": "/post/data-structure/stack/index.png",
      "current-company": "Computer Academy",
      "current-position": "Student",
      "summary": "스택",
      "expose-images": true,
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "자료구조"
      ],
      "images": [
        {
          "src": "/post/data-structure/stack/index.png",
          "alt": "스택"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "스택이란?::what-is-stack",
            "title": "스택이란?",
            "fragment": "what-is-stack",
            "children": []
          },
          {
            "rank": 2,
            "origin": "스택의 필수기능 구현::core-operations",
            "title": "스택의 필수기능 구현",
            "fragment": "core-operations",
            "children": []
          },
          {
            "rank": 2,
            "origin": "스택의 구현::implementation",
            "title": "스택의 구현",
            "fragment": "implementation",
            "children": []
          },
          {
            "rank": 2,
            "origin": "스택의 사용::usage",
            "title": "스택의 사용",
            "fragment": "usage",
            "children": []
          }
        ]
      }
    },
    "description": "스택은 후입선출(LIFO, Last In First Out)의 자료구조로, 데이터를 쌓아 올리는 방식으로 저장한다.",
    "content": "\r\n\r\n## 스택이란?::what-is-stack\r\n\r\n![스택](/post/data-structure/stack/index.png)\r\n:{ \"description\": \"스택\" }\r\n\r\n스택은 후입선출(LIFO, Last In First Out)의 자료구조로, 데이터를 쌓아 올리는 방식으로 저장한다.\r\n스택에 값을 넣는 행위를 **Push**, 값을 꺼내는 행위를 **Pop**이라고 한다.\r\n\r\n이미지 처럼 9라는 값을 넣고(Push) 다시 꺼내어(Pop)도 9가 나오게 된다.\r\n이 자료구조는 컴퓨터의 메모리 구조에서 함수 호출과 복귀 주소를 저장하는데 사용된다.\r\n\r\n프로세스가 메모리에 올라가서 함수의 호출을 받으면, 함수의 호출 정보를 스택에 저장하고 함수가 종료되면 스택에서 꺼내어 복귀 주소로 사용한다.\r\n스택은 [배열](/docs/data-structure/array)이나 [연결 리스트](/docs/data-structure/linked-list)로 구현할 수 있다.\r\n\r\n## 스택의 필수기능 구현::core-operations\r\n\r\n* peek(): 스택의 맨 위에 있는 데이터를 반환한다. 말그대로 훔쳐보는 것이기 때문에 데이터를 꺼내지 않는다.\r\n\r\n```text\r\nmethod peek(): Item is\r\n    return stack[top]\r\n```\r\n\r\n* push(item): 스택의 맨 위에 데이터를 추가한다.\r\n```text\r\nmethod push(Item item) is\r\n    if stack is full then\r\n        throw StackOverflowException\r\n    top = top + 1 //마지막으로 들어간 요소의 인덱스를 증가시킨다.\r\n    stack[top] = item //새로운 요소의 값을 넣는다.\r\n```\r\n\r\n* pop(): 스택의 맨 위에 있는 데이터를 꺼내어 반환한다.\r\n```text\r\nmethod pop(): Item is\r\n    if stack is empty then\r\n        throw StackUnderflowException\r\n    Item item = stack[top] //맨 위에 있는 요소를 꺼낸다.\r\n    top = top - 1 //맨 위에 있는 요소를 꺼냈으므로 인덱스를 감소시킨다.\r\n    return item\r\n```\r\n\r\n## 스택의 구현::implementation\r\n\r\n이 예제에서는 배열과, 연결 리스트로 스택을 구현한다.\r\n\r\n::code-group\r\n```cpp::(c++) Stack 상위 클래스\r\ntemplate <typename T>\r\nclass Stack {\r\n    public:\r\n        // 가상 소멸자\r\n        virtual ~Stack() = default;\r\n        virtual void push(const T& item) = 0;\r\n        virtual T pop() = 0;\r\n        virtual T peek() = 0;\r\n        virtual bool is_empty() = 0;\r\n        virtual int size() = 0;\r\n};\r\n```\r\n\r\n```java::(java) Stack 상위 클래스\r\npublic interface Stack<T> {\r\n    void push(T item);\r\n    T pop();\r\n    T peek();\r\n    boolean isEmpty();\r\n    int size();\r\n}\r\n```\r\n::\r\n\r\n두 가지 방식 모두 구현하기 위해, 상위 클래스를 만들어 공통된 메서드를 정의한다.\r\n\r\n::code-group\r\n```cpp::(c++) 배열로 구현한 스택\r\n#include <iostream>\r\n#include \"Stack.h\"\r\nusing namespace std;\r\n\r\ntemplate <typename T>\r\nclass ArrayStack final : public Stack<T> {\r\nprivate:\r\n    T* arr;\r\n    int top;\r\n    int cap;\r\npublic:\r\n    explicit ArrayStack(const int cap): top(-1), cap(cap) {\r\n        arr = new T[cap];\r\n    }\r\n\r\n    ~ArrayStack() override {\r\n        delete[] arr;\r\n    }\r\n\r\n    void push(const T& item) override {\r\n        if (top == cap -1) {\r\n            throw overflow_error(\"Stack is full\");\r\n        }\r\n        arr[++top] = item;\r\n    }\r\n\r\n    T pop() override {\r\n        if (is_empty()) {\r\n            throw underflow_error(\"Stack is empty\");\r\n        }\r\n\r\n        return arr[top--];\r\n    }\r\n\r\n    T peek() override {\r\n        if (is_empty()) {\r\n            throw underflow_error(\"Stack is empty\");\r\n        }\r\n\r\n        return arr[top];\r\n    }\r\n\r\n    bool is_empty() override {\r\n        return top == -1;\r\n    }\r\n\r\n    int size() override {\r\n        return top + 1;\r\n    }\r\n\r\n    friend ostream& operator<<(ostream& os, const ArrayStack<T>& stack) {\r\n        os << \"Stack: [\";\r\n        for (int i = stack.top; i >= 0; i--) {\r\n            os << stack.arr[i];\r\n            if (0 < i) os << \",\";\r\n        }\r\n        os << \"]\";\r\n        return os;\r\n    }\r\n};\r\n```\r\n```java::(java) 배열로 구현한 스택\r\npublic class ArrayStack<T> implements Stack<T> {\r\n    private T[] arr;\r\n    private int top;\r\n    private int cap;\r\n\r\n    public ArrayStack(int cap) {\r\n        this.top = -1;\r\n        this.cap = cap;\r\n        arr = (T[]) new Object[cap];\r\n    }\r\n\r\n    @Override\r\n    public void push(T item) {\r\n        if (top == cap - 1) {\r\n            throw new StackOverflowError(\"Stack is full\");\r\n        }\r\n        arr[++top] = item;\r\n    }\r\n\r\n    @Override\r\n    public T pop() {\r\n        if (isEmpty()) {\r\n            throw new StackUnderflowError(\"Stack is empty\");\r\n        }\r\n        return arr[top--];\r\n    }\r\n\r\n    @Override\r\n    public T peek() {\r\n        if (isEmpty()) {\r\n            throw new StackUnderflowError(\"Stack is empty\");\r\n        }\r\n        return arr[top];\r\n    }\r\n\r\n    @Override\r\n    public boolean isEmpty() {\r\n        return top == -1;\r\n    }\r\n\r\n    @Override\r\n    public int size() {\r\n        return top + 1;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(\"Stack [\");\r\n        for (int i = 0; i <= top; i++) {\r\n            sb.append(arr[i]);\r\n            if (i < top) sb.append(\",\");\r\n        }\r\n        sb.append(\"]\");\r\n        return sb.toString();\r\n    }\r\n}\r\n```\r\n::\r\n\r\n::code-group\r\n```cpp::(c++) 연결 리스트로 구현한 스택\r\n#include \"Stack.h\"\r\n#include <iostream>\r\nusing namespace std;\r\n\r\n\r\ntemplate <typename T>\r\nclass LinkedListStack : public Stack<T> {\r\nprivate:\r\n\r\n    //연결 리스트를 위한 Node 구조체\r\n    struct Node {\r\n        T data;\r\n        Node* next;\r\n\r\n        explicit Node(const T& value) : data(value), next(nullptr) {}\r\n    };\r\n\r\n    Node* top;\r\n    int cap;\r\n\r\npublic:\r\n    explicit LinkedListStack(int capacity) : cap(capacity), top(nullptr) {}\r\n    ~LinkedListStack() override {\r\n        while (top != nullptr) {\r\n            Node* temp = top;\r\n            top = top->next;\r\n            delete temp;\r\n        }\r\n    }\r\n    void push(const T &item) override {\r\n        Node* newNode = new Node(item);\r\n        newNode->next = top;\r\n        top = newNode;\r\n        cap++;\r\n    }\r\n\r\n    T pop() override {\r\n        if (is_empty()) {\r\n            throw underflow_error(\"Stack is empty\");;\r\n        }\r\n        Node* temp = top;\r\n        T popped = temp->data;\r\n        top = top->next;\r\n        delete temp;\r\n        cap--;\r\n\r\n        return popped;\r\n    }\r\n\r\n    T peek() override {\r\n        if (is_empty()) {\r\n            throw underflow_error(\"Stack is empty\");;\r\n        }\r\n        return top->data;\r\n    }\r\n\r\n    bool is_empty() override {\r\n        return top == nullptr;\r\n    }\r\n\r\n    int size() override {\r\n        return top == nullptr ? 0 : cap;\r\n    }\r\n\r\n    friend ostream& operator<<(ostream& os, const LinkedListStack<T>& stack) {\r\n        os << \"Stack: [\";\r\n        Node* current = stack.top;\r\n        while (current != nullptr) {\r\n            os << current->data;\r\n            if (current->next != nullptr) {\r\n                os << \", \";\r\n            }\r\n            current = current->next;\r\n        }\r\n        os << \"]\";\r\n        return os;\r\n    }\r\n};\r\n```\r\n```java::(java) 연결 리스트로 구현한 스택\r\npublic class LinkedListStack implements Stack {\r\n    private Node top;\r\n    private int cap;\r\n\r\n    public LinkedListStack(int capacity) {\r\n        this.cap = capacity;\r\n        this.top = null;\r\n    }\r\n\r\n    @Override\r\n    public void push(Object item) {\r\n        Node newNode = new Node(item);\r\n        newNode.next = top;\r\n        top = newNode;\r\n        cap++;\r\n    }\r\n\r\n    @Override\r\n    public Object pop() {\r\n        if (isEmpty()) {\r\n            throw new StackUnderflowError(\"Stack is empty\");\r\n        }\r\n        Node temp = top;\r\n        Object popped = temp.data;\r\n        top = top.next;\r\n        temp.next = null;\r\n        cap--;\r\n        return popped;\r\n    }\r\n\r\n    @Override\r\n    public Object peek() {\r\n        if (isEmpty()) {\r\n            throw new StackUnderflowError(\"Stack is empty\");\r\n        }\r\n        return top.data;\r\n    }\r\n\r\n    @Override\r\n    public boolean isEmpty() {\r\n        return top == null;\r\n    }\r\n\r\n    @Override\r\n    public int size() {\r\n        return top == null ? 0 : cap;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        StringBuilder sb = new StringBuilder(\"Stack: [\");\r\n        Node current = top;\r\n        while (current != null) {\r\n            sb.append(current.data);\r\n            if (current.next != null) {\r\n                sb.append(\", \");\r\n            }\r\n            current = current.next;\r\n        }\r\n        sb.append(\"]\");\r\n        \r\n        return sb.toString();\r\n    }\r\n    \r\n    public static class Node<T> {\r\n        T data;\r\n        Node next;\r\n        \r\n        public Node(T data) {\r\n            this.data = data;\r\n            this.next = null;\r\n        }\r\n    }\r\n```\r\n::\r\n\r\n## 스택의 사용::usage\r\n\r\n::code-group\r\n```cpp::클라이언트 코드\r\nLinkedListStack<int> stack(100);\r\nstack.push(10);\r\nstack.push(20);\r\n\r\ncout << stack << endl;\r\n\r\nconst int popped = stack.pop();\r\ncout << \"popped: \" << popped << endl;\r\ncout << stack << endl;\r\n\r\nstack.push(75);\r\ncout << \"pushed: \" << 75 << endl;\r\ncout << stack << endl;\r\n```\r\n```text::출력 결과\r\nStack [10,20]\r\npopped: 20\r\nStack [10]\r\npushed: 75\r\nStack [10,75]\r\n```\r\n::\r\n"
  },
  {
    "path": "/docs/computer-science/computer-structure/bit",
    "header": {
      "layout": "wiki",
      "title": "비트 (Bit)",
      "date": 1567671000000,
      "tags": [
        "Computer",
        "Binary",
        "Digit",
        "Bit"
      ],
      "summary": "비트",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "컴퓨터",
        "하드웨어"
      ],
      "images": [],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "Bit란?::what-is-bit",
            "title": "Bit란?",
            "fragment": "what-is-bit",
            "children": []
          },
          {
            "rank": 2,
            "origin": "2진수 변환::convert-binary",
            "title": "2진수 변환",
            "fragment": "convert-binary",
            "children": []
          }
        ]
      }
    },
    "description": "",
    "content": "\r\n## Bit란?::what-is-bit\r\n\r\n**Bit**는 2진법을 뜻하는 **B**inary 와 숫자를 뜻하는 Dig**it**의 합성어로 2진수를 나타내는 단위이다.  \r\n일상 생활에서는 10진법을 사용한다. 10진법은 0부터 9까지의 숫자로 이루어져 있으며, 10개의 숫자로 표현한다.\r\n\r\n하지만, 컴퓨터 체계에서는 2진법을 사용하며, 실제로 컴퓨터 상에서 우리가 다루는 10진수는 실제로 2진수로 변환되어 처리된다.\r\n\r\n예를 들어 10진수 **11**을 2진수로 변환하면 **1011**이 된다. 이렇게 2진법 체계로 변환된 숫자를 2진수(**Bit**)라고 한다.\r\n\r\n## 2진수 변환::convert-binary\r\n\r\n예) 1011~2~ = 1x2^3^ + 0x2^2^ + 1x2^1^ + 1x2^0^ = 11~10~\r\n\r\n\r\n\r\n\r\n\r\n"
  },
  {
    "path": "/docs/data-structure/array",
    "header": {
      "layout": "post",
      "title": "배열 (Array)",
      "tags": [
        "Data Structure",
        "Array"
      ],
      "date": 1567630380000,
      "profile-image": "/post/profile/profile0.jpg",
      "thumbnail": "/post/data-structure/array/index.png",
      "current-company": "Computer Academy",
      "current-position": "Student",
      "summary": "배열",
      "expose-images": true,
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "자료구조"
      ],
      "images": [
        {
          "src": "/post/data-structure/array/index.png",
          "alt": "배열의 주소"
        }
      ],
      "headlines": {
        "rank": 0,
        "origin": "root::root",
        "title": "root",
        "fragment": "root",
        "children": [
          {
            "rank": 2,
            "origin": "배열이란?::what-is-array",
            "title": "배열이란?",
            "fragment": "what-is-array",
            "children": []
          },
          {
            "rank": 2,
            "origin": "배열의 특징::features",
            "title": "배열의 특징",
            "fragment": "features",
            "children": []
          }
        ]
      }
    },
    "description": "배열은 프로그래밍 언어에서 지원되며, 가장 기본이 되는 자료구조이다.\r\n배열에 대해 알아보자.",
    "content": "\r\n\r\n## 배열이란?::what-is-array\r\n\r\n**배열(Array)**은 동일한 자료형의 데이터를 연속적으로 저장하는 자료구조이다.\r\n여러개의 데이터를 한번에 다룰 수 있으며, 색인(index)으로 각 데이터에 접근할 수 있다.\r\n\r\n각 언어 별로 선언 방법이 다르지만, 내부적으로 저장되고 사용되는 매커니즘은 동일하다.\r\n\r\n::code-group\r\n```cpp::C++의 배열의 선언\r\nint arr[5] = {1, 2, 3, 4, 5};\r\n```\r\n\r\n```java::Java의 배열 선언\r\nint [] arr = {1, 2, 3, 4, 5};\r\n```\r\n\r\n```typescript::TypeScript의 배열 선언\r\nvar arr: number[] = [1, 2, 3, 4, 5];\r\n```\r\n::\r\n\r\n배열은 선언시 크기를 정해야한다. 코드에서 명시한 5는 배열의 크기를 의미한다.\r\n배열의 각 요소는 인덱스로 접근할 수 있는데, 책으로 치면 책의 쪽 번호와 같다.\r\n\r\n예를 들어 위의 코드에서 `arr[0]`은 1, `arr[1]`은 2, `arr[2]`는 3, `arr[3]`은 4, `arr[4]`는 5를 가리킨다.\r\n**인덱스는 0부터 시작하며**, 직관적으로 표현된 `[1, 2, 3, 4, 5]`를 그대로 보면된다.\r\n\r\n배열의 크기는 물리적인 메모리를 할당 받는 것이기 때문에, 정해진 크기외의 인덱스로 접근시 오류가 발생한다.\r\n\r\n## 배열의 특징::features\r\n\r\n![배열의 주소](/post/data-structure/array/index.png)\r\n:{ \"align\": \"center\", \"max-width\": \"300px\", \"description\": \"배열의 요소\" }\r\n\r\n배열은 선언시 위와같이 할당된다. 왼쪽의 메모리 주소는 배열에 저장되는 타입의 크기에 따라 다르개 할당된다.\r\n`int`배열 같은 경우 `4byte`를 차지하기 때문에, 연속적인 주소를 위해 `90..94..98` 처럼(끝에 두자리 예)증가한다.\r\n\r\n기본형의 경우 자료형의 크기만큼 증가가되고, 참조형의 경우 컴퓨터 비트 체계를 따라 증가한다. (예: 64 비트 체계의 경우 `8byte` 단위로 증가)\r\n\r\n어쨋든 위의 각각의 요소를 접근하기 위해서는 아래처럼 인덱스를 통해 접근한다.\r\n\r\n```c++\r\nint arr[5] = {9, 1, 4, 3, 6};\r\nint first = arr[0]; // 9\r\nint second = arr[1]; // 1\r\nint third = arr[2]; // 4\r\nint fourth = arr[3]; // 3\r\nint fifth = arr[4]; // 6\r\n```\r\n\r\n이처럼 여러개의 요소를 한개의 변수로 관리할 수 있는 데이터 구조이다.\r\n\r\n> 참조의 경우 배열의 요소에 참조 객체의 주소가 저장되므로 초기화 하지않는 다면 `0x0` 즉 null 상태이다.\r\n:{ \"type\": \"note\", \"icon\": \"info\" }\r\n\r\n\r\n\r\n\r\n"
  }
]