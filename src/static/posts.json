[
  {
    "path": "/wiki/direct-memory-access",
    "header": {
      "layout": "wiki",
      "title": "Direct Memory Access (DMA)",
      "categories": [
        "computer",
        "hardware"
      ],
      "tags": [
        "Hardware",
        "DMAC",
        "Direct Memory Access Controller"
      ],
      "summary": "DMA란?",
      "hide": false,
      "date": 1999999999999,
      "breadcrumbs": [
        "문서",
        "computer",
        "hardware"
      ],
      "images": [
        {
          "src": "/post/computer/data-transfer-between-memory-and-io-device.png",
          "alt": "메모리와 I/O 장치간의 데이터 전송"
        },
        {
          "src": "/post/computer/dma-request.png",
          "alt": "DMA 요청"
        }
      ],
      "headlines": {
        "grade": 0,
        "title": "root",
        "fragmentId": "root",
        "children": [
          {
            "grade": 2,
            "title": "DMA란 무엇인가?",
            "fragmentId": "dma%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F",
            "children": [],
            "isSelected": false
          },
          {
            "grade": 2,
            "title": "DMA는 어떻게 사용되는가?",
            "fragmentId": "dma%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94%EA%B0%80%3F",
            "children": [
              {
                "grade": 3,
                "title": "DMA 의 동작 순서",
                "fragmentId": "dma-%EC%9D%98-%EB%8F%99%EC%9E%91-%EC%88%9C%EC%84%9C",
                "children": [],
                "isSelected": false
              }
            ],
            "isSelected": false
          }
        ],
        "isSelected": false
      }
    },
    "description": "",
    "content": "\r\n## DMA란 무엇인가?\r\n\r\nDMA는 `IO 장치`와 `메모리`간의 데이터 전송을 위한 기술이다.\r\n\r\n정확히는 모든 I/O장치는 아니고, 대용량 데이터 전송을 목적으로 하는 하드웨어와 연결되어있다.  \r\n저장 장치의 경우 `HDD/SSD`, `CD/DVD` 그리고 멀티미디어의 경우 `그래픽 카드(GPU)`, `사운드 카드` 등이 있다.\r\n\r\n[`PIO`]()방식에서는 [CPU]()가 한 워드 또는 바이트마다 전송하기 때문에, 속도가 빠른 **I/O 장치**의 경우 CPU의 실제 프로세스 작업 시간을 줄여 다른 작업을 수행하는데 방해가된다.  \r\n이를 해결하기위해 등장한 DMA 기술은 `I/O 장치에서 메모리`로 또는 `메모리에서 I/O 장치`로 데이터를 CPU의 개입없이 전송하여 CPU의 부담을 줄여준다.\r\n\r\n![메모리와 I/O 장치간의 데이터 전송](/post/computer/data-transfer-between-memory-and-io-device.png)\r\n:{ \"max-width\": \"400px\", \"wrapper-class\": \"justify-center\", \"description\": \"메모리와 I/O 장치간의 데이터 전송\" }\r\n\r\n## DMA는 어떻게 사용되는가?\r\n\r\n**D**irect **M**emory **A**cess **C**ontroller (이하 `DMAC`)는 하드웨어 장치로서, [메모리]() 입출력 장치간의 데이터 전송을 DMA 기술로서 관리하는 장치이다.\r\n\r\n\r\n### DMA 의 동작 순서\r\n\r\n장치 A에서 장치 B로 `DMA` 요청이 들어왔다는 가정하에, 순서를 설명하자면 다음과 같다.\r\n\r\n1. 장치 컨트롤러는 `DMAC`과 물리적으로 연결 되어있는 신호선에  DMA Request(`DMA 요청`)을 보낸 후 `DMAC`에서 요청을 받아들이면, 장치 컨트롤러로 DMA Acknowledge(`DMA 승인`) 신호를 보낸다.\r\n\r\n![DMA 요청](/post/computer/dma-request.png)\r\n:{ \"max-width\": \"400px\", \"wrapper-class\": \"justify-center\", \"description\": \"장치 컨트롤러의 DMA 요청\" }\r\n\r\n2. `DMAC`는 데이터를 전송할 시스템 버스의 소유권을 얻기위해 CPU에게 제어 버스로 `Bus Request` 신호를 전송한다. CPU는 `Bus Grant`신호를 전송하여 버스 사용을 허가한다.\r\n\r\n3. 버스의 소유권을 얻게된 DMAC은 각 장치들로 [시스템 버스]()를 제어하여 데이터를 전송한다.\r\n   1. 주소 신호: 장치 A로 처리될 데이터의 주소를 전달한다.\r\n   2. 제어 신호: 장치 A로 제어할 명령(read)을 전달한다.\r\n   3. 주소 신호: 장치 B로 처리될 데이터의 주소를 전달한다.\r\n   4. 제어 신호: 장치 B로 제어할 명령(write)을 전달한다.\r\n   5. 데이터 전송: 장치 A에서 장치 B로 데이터를 전송한다.\r\n\r\n    \r\n4. 데이터 전송제어를 모두 마친 DMAC은 CPU에게 시스템 버스의 소유권을 반환한다.\r\n\r\n\r\n**Cycle Stealing**\r\n\r\n\r\n\r\n\r\n\r\n"
  },
  {
    "path": "/docs/life/youth-of-ggomi",
    "header": {
      "layout": "post",
      "title": "꼬미의 젊은 시절",
      "categories": [],
      "tags": [
        "Life"
      ],
      "date": 1734591600000,
      "thumbnail": "/post/life/tired-ggomi.jpg",
      "current-company": "NEOWIZ",
      "current-position": "Software Engineer",
      "summary": "나란 꼬미",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "life"
      ],
      "images": [
        {
          "src": "/post/life/first-day-of-ggomi.jpg",
          "alt": "꼬미가 처음 온 날"
        }
      ],
      "headlines": {
        "grade": 0,
        "title": "root",
        "fragmentId": "root",
        "children": [],
        "isSelected": false
      }
    },
    "description": "\r\n",
    "content": "\r\n\r\n![꼬미가 처음 온 날](/post/life/first-day-of-ggomi.jpg)\r\n:{ \"wrapper-class\": \"justify-center\", \"description\": \"꼬미가 처음 만난날\" \"class\": \"w-3/5\" }\r\n\r\n꼬미는 엄마를 잃고, 죽어 가던 형제들 사이에서 같이 생명을 잃어가고 있었다.  \r\n꼬미는 태어났을때 다른 강아지들보다 너무 작아서 쪼꼬미라고 지었다. (엄마가 조씨라서 조꼬미)  \r\n\r\n집에 데려가던 차안에서 토를 했는데, 몇백마리의 기생충이 나왔다.\r\n"
  },
  {
    "path": "/docs/database/mysql-explain",
    "header": {
      "layout": "post",
      "title": "MySQL의 EXPLAIN을 알아보자",
      "categories": [
        "database",
        "mysql"
      ],
      "tags": [
        "Database",
        "MySQL",
        "EXPLAIN"
      ],
      "date": 1724390820000,
      "thumbnail": "/post/database/mysql/mysql-explain-thumbnail.webp",
      "current-company": "NEOWIZ",
      "current-position": "Software Engineer",
      "summary": "MySQL EXPLAIN",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "데이터베이스"
      ],
      "images": [],
      "headlines": {
        "grade": 0,
        "title": "root",
        "fragmentId": "root",
        "children": [
          {
            "grade": 2,
            "title": "EXPLAIN 출력 컬럼",
            "fragmentId": "explain-%EC%B6%9C%EB%A0%A5-%EC%BB%AC%EB%9F%BC",
            "children": [
              {
                "grade": 3,
                "title": "id (SELECT 순서)",
                "fragmentId": "id-(select-%EC%88%9C%EC%84%9C)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "select_type (SELECT 타입)",
                "fragmentId": "select_type-(select-%ED%83%80%EC%9E%85)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "table (참조 테이블)",
                "fragmentId": "table-(%EC%B0%B8%EC%A1%B0-%ED%85%8C%EC%9D%B4%EB%B8%94)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "partition (파티션)",
                "fragmentId": "partition-(%ED%8C%8C%ED%8B%B0%EC%85%98)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "type (조인타입)",
                "fragmentId": "type-(%EC%A1%B0%EC%9D%B8%ED%83%80%EC%9E%85)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "possible_kyes (사용가능한 인덱스)",
                "fragmentId": "possible_kyes-(%EC%82%AC%EC%9A%A9%EA%B0%80%EB%8A%A5%ED%95%9C-%EC%9D%B8%EB%8D%B1%EC%8A%A4)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "key (사용할 인덱스)",
                "fragmentId": "key-(%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%9D%B8%EB%8D%B1%EC%8A%A4)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "key_len (키의 길이)",
                "fragmentId": "key_len-(%ED%82%A4%EC%9D%98-%EA%B8%B8%EC%9D%B4)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "ref (참조 값)",
                "fragmentId": "ref-(%EC%B0%B8%EC%A1%B0-%EA%B0%92)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "rows (검사 행 개수)",
                "fragmentId": "rows-(%EA%B2%80%EC%82%AC-%ED%96%89-%EA%B0%9C%EC%88%98)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "filtered (필터된 수치)",
                "fragmentId": "filtered-(%ED%95%84%ED%84%B0%EB%90%9C-%EC%88%98%EC%B9%98)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "Extra (추가적인 내용)",
                "fragmentId": "extra-(%EC%B6%94%EA%B0%80%EC%A0%81%EC%9D%B8-%EB%82%B4%EC%9A%A9)",
                "children": [],
                "isSelected": false
              }
            ],
            "isSelected": false
          }
        ],
        "isSelected": false
      }
    },
    "description": "MySQL의 쿼리실행계획에 대해 알아보자.\r\n",
    "content": "\r\n\r\n회사에서는 신규유입되는 쿼리에 한에 검수할 수 있는 툴을 만들었다.\r\n\r\n나는 담당하는 서비스에 대해 신규 유입 쿼리를 검수해야하며, 매우 많은 쿼리를 봐야만 했다. \r\n이는 반복적인 업무(쿼리 복사, 테이블 및 인덱스확인, 검수)로 이어졌으며, 실행계획만으로 분석해야하는 대상인지를 1차적으로 판단할 필요가있었다.\r\n\r\n쿼리는 여러 유입 목록중 하나를 상세보기로 전체쿼리를 보아 DB Client(Datagrip)로 가져와서 한개씩 확인 해야했다. \r\n해당 목록에는 쿼리 실행계획도 포함이 되어있기때문에, 상세보기를 보지않고, 목록에서 실행계획만 본다면 바로 판단이 가능하다고 생각되어, 실행 계획을 공부하기로 했다.  \r\n\r\n---\r\n\r\n`EXPLAIN`은 MySQL이 statement를 어떻게 실행하는지에 대한 정보를 제공한다.\r\n`EXPLAIN`은 `SELECT`쿼리 에서 사용되는 각 테이블에 대한 정보를 반환하며, 이는 [Mysql Query Optimizer]() 가 명령문을 처리하면서 읽는 순서대로 테이블을 나열한다. \r\n이 말은 MySQL이 첫번째 테이블에서 행을 읽고 두번째 테이블에서 매치되는 행을 찾은 다음, 세번째 테이블에서, 그리고 계속 그렇게 진행한다는 의미이다. \r\n\r\n\r\n\r\n## EXPLAIN 출력 컬럼\r\n\r\n`EXPLAIN`의 각 출력 행은 하나의 테이블에 대한 정보를 제공한다. 각 행은  아래 `표 1.1 EXPLAIN 출력 컬럼들` 에 요약된 값을 포함한다.\r\n테이블의 첫번째 컬럼에는 컬럼명, 두번째는 `FORMAT=JSON`이 사용될때 출력에서 보여지는 프로퍼티명을 제공한다.\r\n\r\n\r\n\r\n*표 1.1 EXPLAIN 출력 컬럼들*\r\n\r\n| 컬럼          | JSON 이름     | 의미                             |\r\n| ------------- | ------------- | -------------------------------- |\r\n| id            | select_id     | SELECT 식별자                    |\r\n| select_type   | 없음          | SELECT 타입                      |\r\n| table         | table_name    | 결과 행에 대한 테이블            |\r\n| partitions    | partitions    | 매칭되는 파티션                  |\r\n| type          | access_type   | JOIN 타입                        |\r\n| possible_keys | possible_keys | 선택에 사용가능한 index들        |\r\n| key           | key_length    | 선택된 키의 길이                 |\r\n| ref           | ref           | index에 비교되는 컬럼들          |\r\n| rows          | rows          | 조사될 예상행                    |\r\n| filtered      | filtered      | 테이블 조건에서 걸러진 행의 비율 |\r\n| extra         | 없음          | 추가 정보                        |\r\n\r\n\r\n\r\n### id (SELECT 순서)\r\n(JSON: selected_id)  \r\nSELECT 식별자이다. 쿼리 내에서 SELECT의 순서가 있는 숫자이며,  다른 행의 `UNION` 결과를 행이 참조한다면 값은 null일 수 있다. \r\n이 경우 테이블 컬럼은 id 값들의 M과 N인 행의 `UNION`에 행이 참조하는 행을 나타내기 위해, <union**M**,**N**> 같은 값을 보여준다.\r\n  \r\n\r\n### select_type (SELECT 타입)   \r\n(JSON: 없음)  \r\n아래 보여진 테이블중 어떤 `SELECT`의 타입이다. JSON-formatted EXPLAIN은  `SIMPLE`이나 `PRIMARY`가 아닌 한  `query_block`의 프로퍼티로 SELECT 타입을 노출한다.\r\n\r\n| select_type **값**   | JSON 이름                  | Meaning                                                      |\r\n| -------------------- | -------------------------- | ------------------------------------------------------------ |\r\n| SIMPLE               | 없음                       | 간단한 SELECT (UNION 또는 서브쿼리 사용 X)                   |\r\n| PRIMARY              | 없음                       | 가장 바깥쪽 SELECT                                           |\r\n| UNION                | 없음                       | UNION의 두번째 이상의 SELECT                                 |\r\n| DEPENDENT UNION      | dependent (true)           | 바깥쪽 쿼리에 의존되는 UNION에서 두번째 이상의 SELECT        |\r\n| UNION RESULT         | union_result               | UNION의 결과                                                 |\r\n| SUBQUERY             | 없음                       | 서브쿼리의 첫번째 SELECT                                     |\r\n| DEPENDENT SUBQUERY   | dependent (true)           | 바깥쪽 쿼리에 의존되는 서브쿼리의 첫번째 SELECT              |\r\n| DERIVED              | 없음                       | 파생된 테이블 (서브쿼리로 만들어진 임시테이블)               |\r\n| DEPENDENT DERIVED    | depentent (true)           | 또다른 테이블을 의존하는 파생된 테이블                       |\r\n| MATERIALIZED         | materialized_from_subquery | 서브쿼리로 물질화                                            |\r\n| UNCHAHEABLE SUBQUERY | cacheable (false)          | 바깥쪽 쿼리의 각  행에대해 결과가 캐시될수 없고 재 평가 되어아야하는 서브쿼리 |\r\n| UNCACHEABLE UNION    | cacheable (false)          | 캐시를 할 수 없는 서브쿼리에 속해있는 UNION 내 두번째 이상 SELECT |\r\n\r\n> `DEPENDENT`는 일반적으로 [상관관계 서브쿼리](https://dev.mysql.com/doc/refman/8.4/en/correlated-subqueries.html) 사용을 의미한다.\r\n:{ \"type\": \"note\", \"icon\": \"info\"}\r\n\r\n### table (참조 테이블)\r\n(JSON: table_name)    \r\n출력행이 참조하는 테이블명이며, 다음 값중 하나가 될 수도 있다.\r\n* <union**M**, **N**>:  행은 **M** 과 **N**의 id 값을 갖는 행의 union을 합집합을 참조한다.\r\n* <deribed**N**>: 행은 **N**의 값을 갖는 행에 대한 파생된 테이블의 결과를 참조한다.  파생된 테이블은 예를들어 `FROM`절 내 서브쿼리에서 생성될 수도 있다.\r\n* <subquery**N**>: 행은 **N**의 id값을 갖는 행에대해 구체화된 서브쿼리(Materialized Subquery)의 결과를 참조한다.\r\n\r\n### partition (파티션)\r\n(JSON: partitions)  \r\n  쿼리로부터 매칭될수 있는 레코드에서의 파티션이다. 파티셔닝 되지않은 테이블에 대해서는 `NULL` 이다.\r\n\r\n### type (조인타입) \r\n(JSON: access_type)\r\n조인 타입이며, 테이블들을 어떻게 조인하는지 설명을 출력한다. JSON-formatted 출력에서는 acess_type의 속성 값으로 나온다. 다음에 목록은 조인타입을 좋은 케이스부터 안좋은케이스 순으로 설명한다.\r\n* system  \r\n  테이블이 한개의 로우(= 시스템 테이블)만 가지고있다. `const` 조인타입의 특별한 케이스이다.\r\n* const  \r\n테이블에 매칭되는 행이 최대 한개만 있으며, 이는 쿼리의 시작시 읽힌다. 오직 한개의 행만 있기 때문인데, 이 행의 열에 있는 값은 옵티마이저의 나머지 부분에서 상수로 간주될 수 있다. `const` 테이블은 한번만 읽히므로 매우빠르다.\r\n`const` 는`UNIQUE` 인덱스나 `PRIMARY KEY` 의 모든 부분을 상수값과 비교할때 시용된다.  다음 쿼리는  *tbl_name*이 상수 테이블로 사용될 수 있다.\r\n```sql\r\nSELECT * FROM tbl_name WHERE primary_key = 1;\r\n  \r\nSELECT * FROM tbl_name\r\n    WHERE primary_key_part1 = 1 AND primary_key_part2 = 2;\r\n```\r\n\r\n* eq_ref  \r\n이전 테이블에서 각 행 조합마다 이 테이블에서 한 행씩 읽는다. `system`과 `const` 타입을 제외하면 이게 제일 나은 조인타입이다.  조인에서 인덱스의 모든 부분을 사용하고,  인덱스가 `PRIMARY` 또는 `UNIQUE NOT NULL` 인덱스인 경우에 사용된다.\r\n`eq_ref`는 `=` 연산자를 사용하여 비교된 컬럼  인덱스에 사용될 수있다. 비교값은 상수가 될수 있고, 이 테이블보다 먼저 읽은 테이블의 열을 사용하는 표현식이 될 수도 있다. 다음의 예제에서 MySQL 은 *ref_table*를 처리하기위해 `eq_ref` 조인을 사용 할 수 있다.\r\n```sql\r\nSELECT * FROM ref_table,other_table\r\n  WHERE ref_table.key_column = other_table.column; //표현식 비교\r\n  \r\nSELECT * FROM ref_table, other_table\r\n  WHERE ref_table.key_column_part1 = other_table.column\r\n  AND ref_table.key_column_part2 = 1; //상수비교\r\n```\r\n\r\n* ref  \r\n이전 테이블의 행조합마다 일치하는 인덱스 값이 있는 모든행이 이 테이블에서 읽혀진다. 키의 가장왼쪽 접두어만 조인에 사용되거나 키가 `PRIMARY KEY` 또는 `UNIQUE`인덱스(즉, 키 값을 기준으로 조인이 단일행을 선택할 수 없는 경우)가 아닌경우에 `ref`가 사용된다.\r\n사용된 키가 몇개의 행에만 일치하는경우, 좋은 조인 타입이다.\r\n`ref` 는 `<=>`또는 `=` 연산자를 사용하여 비교된 인덱스들에 대해 사용될 수 있다. 다음의 예제에서 MySQL은 *ref_table* 처리에 `ref` 조인을 사용할 수 있다.  \r\n```sql\r\nSELECT * FROM ref_table WHERE key_column = expr; //여기서 expr은 다른 테이블에 대한 조건 표현식을 의미한다.\r\n  \r\nSELECT * FROM ref_table, other_table\r\n  WHERE ref_table.key_column = other_table.column;\r\n  \r\nSELECT * FROM ref_table,other_table\r\n  WHERE ref_table.key_column_part1 = other_table.column\r\n  AND ref_table.key_column_part2 = 1;\r\n```\r\n* fulltext  \r\n`FULLTEXT` 인덱스를 사용하여 수행된 조인이다.\r\n\r\n* ref_or_null  \r\n이 조인 타입은 `ref` 와 유사하지만, MySQL이 `NULL` 값을 포함하는 행들에 대해 추가 검색 수행한다는 점이 다르다. 이 조인 타입 최적화는 서브쿼리를 해결하는데 가장 자주 사용된다. 다음의 예제에서 MySQL은 *ref_table*을 처리에 `ref_or_null` 조인을 사용할 수 있다.\r\n```sql\r\nSELECT * FROM ref_table\r\n  WHERE key_column = expr OR key_column IS NULL;\r\n```\r\n* index_merge  \r\n이 조인 타입은 인덱스 병합 최적화가 사용되었다는 것을 나타 낸다. 이 경우, 출력행의 `key` 컬럼은 사용된 인덱스들의 목록을 포함하며  `key_len` 은 사용된 인덱스에 대한 가장긴 키부분 목록을 포함한다.\r\n\r\n* unique_subquery  \r\n이 타입은 다음 형식의 `IN` 서브쿼리이 대한 `eq_ref`를 대체한다.\r\n```sql\r\nvalue IN (SELECT primary_key FROM single_table WHERE some_expr)\r\n```\r\n`unique_subquery`는 완전히 더나은 효율성을 위해 서브쿼리를 완전히 대체하는 인덱스 조회 함수일 뿐이다.\r\n\r\n* index_subquery  \r\n이 조인 타입은 `unique_subquery`와 비슷하다. `IN` 서브쿼리를 대체하지만, 다음의 형식의 서브쿼리에서 유니크가 아닌 인덱스에 대해 동작한다.\r\n```sql\r\nvalue IN (SELECT key_column FROM single_table WHERE some_expr)\r\n```\r\n\r\n* range  \r\n주어진 범위에 있는 행들만 조회되며, 행 선택에 인덱스를 사용한다. 출력 행의 `key` 컬럼은 해당 인덱스가 사용됨을 나타낸다. `key_len` 컬럼은 사용된 가장긴 키부분을 포함한다. `ref`컬럼은 이 타입에대해 `NULL` 이다.\r\n`range`는 `key`컬럼이  `=, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, LIKE` 또는  `IN()` 연산자를 사용하여 비교되는 상수일 때 사용된다.\r\n```sql \r\nSELECT * FROM tbl_name\r\n  WHERE key_column = 10;\r\n  \r\nSELECT * FROM tbl_name\r\n  WHERE key_column BETWEEN 10 and 20;\r\n  \r\nSELECT * FROM tbl_name\r\n  WHERE key_column IN (10, 20, 30);\r\n  \r\nSELECT * FROM tbl_name\r\n  WHERE key_part1 = 10 AND key_part2 IN (10, 20, 30);\r\n```\r\n* index   \r\n`index` 조인 타입은 인덱스 트리 스캔 빼고 `ALL` 하고 같으며, 두가지 상황에서 발생한다.\r\n* 인덱스가 쿼리에 대한 커버링 인덱스 이고,  테이블에서 필요한 모든 데이터를 충족하는 데 사용할 수 있는 경우 인덱스 트리만 스캔된다. 이 경우 `Extra` 컬럼은 `Using Index`라고 나온다. 보통 인덱스 전용 스캔은 일반적으로 인덱스 사이즈가 테이블 데이터보다 작기떄문에, `ALL`보다 빠르다.\r\n* 풀 스캔은 인덱스에서 읽어서 인덱스 순서대로 데이터 행을 조회하여 수행된다.  `Extra` 컬럼이 에는 인덱스 사용이 나오지 않는다.\r\nMySQL은 쿼리가 단일인덱스의 일부인 컬럼만 사용하는 경우, 이 조인타입을 사용할 수있다.\r\n\r\n* ALL  \r\n풀스캔은 이전 테이블의 행 조합 마다 수행된다. 테이블이 `const`로 표시되지않은 첫번째 테이블인 경우 일반적으로 좋지 않으며, 다른 모든 경우에는 *매우* 나쁘다. 보통은, 이전테이블의 상수값 이나 컬럼값을 기준으로 테이블에서 행을 검색할 수있는 인덱스를 추가하면 `ALL` 타입을 피할 수 있다.\r\n\r\n### possible_kyes (사용가능한 인덱스)\r\n(JSON: possible_keys)    \r\n`possible_keys` 컬럼은 MySQL이 이 테이블에서 행을 찾기위해 선택할 수 있는 인덱스들을 나타낸다. 참고로 이 컬럼은 `EXPLAIN`의 출력에 표시된 테이블들의 순서와 별개입니다. 이 말은 테이블 순서 생성된 실행에서  `possible_keys`에 어떤 키들은 사용될수 없을 수도 있다는 의미이다.\r\n이 컬럼이 `NULL`이라면, 적절한 인덱스가 없다는 뜻이다. 이 경우 인덱싱에 적합한 컬럼을 참조하는지 확인하기위해 `WHERE` 절을 검사사여 쿼리의 성능을 개선할 수 있다. 적절한 인덱스를 생성하고 `EXPLAIN` 쿼리를 확인해보자.\r\nSHOW INDEX FROM  *table_name* 으로 테이블 인덱스를 볼수 있다.\r\n\r\n### key (사용할 인덱스)\r\n(JSON: key)  \r\n`key`  컬럼은 MySQL이 사용하기로 정한 키(인덱스)를 나타냅니다. MySQL이 행조회에 `possible_keys` 인덱스들중 중 한개를 사용하기로 정했다면, 인덱스는 키값으로 나열된다.\r\n`key` 는 `possible_keys` 값에 없는 인덱스를 지정할 수도 있다.  이는 `possible_keys` 인덱스중 어느행도 조회되는데 적합하지 않지만, 쿼리의 선택된 모든 컬럼이 다른 인덱스의 컬럼인경우 발생할 수 있다. 즉, 지정된 인덱스가 선택된 컬럼들을 포함하고 있기때문에, 어느행을 검색할지를 결정하는 데는 사용되지 않더라도 인덱스 스캔은 데이터 행 스캔보다 효율적이다. (*이 내용은 \"커버링 인덱스\"의 효율성에 대한 내용이다.*)\r\n`InnoDB`의 경우 쿼리에서 기본키를 선택하더라도 보조 인덱스가 선택한 열을 포함할 수 있다. 이는 `InnoDB`가 각 보조인덱스에 기본 키 값을 저장하기 때문이다. `key`컬럼이 `NULL`이라면, `MySQL`은 쿼리를 보다 효율적으로 실행하는데 사용할 인덱스를 찾지 못한다.\r\n\r\n`MySQL`이 `possible_keys` 컬럼 내 있는 인덱스를 강제로 사용하거나 무시하게 하려면, 쿼리에서 `FORCE_INDEX`, `USE_INDEX` 또는 `IGNORE_INDEX`를 사용하면 된다.\r\n\r\n### key_len (키의 길이) \r\n(JSON: key_length)    \r\n`key_len` 컬럼은 `MySQL`이 사용하기로 결정한 키의 길이를 나타낸다. `key_len`의 값은 MySQL이 실제로 사용하는 복합키의 일부가 얼마나 되는지 확인 할수 있게 해준다. \r\n실제 표시되는 값은 사용된 키의 바이트 길이를 나타내여 사용하는 유니코드마다 다를수 있다. (*실제로 사용하는 복합키의 일부의 의미는 쿼리에 따라 첫번째 컬럼만 사용할 수도 있고, 두번째 컬럼까지 사용할 수 있다는 의미이다.*)\r\n키 저장 포맷으로 인해, `NULL`이 될수 있는 컬럼의 키 길이는 `NOT NULL`인 컬럼의 길이보다 1이 크다. (*NULL을 구분할 비트가 추가되기 때문에*)\r\n\r\n### ref (참조 값)\r\n(JSON: ref)\r\n`ref`컬럼은 테이블에서 `key` 컬럼 내 어떤 컬럼이나 제약이 지정된 인덱스와 비교되었는지 보여줍니다.\r\n값이 `func`라면, 사용된 값은 어떤 함수의 결과입니다. 어떤 함수인지 확인하려면, 확장된 `EXPLAIN`결과를 보기위해 `EXPLAIN`뒤에 `SHOW WARNINGS`를 사용하면 된다. \r\n함수는 실제로 산술 연산자 같은 연산자 일 수 있다.\r\n\r\n### rows (검사 행 개수)\r\n(JSON: rows)    \r\n`rows`  컬럼은 `MySQL`이 쿼리 실행 검사를 해야만 한다고 여기는 행들의 개수를 나타낸다. `InnoDB` 테이블의 경우, 이 값은 예측치이며, 항상 정확하지 않을 수도 있다.\r\n\r\n### filtered (필터된 수치) \r\n(JSON: filtered)\r\n`filtered` 컬럼은 테이블 조건으로 필터된 테이블 행들의 예상 백분률을 나타낸다. \r\n최대 값은 100이며, 이는 행의 필터링이 발생되지않음을 의미한다. 100에서 감소된 값은 필터링 양이 증가함을 나타낸다. \r\n`rows` 는 검된 행의 예상치를 보여주고`rows` × `filtered`는 다음 테이블로 조인된 행의 갯수를 보여준다. 예를들어, `rows`가 1000이고 `filtered`가 50.00(50%)라면, 다음 테이블로 조인된 행의 개수는 1000 × 50% = 500이다.\r\n\r\n### Extra (추가적인 내용)\r\n(JSON: 없음)\r\n이컬럼은  `MySQL`이 쿼리를 어떻게 해결하는지에 대한 추가적인 정보를 포함한다. 다른 값의 설명들은 `EXPLAIN` [Extra 정보]()을 보자.\r\n\r\n`Extra`컬럼에 해당하는 단일 JSON 속성 값은 따로 없지만, 이 컬럼 내에서 발생될수 있는 값들은 JSON 속성이나 `message` 속성의 텍스트로 노출된다.\r\n쿼리를 빠르게 만들고 싶다면, `Using filesort`와 `Using temporary`의 `Extra` 컬럼값을 조심하자. JSON 형식에서는 `using_filesort`와 `using_temporary_table` 값이 `true`와 같다.\r\n\r\n* Zero limit  \r\n쿼리에 `LIMIT 0`절이있고 어떤 행도 선택할 수 없는 경우이다.\r\n\r\n* Using Where with pushed condition  \r\n이 항목은 [NDB]() 테이블들에만 적용된다.\r\n\r\n* Using Where  \r\n`WHERE`절은 다음 테이블과 일치시킬 행이나 클라이언트에 보내낼 행을 제한하는데 사용된다.  \r\n특별하게 테이블의 모든행을 가져오길 의도하거나 검사하려 하지 않는한, `Extra` 값이 `Using Where`이 아니고 테이블 조인 타입이 `ALL` 또는 `index`라면, 쿼리에 문제가 있을수 있다.  \r\n\r\n`Using Where`은 직접적으로 대응되는 JSON 속성이 없고 `attached_condition` 속성은 사용되는 모든 `WHERE` 조건을 포함한다.\r\n\r\n* Using temporary  \r\n쿼리를 해결하기위해 `MySQL`은 결과를 보관하기위해 임시테이블을 생성할 필요가 있다. 이는 일반적으로 쿼리가 컬럼을 다르게 나열하는 `GROUP BY`와 `ORDER BY`절을 포함하면 발생한다.  \r\n\r\n* Using sort_union(...), Using union(...), Using intersect(...)  \r\n이런것들은 `index_merge` 조인타입에 대한 인덱스 스캔이 어떻게 병합되는지를 보여주는 특별한 알고리즘을 나타낸다.\r\n\r\n* Using MRR  \r\n테이블은 다중범위 읽기 최적화 전략을 사용하여 읽힌다.  \r\n\r\n* Using join buffer (Block Nested Loop), Using join buffer (Batched Key Access), Using join buffer (hash join)  \r\n이전 조인의 테이블은 조인버퍼로 부분적으로 읽히고, 그 행들은 버퍼에서 현재 테이블과 조인을 수행하는데 사용된다. \r\n(Block Nested Loop)는 Block Nested-Loop 알고리즘 사용을 나타내고,(Batched Key Access)는 Batched Key Access 알고리즘 사용을 나타내며 (hash join)은 해시조인 사용을 나타낸다.\r\n즉 `EXPLAIN` 출력의 이전라인에 있는 테이블의 키가 버퍼에 저장되고, 일치하는 행은 `Using join buffter`가 나타나는 줄로 보여진 테이블에서 일괄적으로 가져온다.\r\n\r\n* Using index for skip scan  \r\n스캔 스킵에대한 인덱스를 나타낸다.\r\n\r\n* using index for group-by  \r\n`Using index` 테이블 접근 방법과 유사하며, `Using index for group-by`sms `MySQL`이 실제테이블에 추가적인 어떤 디스크 접근도 없이 `GROUP BY` 또는 `DISTINT` 쿼리의 모든 컬럼을 검색하는데 사용할수 있는 인덱스를 찾았다는 것을 나타낸다.\r\n게다가, 각 그룹에대해 몇개의 인덱스 항목만 읽도록하는 가장 효융적인 방식으로 인덱스가 사용된다.\r\n\r\n* Using index condition  \r\n테이블은 인덱스 튜블을 접근하여 읽고 전체 테이블 행을 읽을것인지 결정하기위해 먼저 테스트한다. 이 방법의 경우, 인덱스 정보는 필수가 아닌한 전체 테이블 행을 읽는것을 연기(\"푸시다운\")하는 데 사용된다.\r\n\r\n* Using index  \r\n실제 행을 읽기위한 추가적인 탐색 없이 인덱스트리에서 정보만을 사용하여 테이블에서 컬럼 정보를 가져온다. 이 전략은 단일 인덱스의 부분인 컬럼만 사용하는 쿼리일때 사용될 수 있다.\r\nInnoDB에서 사용자정의 클러스터드 인덱스(기본키)를 가진 테이블인 경우, `Extra` 컬럼에 `Using index`가 없더라도 해당 인덱스가 사용될 수 있다. 이는 `type`이 인덱스와 `key`가 `PRIMARY`인 경우에 해당한다.\r\n사용된 커버링 인덱스에 대한 정보는 `EXPLAIN FORMAT=TRADITIONAL`과 `EXPLAIN FORMAT=JSON`에 대해 보여진다.\r\n\r\n* Using filesort  \r\n`MySQL`은 정렬된 순서로 행을 검색하는 방법을 찾기위해 한번 더 데이터를 훑어야 한다.\r\n정렬은 조인타입에 따라 모든 행을 검토하면서 `WHERE`절과 일치하는 모든 행에 대해 행을 가리키는 포인터와 정렬키를 저장하는 방식으로 수행된 다음 키들이 정렬되고 정렬된 순서로 행들을 가져온다.\r\n"
  },
  {
    "path": "/docs/framework/spring/abstract-transaction-manager",
    "header": {
      "layout": "post",
      "title": "스프링의 트랜잭션 관리자",
      "categories": [
        "framework",
        "spring"
      ],
      "tags": [
        "Spring",
        "Spring Boot",
        "Transaction",
        "Transaction Manager"
      ],
      "date": 1717495080000,
      "thumbnail": "/post/framework/spring/spring-transaction-manager.png",
      "current-company": "NEOWIZ",
      "current-position": "Software Engineer",
      "summary": "Transaction Manager",
      "excerpt_separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "프레임워크",
        "스프링"
      ],
      "images": [],
      "headlines": {
        "grade": 0,
        "title": "root",
        "fragmentId": "root",
        "children": [
          {
            "grade": 2,
            "title": "AbstractPlatformTransactionManager",
            "fragmentId": "abstractplatformtransactionmanager",
            "children": [
              {
                "grade": 3,
                "title": "설명",
                "fragmentId": "%EC%84%A4%EB%AA%85",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "필드",
                "fragmentId": "%ED%95%84%EB%93%9C",
                "children": [],
                "isSelected": false
              }
            ],
            "isSelected": false
          },
          {
            "grade": 2,
            "title": "설정기능",
            "fragmentId": "%EC%84%A4%EC%A0%95%EA%B8%B0%EB%8A%A5",
            "children": [
              {
                "grade": 3,
                "title": "final setTransactionSynchronizationName(String constantName)",
                "fragmentId": "final-settransactionsynchronizationname(string-constantname)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "final setTransactionSynchronization( int transactionSynchronization)",
                "fragmentId": "final-settransactionsynchronization(-int-transactionsynchronization)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "final setDefaultTimeout(int defaultTimeout)",
                "fragmentId": "final-setdefaulttimeout(int-defaulttimeout)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "final setNestedTransactionAllowed(boolean nestedTransactionAllowed)",
                "fragmentId": "final-setnestedtransactionallowed(boolean-nestedtransactionallowed)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "final setValidateExistingTransaction(boolean validateExistingTransaction)",
                "fragmentId": "final-setvalidateexistingtransaction(boolean-validateexistingtransaction)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "final setGlobalRollbackOnParticipationFailure(boolean gloabalRollbackOnParticipationFailure)",
                "fragmentId": "final-setglobalrollbackonparticipationfailure(boolean-gloabalrollbackonparticipationfailure)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "final setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly)",
                "fragmentId": "final-setfailearlyonglobalrollbackonly(boolean-failearlyonglobalrollbackonly)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "final setRollbackOnCommitFailure(boolean rollbackOnCommitFailure)",
                "fragmentId": "final-setrollbackoncommitfailure(boolean-rollbackoncommitfailure)",
                "children": [],
                "isSelected": false
              }
            ],
            "isSelected": false
          },
          {
            "grade": 2,
            "title": "PlatformTransactionManager 구현체",
            "fragmentId": "platformtransactionmanager-%EA%B5%AC%ED%98%84%EC%B2%B4",
            "children": [
              {
                "grade": 3,
                "title": "final getTransaction(TransactionDefinition definition)",
                "fragmentId": "final-gettransaction(transactiondefinition-definition)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "doGetTransaction",
                "fragmentId": "dogettransaction",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "handleExistingTransaction",
                "fragmentId": "handleexistingtransaction",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "doBegin",
                "fragmentId": "dobegin",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "final commit(TransactionStatus status)",
                "fragmentId": "final-commit(transactionstatus-status)",
                "children": [],
                "isSelected": false
              }
            ],
            "isSelected": false
          }
        ],
        "isSelected": false
      }
    },
    "description": "트랜잭션 관리자의 공통 처리사항을 알아보자\r\n\r\n",
    "content": "\r\n\r\n## AbstractPlatformTransactionManager\r\n\r\nSpring은 Transaction Manager를 추상화하여 간단하게 사용할수 있다. `DataSourceTransactionManager` 이던 `HibernateSessionMannager` 던 등등 다른 Transaction Manager를 하나로 추상화 되어있는 `AbstractPlatformTransactionManager`를 상황에 맞는 구성을 Spring이 구성해주기때문에 별다른 설정없이 사용하면 된다.\r\n\r\n\r\n\r\n### 설명\r\n`org.springframework.transaction.jta.JtaTransactionManager` 같이 실제 플랫폼 트랜잭션매니저의 기반으로 사용되는 Spring의 표준 트랜잭션 작업흐름 구현체, 추상 기본  클래스이다.\r\n\r\n이 기본 클래스는 다음의  작업흐름을 처리를 제공한다.\r\n\r\n* 트랜잭션이 있는지 판단\r\n* 적절한 전파 동작을 적용\r\n* 필요하다면 트랜잭션을 중단하고 재개\r\n* 커밋 시 rollback-only 표시를 확인\r\n* 롤백 시 적절한 수정 사항을 적용 (실제 롤백 또는  rollback-only를 설정해서)\r\n* 등록된 동기화 콜백을 트리거 (트랜잭션 동기화가 활성화 된 경우)\r\n\r\n하위클래스는 트랜잭션의 특정 상태에대한 특정 템플릿 메서드를 구현해야 함 (예:  중단, 재개, 커밋, 롤백전). 가장중요한 건 추상화와 실제 구현체로 제공되어야만 하는것이고, 그외에는 기본값이 제공되므로 `overriding` 선택사항.  \r\n\r\n트랜잭션 동기화는 트랜잭션 완료시간에 호출되는 콜백을 등록하기위한 일반적인 메커니즘. 이것은 JTA 트랜잭션 내에서 동작할때 JDBC, 하이버네이트, JPA 등등에 대한 데이터 접근클래스로부터 내부적으로 사용. (트랜잭션 완료 시간에 닫히기 위해 트랜잭션 내에서 개방된 리소스를 등록. 예 : 트랜잭션 내 동일한 하이버네이트 세션의 재사용을 위해 )  \r\n\r\n이 클래스의 상태는 직렬화 가능하여  트랜잭션 인터셉터를 전달하는 프록시와 마찬가지로 트랜잭션 전략를 직렬화 가능. 이것은 하위클래스에 달려있는데, 상태를 직렬화 되게 만들고 싶다면 진행. 이 경우에 하위클래스는 마커 인터페이스인 `java.io.Seializable` 를 구현해야하며 일시적인 상태를 복원해야하는경우 잠재적으로 `private` readObject()  메소드 (자바 직렬화 규칙에따라 )를 구현해야함.  \r\n\r\n\r\n### 필드\r\n\r\n* SYNCHRONIZATION_ALWAYS = 0;\r\n    * 트랜잭션 동기화를 항상 활성화며 기존 백엔드 트랜잭션이 없는 PROPAGATION_SUPPORTS인 \"비어있는\" 트랜잭션 까지도 적용.\r\n\r\n* SYNCHRONIZATION_ON_ACTUAL_TRANSACTION = 1;\r\n    * 실제 트랜잭션을 위해서만 트랜잭션 동기화를 활성화 하며, 기존 백엔드 트랜잭션이 없는  PROPAGATION_SUPPORTS 인 비어있는 트랜잭션에는 적용되지 않음.\r\n\r\n* SYNCHRONIZATION_NEVER = 2;\r\n    * 실제 트랜잭션까지도 트랜잭션동기화를 활성화하지 않음.\r\n\r\n## 설정기능\r\n`AbstactPlatformTransactionManager`는 트랜잭션 동기화를 등록하고 관리할 수 있음.\r\n\r\n### final setTransactionSynchronizationName(String constantName)\r\n\r\n* 이 클래스의 해당 상수명으로 트랜잭션 동기화를 설정.\r\n\r\n\r\n\r\n### final setTransactionSynchronization( int transactionSynchronization)\r\n\r\n* 이 트랜잭션 매니저가 Thread-bound 트랜잭션 동기화 지원을 활성화 해야만 할때 설정함. 기본값은 `SYNCHRONIZATION_ALWAYS`.\r\n* 참고로 트랜잭션 동기화는 다른 트랜잭션 매니저에 의해 다중 동시 트랜잭션을 지원하지 않음. 한개의 트랜잭션 매니저만이 이것을 언제든지 허용할 수 있음.\r\n\r\n\r\n### final setDefaultTimeout(int defaultTimeout)\r\n\r\n* 트랜잭션 레벨에 초단위로 명시된 타임아웃이 없는경우 이 트랜잭션 매니저가 적용해야만하는 기본 타임아웃을 명시.\r\n* 기본값은 근본적인 트랜잭션 인프라 기본 타임아웃(예: 일반적으로, JTA Provider 의 경우 30초)이며, TransactionDefinition.TIMEOUT_DEFAULT 값으로 나타남.\r\n\r\n\r\n\r\n### final setNestedTransactionAllowed(boolean nestedTransactionAllowed)\r\n\r\n* 기본값은 \"false\"이며, 중복 트랜잭을 허용할지 설정.\r\n* 일반적으로 구체적인 트랜잭션 매니저 하위클래스에 의해 적절한 기본값으로 초기화 됨.\r\n\r\n\r\n### final setValidateExistingTransaction(boolean validateExistingTransaction)\r\n\r\n* 기존 트랜잭션에 참여하기 전에 검증돼야 하는지 설정.\r\n* 기존 트랜잭션(예: PROPAGATION_REQUIRED 또는 PROPAGATION_SUPPORT가 기존 트랜잭션을 만나는 경우)에 참여할때, 이 외부 트랜잭션의 형질은 내부 트랜잭션영역에 까지도 적용.\r\n* 유효성 검사는 내부 트랜잭션 정의에서 호환되지 않는 고립레벨 및 읽기전용 설정을 감지하고 해당 예외를 throw하여 이에따라 참여를 거부.\r\n* 기본값은 \"false\"이며, 내부 트랜잭션 설정을 느슨하게 무시하여, 외부 트랜잭션의 형질로 간단히 재정의.\r\n* \"true\" 플래그로 변경은 엄격한 유효성검사를 강제하도록 명령.\r\n\r\n\r\n### final setGlobalRollbackOnParticipationFailure(boolean gloabalRollbackOnParticipationFailure)\r\n\r\n* 참여하는 트랜잭션이 실패한후에 기존 트랜잭션을 `rollback-only`로 전역적으로 표시할지 설정.\r\n* 기본값은 \"true\"이며, 참여하는 트랜잭션(예: PROPAGATION_REQUIRED 또는 PROPAGATION_SUPPORT가 기존 트랜잭션을 만나는 경우)이 실패한다면, 트랜잭션은 `rollback-only`로 전역적으로 마킹. *이런 트랜잭션에 오직 가능한 결과는 롤백.*  \r\n* “false”로 변경시: 트랜잭션 발신자가 롤백 결정을 내림. 만약 참여하는 트랜잭션이 예외로 실패한다면, 호출자는 트랜잭션 내 다른경로로 계속하기로 결정할 수 있음. 하지만, 이는 모든 참여 자원이 데이터 액세스 실패 후에도 트랜잭션 커밋을 향해 계속할 수 있는 경우에만 작동. (일반적으로 Hibernate 세션은 해당되지 않는 경우임. 예: JDBC insert/update/delete 동작들의 sequence)  \r\n* **참고:** 이 플래그는 일반적으로 데이터 접근 작업(TransactionInterceptor가 롤백룰에 따라 PlatformTransactionManager.rollback() 호출을 트리거하는 경우)으로 인해 throw 된 예외가 발생한 하위 트랜잭션에 대한 명시적 롤백시도에만 적용. 플래그가 비활성화라면 호출자는 하위 트랜잭션의 롤백룰과 관계없이 예외를 처리하고 롤백을 결정할 수 있음. 그러나 이 플래그는 하위트랜잭션에 명시적 `setRollbackOnly` 호출을 적용하지 않으므로,이는  항상 최종적인 글로벌 롤백(`rollback-only` 호출후 예외가 발생하지 않을 수 있기 때문에 )을 유발.\r\n* 하위트랜잭션의 실패처리에 대한 추천드리는 방법은 글로벌 트랜잭션이 하위트랜잭션의 시작시 가져온 세이브포인트로 롤백될 수 있도록 하는 “중복 트랜잭션” 임. `PROPAGATION_NESTED`는 정확히 이러한 의미를 제공함. 그러나, 중복 트랜잭션 지원이 가능할 때만 동작함. `DataSource TransactionManager` 경우지만, `JtaTransactionManager`의 경우는 아님.\r\n\r\n\r\n### final setFailEarlyOnGlobalRollbackOnly(boolean failEarlyOnGlobalRollbackOnly)\r\n* 트랜잭션이 `rollback-only`로 전역적으로 표시된 경우에 조기 실패할 것 인지 설정.\r\n* 기본값은 “false” 이며, 가장 바깥쪽의 트랜잭션 바운더리에서만 `UnexpectedRollbackExcetpion`을 발생시킴. 내부 트랜잭션 바운더리 내에서 전역 rollback-only 마커가 처음 감지하여 즉시 `UnexpectedRollbackException`을 발생시키려면 이 값을 변경해야함.\r\n* 참고로 스프링 2.0부터 전역  rollback-only 표시자에 대한 조기실패 동작이 통합 됨. (모든 트랜잭션 매니져는 기본적으로 가장 바깥쪽의 트랜잭션 바운더리에서만 `UnexpectedRollbackException`을 발생시킴.) 이 허용 예를들어 동작이 실패하고 트랜잭션이 완료되지 않은 후에도 유닛 테스트를 계속할 수 있음. 모든 트랜잭션 매니저는 이 플래그가 명시적으로 \"true\"로 설정됐을 때만 조기실패 시킴.\r\n\r\n### final setRollbackOnCommitFailure(boolean rollbackOnCommitFailure)\r\n*  `doCommit`메소드 호출의 실패에 `doRollback`이 수행 해야만하는지 설정함. 일반적으로 필요하지 않고 후속 롤백 예외로 커밋 예외를 무시할 가능성이 있으며, 따라서 피해야함.\r\n\r\n## PlatformTransactionManager 구현체\r\n\r\n\r\n### final getTransaction(TransactionDefinition definition)\r\n\r\n```java\r\n@Override\r\n\tpublic final TransactionStatus getTransaction(@Nullable TransactionDefinition definition)\r\n\t\t\tthrows TransactionException {\r\n\r\n\t\t// Use defaults if no transaction definition given.\r\n\t\tTransactionDefinition def = (definition != null ? definition : TransactionDefinition.withDefaults());\r\n\r\n\t\tObject transaction = doGetTransaction();\r\n\t\tboolean debugEnabled = logger.isDebugEnabled();\r\n\r\n\t\tif (isExistingTransaction(transaction)) {\r\n\t\t\t// Existing transaction found -> check propagation behavior to find out how to behave.\r\n\t\t\treturn handleExistingTransaction(def, transaction, debugEnabled);\r\n\t\t}\r\n\r\n\t\t// Check definition settings for new transaction.\r\n\t\tif (def.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {\r\n\t\t\tthrow new InvalidTimeoutException(\"Invalid transaction timeout\", def.getTimeout());\r\n\t\t}\r\n\r\n\t\t// No existing transaction found -> check propagation behavior to find out how to proceed.\r\n\t\tif (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {\r\n\t\t\tthrow new IllegalTransactionStateException(\r\n\t\t\t\t\t\"No existing transaction found for transaction marked with propagation 'mandatory'\");\r\n\t\t}\r\n\t\telse if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||\r\n\t\t\t\tdef.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||\r\n\t\t\t\tdef.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {\r\n\t\t\tSuspendedResourcesHolder suspendedResources = suspend(null);\r\n\t\t\tif (debugEnabled) {\r\n\t\t\t\tlogger.debug(\"Creating new transaction with name [\" + def.getName() + \"]: \" + def);\r\n\t\t\t}\r\n\t\t\ttry {\r\n\t\t\t\treturn startTransaction(def, transaction, debugEnabled, suspendedResources);\r\n\t\t\t}\r\n\t\t\tcatch (RuntimeException | Error ex) {\r\n\t\t\t\tresume(null, suspendedResources);\r\n\t\t\t\tthrow ex;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Create \"empty\" transaction: no actual transaction, but potentially synchronization.\r\n\t\t\tif (def.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT && logger.isWarnEnabled()) {\r\n\t\t\t\tlogger.warn(\"Custom isolation level specified but no actual transaction initiated; \" +\r\n\t\t\t\t\t\t\"isolation level will effectively be ignored: \" + def);\r\n\t\t\t}\r\n\t\t\tboolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);\r\n\t\t\treturn prepareTransactionStatus(def, null, true, newSynchronization, debugEnabled, null);\r\n\t\t}\r\n\t}\r\n```\r\n\r\n이 구현체는 전파동작을 처리함. doGetTransaction, isExistingTransaction 및 doBegin 메서드를 위임함.\r\n설정된 값을 먼저확인하고 없다면 기본값으로 세팅하  트랜잭션을 가져옴. 제일먼저 `TransactionDefinition` 기본값 세팅 후 `doGetTransaction`으로 트랜잭션을 불러옴.\r\n이 메서드에서는 먼저 살펴봐야할 메서드가 3가지정도로 나눌수 있음. `doGetTransaction`, `handleExistingTransaction`, `doBegin`을 보며 유추함.\r\n\r\n\r\n### doGetTransaction\r\n\r\n* 현재 트랜잭션 상태에대한 트랜잭션 객체를 리턴하는 메서드임.\r\n* 반환된 객체는 일반적으로 변경할수 있는 방식에 해당하는 트랜잭션을 전달하여 구체적인 트랜잭션 매니저 구현체에 명시됨.\r\n\r\n\r\n이 메서드는 추상화되어있고 각 구현체인 Transaction Manager들에 의하여 구현되있음. 일반적으로 `JDBC`를 사용하는 `DataSourceTransactionManager`를 예:\r\n\r\n```java\r\n@Override\r\nprotected Object doGetTransaction() {\r\n  DataSourceTransactionObject txObject = new DataSourceTransactionObject();\r\n  txObject.setSavepointAllowed(isNestedTransactionAllowed());\r\n  ConnectionHolder conHolder =\r\n      (ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource());\r\n  txObject.setConnectionHolder(conHolder, false);\r\n  return txObject;\r\n}\r\n```\r\n`line 4`에서 세이브포인트를 이 트랜잭션내에서 허용될 것인지를 정하고 매개변수로 중첩트랜잭션의 허용 여부을 보냄. `line 5`에 `ConnnectionHolder`가 컨넥션 및 세이브 포인트를 생성함. 아래 코드를 보시면 세이브포인트의 네이밍을 확인할 수 있음.\r\n\r\n```java\r\npublic Savepoint createSavepoint() throws SQLException {\r\n\t\tthis.savepointCounter++;\r\n\t\treturn getConnection().setSavepoint(SAVEPOINT_NAME_PREFIX + this.savepointCounter);\r\n\t}\r\n```\r\n트랜잭션 내에서 `SAVEPOINT_0`, `SAVEPOINT_1` .. 이런식으로 생성되면서 갯수를 체크함. `ConnectionHolder`는 현재 설정된 DataSource로 `Connnection`을 생성하여 할당. 결과적으로 세이브포인트 사용 여부와 컨넥션을 가지고 트랜잭션 객체를 반환함.\r\n\r\n### handleExistingTransaction\r\n트랜잭션이 존재하는지 확인하고 존재한다면 `handleExistingTransaction`으로 보내버림.\r\n\r\n```java\r\nprivate TransactionStatus handleExistingTransaction(\r\n\t\t\tTransactionDefinition definition, Object transaction, boolean debugEnabled)\r\n\t\t\tthrows TransactionException {\r\n\r\n\t\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {\r\n\t\t\tthrow new IllegalTransactionStateException(\r\n\t\t\t\t\t\"Existing transaction found for transaction marked with propagation 'never'\");\r\n\t\t}\r\n\r\n\t\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {\r\n\t\t\tif (debugEnabled) {\r\n\t\t\t\tlogger.debug(\"Suspending current transaction\");\r\n\t\t\t}\r\n\t\t\tObject suspendedResources = suspend(transaction);\r\n\t\t\tboolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);\r\n\t\t\treturn prepareTransactionStatus(\r\n\t\t\t\t\tdefinition, null, false, newSynchronization, debugEnabled, suspendedResources);\r\n\t\t}\r\n\r\n\t\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {\r\n\t\t\tif (debugEnabled) {\r\n\t\t\t\tlogger.debug(\"Suspending current transaction, creating new transaction with name [\" +\r\n\t\t\t\t\t\tdefinition.getName() + \"]\");\r\n\t\t\t}\r\n\t\t\tSuspendedResourcesHolder suspendedResources = suspend(transaction);\r\n\t\t\ttry {\r\n\t\t\t\treturn startTransaction(definition, transaction, debugEnabled, suspendedResources);\r\n\t\t\t}\r\n\t\t\tcatch (RuntimeException | Error beginEx) {\r\n\t\t\t\tresumeAfterBeginException(transaction, suspendedResources, beginEx);\r\n\t\t\t\tthrow beginEx;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {\r\n\t\t\tif (!isNestedTransactionAllowed()) {\r\n\t\t\t\tthrow new NestedTransactionNotSupportedException(\r\n\t\t\t\t\t\t\"Transaction manager does not allow nested transactions by default - \" +\r\n\t\t\t\t\t\t\"specify 'nestedTransactionAllowed' property with value 'true'\");\r\n\t\t\t}\r\n\t\t\tif (debugEnabled) {\r\n\t\t\t\tlogger.debug(\"Creating nested transaction with name [\" + definition.getName() + \"]\");\r\n\t\t\t}\r\n\t\t\tif (useSavepointForNestedTransaction()) {\r\n\t\t\t\t// Create savepoint within existing Spring-managed transaction,\r\n\t\t\t\t// through the SavepointManager API implemented by TransactionStatus.\r\n\t\t\t\t// Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.\r\n\t\t\t\tDefaultTransactionStatus status =\r\n\t\t\t\t\t\tprepareTransactionStatus(definition, transaction, false, false, debugEnabled, null);\r\n\t\t\t\tstatus.createAndHoldSavepoint();\r\n\t\t\t\treturn status;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Nested transaction through nested begin and commit/rollback calls.\r\n\t\t\t\t// Usually only for JTA: Spring synchronization might get activated here\r\n\t\t\t\t// in case of a pre-existing JTA transaction.\r\n\t\t\t\treturn startTransaction(definition, transaction, debugEnabled, null);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED.\r\n\t\tif (debugEnabled) {\r\n\t\t\tlogger.debug(\"Participating in existing transaction\");\r\n\t\t}\r\n\t\tif (isValidateExistingTransaction()) {\r\n\t\t\tif (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {\r\n\t\t\t\tInteger currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();\r\n\t\t\t\tif (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {\r\n\t\t\t\t\tConstants isoConstants = DefaultTransactionDefinition.constants;\r\n\t\t\t\t\tthrow new IllegalTransactionStateException(\"Participating transaction with definition [\" +\r\n\t\t\t\t\t\t\tdefinition + \"] specifies isolation level which is incompatible with existing transaction: \" +\r\n\t\t\t\t\t\t\t(currentIsolationLevel != null ?\r\n\t\t\t\t\t\t\t\t\tisoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :\r\n\t\t\t\t\t\t\t\t\t\"(unknown)\"));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!definition.isReadOnly()) {\r\n\t\t\t\tif (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {\r\n\t\t\t\t\tthrow new IllegalTransactionStateException(\"Participating transaction with definition [\" +\r\n\t\t\t\t\t\t\tdefinition + \"] is not marked as read-only but existing transaction is\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tboolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);\r\n\t\treturn prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null);\r\n\t}\r\n```\r\n`PROPAGATION_NEVER`은 현재 트랜잭션이 존재한다면 바로 예외를 throwing 하고,  `PROPAGATION_NOT_SUPPORTED`는 현재 트랜잭션을 중지함.\r\n`PROPAGATION_REQUIRES_NEW`는 현재 진행중인 트랜잭션을 중단하고 새로운 커넥션으로 트랜잭션을 시작하기 때문에 `startTransaction()`로 보냄.\r\n이처럼 다는 설명하지 못하지만 각 전파옵션과 현재 진행중인 트랜잭션의 유무를 판단하여 트랜잭션(상태)를 리턴함.\r\n\r\n### doBegin\r\n\r\n```java\r\n@Override\r\nprotected void doBegin(Object transaction, TransactionDefinition definition) {\r\n  DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;\r\n  Connection con = null;\r\n\r\n  try {\r\n    if (!txObject.hasConnectionHolder() ||\r\n        txObject.getConnectionHolder().isSynchronizedWithTransaction()) {\r\n      Connection newCon = obtainDataSource().getConnection();\r\n      if (logger.isDebugEnabled()) {\r\n        logger.debug(\"Acquired Connection [\" + newCon + \"] for JDBC transaction\");\r\n      }\r\n      txObject.setConnectionHolder(new ConnectionHolder(newCon), true);\r\n    }\r\n\r\n    txObject.getConnectionHolder().setSynchronizedWithTransaction(true);\r\n    con = txObject.getConnectionHolder().getConnection();\r\n\r\n    Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);\r\n    txObject.setPreviousIsolationLevel(previousIsolationLevel);\r\n    txObject.setReadOnly(definition.isReadOnly());\r\n\r\n    // Switch to manual commit if necessary. This is very expensive in some JDBC drivers,\r\n    // so we don't want to do it unnecessarily (for example if we've explicitly\r\n    // configured the connection pool to set it already).\r\n    if (con.getAutoCommit()) {\r\n      txObject.setMustRestoreAutoCommit(true);\r\n      if (logger.isDebugEnabled()) {\r\n        logger.debug(\"Switching JDBC Connection [\" + con + \"] to manual commit\");\r\n      }\r\n      con.setAutoCommit(false);\r\n    }\r\n\r\n    prepareTransactionalConnection(con, definition);\r\n    txObject.getConnectionHolder().setTransactionActive(true);\r\n\r\n    int timeout = determineTimeout(definition);\r\n    if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {\r\n      txObject.getConnectionHolder().setTimeoutInSeconds(timeout);\r\n    }\r\n\r\n    // Bind the connection holder to the thread.\r\n    if (txObject.isNewConnectionHolder()) {\r\n      TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());\r\n    }\r\n  }\r\n\r\n  catch (Throwable ex) {\r\n    if (txObject.isNewConnectionHolder()) {\r\n      DataSourceUtils.releaseConnection(con, obtainDataSource());\r\n      txObject.setConnectionHolder(null, false);\r\n    }\r\n    throw new CannotCreateTransactionException(\"Could not open JDBC Connection for transaction\", ex);\r\n  }\r\n}\r\n```\r\n\r\n이 메서드는 주어진 트랜잭션 정의에따라 의미하  새로운 트랜잭션을 시작함. 이 추상 트랜잭션 매니저에의해 이미 처리되기 때문에 전파동작을 적용하는것에 대해 걱정할 필요없음.   \r\n이 메소드는 트랜잭션 매니저가 실제로 새로운 트랜잭션을 시작하기로 결정할때 호출함. 이전 트랜잭션이 없거나, 이전트랜잭션이 중단됐거나 둘중 하나임.\r\n\r\n특별한 경우는 세이브 포인트 없이 중첩된 트랜잭션임. `useSavepointForNestedTransaction()`이 \"false\"를 리턴 한다면, 이 메소드는 필요할때 중첩된 트랜잭션을 시작을 호출함. 그런 흐름에, 활성트랜잭션이 있음. (이 메소드의 구현체는 이를 감지하고 적절한 중첩 트랜잭션을 시작해야함).\r\n\r\n### final commit(TransactionStatus status)\r\n이 커밋 구현은 기존 트랜잭션 및 프로그래밍 방식 롤백 요청에 참여하는 것을 처리함. `isRollbackOnly`및 `doCommit`그리고 `rollback`에 위임함.\r\n\r\n```java\r\n@Override\r\n\tpublic final void commit(TransactionStatus status) throws TransactionException {\r\n\t\tif (status.isCompleted()) {\r\n\t\t\tthrow new IllegalTransactionStateException(\r\n\t\t\t\t\t\"Transaction is already completed - do not call commit or rollback more than once per transaction\");\r\n\t\t}\r\n\r\n\t\tDefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;\r\n\t\tif (defStatus.isLocalRollbackOnly()) {\r\n\t\t\tif (defStatus.isDebug()) {\r\n\t\t\t\tlogger.debug(\"Transactional code has requested rollback\");\r\n\t\t\t}\r\n\t\t\tprocessRollback(defStatus, false);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {\r\n\t\t\tif (defStatus.isDebug()) {\r\n\t\t\t\tlogger.debug(\"Global transaction is marked as rollback-only but transactional code requested commit\");\r\n\t\t\t}\r\n\t\t\tprocessRollback(defStatus, true);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tprocessCommit(defStatus);\r\n\t}\r\n```\r\n"
  },
  {
    "path": "/docs/tool/customize-markdown-it",
    "header": {
      "layout": "post",
      "title": "markdown-it의 Renderer Rule",
      "categories": [
        "tool"
      ],
      "tags": [
        "markdown-it",
        "typescript"
      ],
      "date": 1689329820000,
      "thumbnail": "/post/tool/customize-markdown-it.webp",
      "current-company": "Herit Corporation",
      "current-position": "Backend Server Developer",
      "summary": "Markdown it 규칙 파헤치기",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "도구"
      ],
      "images": [],
      "headlines": {
        "grade": 0,
        "title": "root",
        "fragmentId": "root",
        "children": [
          {
            "grade": 2,
            "title": "개요",
            "fragmentId": "%EA%B0%9C%EC%9A%94",
            "children": [
              {
                "grade": 3,
                "title": "적용 전",
                "fragmentId": "%EC%A0%81%EC%9A%A9-%EC%A0%84",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "적용 후",
                "fragmentId": "%EC%A0%81%EC%9A%A9-%ED%9B%84",
                "children": [],
                "isSelected": false
              }
            ],
            "isSelected": false
          },
          {
            "grade": 2,
            "title": "분석",
            "fragmentId": "%EB%B6%84%EC%84%9D",
            "children": [
              {
                "grade": 3,
                "title": "Render Rule (규칙)",
                "fragmentId": "render-rule-(%EA%B7%9C%EC%B9%99)",
                "children": [],
                "isSelected": false
              }
            ],
            "isSelected": false
          },
          {
            "grade": 2,
            "title": "템플릿 규칙 적용",
            "fragmentId": "%ED%85%9C%ED%94%8C%EB%A6%BF-%EA%B7%9C%EC%B9%99-%EC%A0%81%EC%9A%A9",
            "children": [
              {
                "grade": 3,
                "title": "규칙 수정",
                "fragmentId": "%EA%B7%9C%EC%B9%99-%EC%88%98%EC%A0%95",
                "children": [],
                "isSelected": false
              }
            ],
            "isSelected": false
          }
        ],
        "isSelected": false
      }
    },
    "description": "javascript의 마크다운 파서인 markdown-it 라이브러리를 커스텀해서 사용해보자. \r\n",
    "content": "\r\n\r\n## 개요\r\n\r\n`markdown-it`은 대중적으로 많이 알려진 javascript markdown parser library이다.\r\n\r\n이글은 마크다운이 무엇 인지에 대해서는 설명하지 않는다. 그저 개인 블로그를 직접 만드는 입장에서 골치덩이인 마크다운 파서를 어떻게하면 조금더 유용하게 쓸수 있을까 고민해보며 만들면서 작성하였다.\r\n\r\n예를 들어 `> BlockQuote`를 작성한다고 가정했을때. 단순히 블럭으로 묶는 것보다 `> BlockQuote {{ \"type\": \"warning\" }}`과 같이 추가적인 템플릿 구문을 추가하여, 경고 스타일의 블럭으로 보여 줄 수도 있을 것이다. 이를 하기 위해서는 기존 `markdown` 해석 형식에서 더 나아가 새로운 템플릿 해석 로직을 추가해야한다. 아래 코드를 보고 좀 더 쉽게 이해해보자.\r\n\r\n\r\n\r\n### 적용 전\r\n\r\n*Markdown*\r\n\r\n```markdown\r\n> 준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다.\r\n```\r\n\r\n*HTML*\r\n\r\n```html\r\n<blockquote>\r\n  준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다.\r\n</blockquote>\r\n```\r\n\r\n\r\n\r\n### 적용 후\r\n\r\n*Markdown*\r\n\r\n```markdown\r\n> 준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다.\r\n:{ \"type\": \"warning\" }\r\n```\r\n\r\n*HTML*\r\n\r\n```html\r\n<blockquote class=\"warning\">\r\n  <p>준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다.</p>\r\n</blockquote>\r\n```\r\n\r\n이는 더 많은 정보를 담을수 있으며, 동시에 추가적인 스타일로 시각적인 효과를 주어, 더 나은 가독성을 만들 수 있다.\r\n\r\n물론 이렇게 만드려면 사용하려는 markdown 구문마다 모두 규칙을 만들어 줘야한다.\r\n\r\n`Markdown-it` 같은 경우 많은 사람들이 블로그 제작시 사용하지만, 실제로 커스텀할 수 있는 `Renderer Rule(랜더링을 하기 위한 규칙)` 같은 기능은 사용하지 않는다. 사실 잘 알려져 있지도 않기 때문에, 많이 사용하지 않는것 일 수 있다.  자신의 블로그를 대충 꾸미고 싶은 사람은 없을테니 이런 방식을 알려 조금이라도 쉽게 이해를 돕고, 나 또한 정리를 하며 다시한번 정립하고 싶다.\r\n\r\n\r\n\r\n## 분석\r\n\r\n### Render Rule (규칙)\r\n\r\n`Renderer Rule(이하 *규칙)` 같은 경우는 `Markdown-it`에서 제공하는 내부적인 규칙의 흐름이다.\r\n\r\n```typescript\r\nimport MarkdownIt from 'mardown-it';\r\n\r\nconst markdown = new MarkdownIt();\r\nconsole.log('rules: ', Object.keys(markdown.renderer.rules));\r\n// Output\r\n// rules: ['code_inline', 'code_block', 'fence', 'image', 'hardbreak', 'softbreak', 'text', 'html_block', 'html_inline']\r\n```\r\n\r\n위는 기본적으로 제공하는 규칙이며, 대략적으로 9개로 볼 수 있다. 이 배열에 명시적으로 있지 않은 요소는 기본규칙이 적용 된다. 예를 들어 `bullet_list_opend` 규칙이 정의 되어 있지 않았으므로, `markdown-it`은 `HTML`로 해석을 시도할 때, `Renderer.prototype.renderToken`이라는 일반 렌더러가 사용된다.\r\n\r\n\r\n\r\n새로운 마크다운 문법을 창시하지 않는한, 아마 기존 문법에서 조금 수정하는 정도 일 것이다.\r\n\r\n따라서 만약 `blockquote_open`이라는 규칙을 수정한다고하면 아래와 같이 할수 있다.\r\n\r\n```typescript\r\nimport MarkdownIt from \"markdown-it\";\r\nimport Token from \"markdown-it/lib/token\";\r\nimport Renderer from \"markdown-it/lib/renderer\";\r\n\r\nconst md = new MarkdownIt();\r\nmd.renderer.rules.blockquote_open = (tokens: Array<Token>, index: number, options: MarkdownIt.Options, env: any, self: Renderer): string => {\r\n\r\n  return '';\r\n}\r\n```\r\n\r\n위에서 받아오는 규칙 함수같은 경우 아래와 같이 타입으로 정의 되어있다.\r\n\r\n```typescript\r\ndeclare namespace Renderer {\r\n    type RenderRule = (tokens: Token[], idx: number, options: MarkdownIt.Options, env: any, self: Renderer) => string;\r\n\r\n    interface RenderRuleRecord {\r\n        [type: string]: RenderRule | undefined;\r\n        code_inline?: RenderRule | undefined;\r\n        code_block?: RenderRule | undefined;\r\n        fence?: RenderRule | undefined;\r\n        image?: RenderRule | undefined;\r\n        hardbreak?: RenderRule | undefined;\r\n        softbreak?: RenderRule | undefined;\r\n        text?: RenderRule | undefined;\r\n        html_block?: RenderRule | undefined;\r\n        html_inline?: RenderRule | undefined;\r\n    }\r\n}\r\n```\r\n\r\n| 인자      | 의미                                         |\r\n| --------- | -------------------------------------------- |\r\n| *tokens*  | 해석되는 모든 토큰 목록 (각 태그에대한 토큰) |\r\n| *index*   | 현재 토큰의 키에 해당하는 인덱스             |\r\n| *options* | `markdown-it`객체가 생성될 때, 정의된 옵션   |\r\n| *env*     | ???                                          |\r\n| *self*    | 렌더러 자체에대한 참조                       |\r\n\r\n규칙을 수정할 때, 실패한다면 기존 규칙으로 `fallback` 시켜줄수 있는 로직도 추가한다면 아래와 같다.\r\n\r\n```typescript\r\nimport MarkdownIt from \"markdown-it\";\r\nimport Token from \"markdown-it/lib/token\";\r\nimport Renderer from \"markdown-it/lib/renderer\";\r\n\r\nconst md = new MarkdownIt();\r\nconst proxy = (tokens: Array<Token>, index: number, options: MarkdownIt.Options, env: any, self: Renderer) => self.renderToken(tokens, index, options);\r\n//기본 fallback 규칙\r\nconst defaultBlockquoteOpenRule = md.renderer.rules.blockquote_open || proxy;\r\n\r\nmd.renderer.rules.blockquote_open = (tokens: Array<Token>, index: number, options: MarkdownIt.Options, env: any, self: Renderer): string => {\r\n  return defaultBlockquoteOpenRule(tokens, index, options, env, self);\r\n}\r\n\r\nconst markdownText = '뜨거운 태양아래 시원한 계곡물에 잠수!\\n> 준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다.';\r\n//HTML 렌더링\r\nconst html = md.render(markdownText);\r\n/* html \r\n<p>뜨거운 태양아래 시원한 계곡물에 잠수!</p>\r\n<blockquote>\r\n\t<p>준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다.</p>\r\n</blockquote>\r\n*/\r\n```\r\n\r\n*tokens*  인자를 출력해보면 다음과 같다.\r\n\r\n```\r\n[\r\n\t{ \"type\": \"paragraph_open\", \"tag\": \"p\" ...},\r\n\t{ \"type\": \"inline\" \"tag\": '' ...},\r\n\t{ \"type\": \"paragraph_close\", \"tag\": \"p\" ...},\r\n\t{ \"type\": \"blockquote_open\", \"tag\": \"blockquote\" ...},\r\n\t{ \"type\": \"paragraph_open\", \"tag\": \"p\" ...},\r\n\t{ \"type\": \"inline\", \"tag\": '' ...},\r\n\t{ \"type\": \"paragragh_close\", \"tag\": 'p' ...},\r\n\t{ \"type\": \"blockquote_close\", \"tag\": \"blockquote\" ...}\r\n]\r\n```\r\n\r\n어떤 패턴이 보인다. 그렇다. `tokens`는 위에서부터 순서대로 html 을 랜더링할 정보를 가지고 있다.\r\n\r\n랜더링 된 `HTML`과 비교하면 직관적으로 알 수 있다.\r\n\r\n```html\r\n<!-- paragraph_open, inline, paragraph_close -->\r\n<p>뜨거운 태양아래 시원한 계곡물에 잠수!</p>\r\n<!-- blockquote_open, paragraph_open, inline, paragragh_close, blockquote_close -->\r\n<blockquote>\r\n\t<p>준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다.</p>\r\n</blockquote>\r\n```\r\n\r\n\r\n\r\n위와 같이 규칙은 랜더링 되어야할 순서대로 생성되기 때문에, 이미 랜더링 된 토큰을 수정할수 없다.\r\n\r\n```html\r\n<blockquote>\r\n\t<p>준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다.</p>\r\n</blockquote>\r\n```\r\n\r\n이런 코드를 보면 순서로 봤을 때 [`blockquote_open` ,`paragraph_open`, `inline`, `paragragh_close`, `blockquote_close`] 로 진행된다.\r\n\r\n만약 내가 `blockquote` 태그에 `class=\"waring\" 이라는 속성을 추가 해주고 싶다면. 이 정보를 전달해야한다.\r\n\r\n```markdown\r\n> 준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다.\r\n> 또는 심장마비가 올수도 있다.\r\n:{ \"type\": \"warning\" }\r\n```\r\n\r\n이런 마크다운이 있을때 별다른 처리가 없다면 아래와 같이 전달하는 속성정보가 그대로 전달되어 출력될 것이다.\r\n\r\n```markdown\r\n<blockquote>\r\n\t<p>준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다. 또는 심장마비가 올수도 있다. :{ \"type\": \"warning\" }</p>\r\n</blockquote>\r\n```\r\n\r\n따라서 `inline` 토큰에서 \"warning\" 값을 추출해서 `blockquote` 토큰에 `class` 속성으로 추가해줘야한다. 또한 `inline` 토큰에는 실제 노출이 필요한 문자열인 `준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다. 또는 심장마비가 올수도 있다.`만 아래와 같이 남아야한다.\r\n\r\n```markdown\r\n<blockquote class=\"warning\">\r\n\t<p>준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다. 또는 심장마비가 올수도 있다.<p>\r\n</bloackquote>\r\n```\r\n\r\n\r\n\r\n위에서 이미 랜더링된 토큰은 수정할 수 없다고 했다. 그 말은 현재 상황에서 보면 [`blockquote_open` ,`paragraph_open`, `inline`, `paragragh_close`, `blockquote_close`]  순서로 진행될때 `inline`토큰에서 `blockquote_open` 토큰에 `class` 속성을 주입해도 이미 랜더링된 `blockquote_open` 토큰에는 적용이 안된다는 말이다. 따라서 `blockquote_open` 에서 뒤에 랜더링될 `inline` 토큰을 수정해야 정상적으로 노출될 수 있다.\r\n\r\n## 템플릿 규칙 적용\r\n\r\n\r\n\r\n### 규칙 수정\r\n\r\n```typescript\r\nimport MarkdownIt from \"markdown-it\";\r\nimport Token from \"markdown-it/lib/token\";\r\nimport Renderer from \"markdown-it/lib/renderer\";\r\n\r\nconst md = new MarkdownIt();\r\nconst proxy = (tokens: Array<Token>, index: number, options: MarkdownIt.Options, env: any, self: Renderer) => self.renderToken(tokens, index, options);\r\n//기본 fallback 규칙\r\nconst defaultBlockquoteOpenRule = md.renderer.rules.blockquote_open || proxy;\r\n\r\nmd.renderer.rules.blockquote_open = (tokens: Array<Token>, index: number, options: MarkdownIt.Options, env: any, self: Renderer): string => {\r\n  try {\r\n    const templateRE = /^([\\s\\S]*?)\\s*:\\s*(\\{[\\s\\S]*\\})\\s*$/mg;\r\n    const inlineIndex = index +2;\r\n\r\n    if (inlineIndex >= tokens.length) throw new Error(`Index out of range from tokens: ${inlineIndex}`);\r\n    const inline = tokens[inlineIndex];\r\n    const content = inline.content;\r\n    const noneMatch = !templateRE.test(content);\r\n    templateRE.lastIndex = 0;\r\n    if (!inline.map || noneMatch) {\r\n      return defaultBlockquoteOpen(tokens, index, options, env, self);\r\n    }\r\n    /*\r\n    * 준비운동을 하지 않고 물에 들어간다면, 다리에 쥐가 날 수 있다. 두번째 줄이지! - executed[1]\r\n    * :{ \"type\": \"warning\" } - executed[2]\r\n    */\r\n    const executed = templateRE.exec(content);\r\n    const text = executed?.[1] ?? '';\r\n    const attributesStr = executed?.[2];\r\n    const attributes = JSON.parse(attributesStr ?? '{}');\r\n    //type = \"warning\"\r\n    const type = attributes['type'];\r\n\r\n\t\t//children은 inline내부에서 랜더링될 자식 토큰들의 목록이다.\r\n    //여기서 slice는 text값 뒤에 템플릿은 필요없기 때문에 제거해주기 위함이다.\r\n    const lfCount = countNewline(text);\r\n    const lineCount = lfCount +1;\r\n    inline.children = inline.children?.slice(0, lfCount + lineCount) ?? inline.children;\r\n    inline.content = text ?? inline.content;\r\n\r\n    //현재 토큰에 class 속성을 부여한다.\r\n    const blockquoteOpen = tokens[index];\r\n    if (type) {\r\n      blockquoteOpen.attrJoin('class', type);\r\n    }\r\n\r\n    return defaultBlockquoteOpen(tokens, index, options, env, self);\r\n  } catch (e: Error) {\r\n    console.error(`Error occurred at parsing token: \"${e.message}\"`);\r\n    return '';\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n`:{ \"type\" : \"warning\" }` 템플릿은 뭔가 급조해서 만들어서 만들었기 때문에 자신만의 템플릿을 만들어 더 나은 parser를 구현할 수 있을듯 하다.\r\n\r\n사실 기존에도 `chirpy` 같은 Jekyll 테마 같은 경우에는 커스텀 템플릿을 만들어 공유되고 있었다.\r\n\r\n"
  },
  {
    "path": "/docs/algorithm/heap-sort",
    "header": {
      "layout": "post",
      "title": "우선순위 컬렉션 HEAP",
      "categories": [
        "algorithm"
      ],
      "tags": [
        "Java",
        "Algorithm",
        "Sort",
        "Heap Sort",
        "Heap"
      ],
      "date": 1651837980000,
      "profile-image": "/post/profile/profile4.jpeg",
      "thumbnail": "/post/algorithm/heap/heap_sort_intro.png",
      "current-company": "Herit Corporation",
      "current-position": "Backend Server Developer",
      "summary": "Heap Data Structure",
      "expose-images": true,
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "알고리즘"
      ],
      "images": [
        {
          "src": "/post/algorithm/heap/tree_images.svg",
          "alt": "위 트리중 어떤것이 힙인지 찾아보세요."
        },
        {
          "src": "/post/algorithm/heap/first_iteration.svg",
          "alt": "힙을 만드려면 완전 이진트리가 있어야 해요."
        },
        {
          "src": "/post/algorithm/heap/other_iteration.svg",
          "alt": "만약 마지막 내부노드부터 순회할 때, 쵀대힙을 만드려면 위와 같이 만들수 있어요."
        },
        {
          "src": "/post/algorithm/heap/last_iteration.svg",
          "alt": "최대힙을 만들어 이런 형태로 노드를 나눌수 있어요."
        },
        {
          "src": "/post/algorithm/heap/add_new_17.svg",
          "alt": "만약 다음의 힙에서 17이라는 값이 추가 된다면"
        },
        {
          "src": "/post/algorithm/heap/add_new_17_2.svg",
          "alt": "이런식으로 부모노드와 바꿔가며, 다시 힙을 유지할 수 있어요."
        },
        {
          "src": "/post/algorithm/heap/heap_sort_1_1.svg",
          "alt": "힙 정렬 1"
        },
        {
          "src": "/post/algorithm/heap/heap_sort_1_2.svg",
          "alt": "힙 정렬 2"
        },
        {
          "src": "/post/algorithm/heap/heap_sort_1_3.svg",
          "alt": "힙 정렬 3"
        },
        {
          "src": "/post/algorithm/heap/heap_sort_1_4.svg",
          "alt": "힙 정렬 4"
        },
        {
          "src": "/post/algorithm/heap/heap_sort_1_5.svg",
          "alt": "힙 정렬 5"
        },
        {
          "src": "/post/algorithm/heap/heap_sort_1_6.svg",
          "alt": "힙 정렬 6"
        },
        {
          "src": "/post/algorithm/heap/heap_sort_1_7.svg",
          "alt": "힙 정렬 7"
        },
        {
          "src": "/post/algorithm/heap/heap_sort_1_8.svg",
          "alt": "힙 정렬 8"
        }
      ],
      "headlines": {
        "grade": 0,
        "title": "root",
        "fragmentId": "root",
        "children": [
          {
            "grade": 2,
            "title": "설명",
            "fragmentId": "%EC%84%A4%EB%AA%85",
            "children": [
              {
                "grade": 3,
                "title": "Heap의 속성 (특징)",
                "fragmentId": "heap%EC%9D%98-%EC%86%8D%EC%84%B1-(%ED%8A%B9%EC%A7%95)",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "Heap을 만드는 방법",
                "fragmentId": "heap%EC%9D%84-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "Heap이 우선 값을 유지하는 방법",
                "fragmentId": "heap%EC%9D%B4-%EC%9A%B0%EC%84%A0-%EA%B0%92%EC%9D%84-%EC%9C%A0%EC%A7%80%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "Heap을 이용해 정렬을 하는 방법",
                "fragmentId": "heap%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%B4-%EC%A0%95%EB%A0%AC%EC%9D%84-%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95",
                "children": [],
                "isSelected": false
              }
            ],
            "isSelected": false
          },
          {
            "grade": 2,
            "title": "구현 코드 (Java)",
            "fragmentId": "%EA%B5%AC%ED%98%84-%EC%BD%94%EB%93%9C-(java)",
            "children": [],
            "isSelected": false
          }
        ],
        "isSelected": false
      }
    },
    "description": "힙의 자료구조와 어떻게 우선순위를 유지하는지 알아보자.\r\n\r\n",
    "content": "\r\n\r\n## 설명\r\n\r\n간단하게 말하여, 힙은 우선순위 큐 입니다. `JAVA`에서는 `PriorityQueue`라는 구현체를 통해 Heap 자료구조를 사용할 수 있어요.\r\n힙은 두 종류가 있는데 `최대 힙`과 `최소 힙`이 있어요. \r\n최대 Heap(최소 Heap)은 단어와 같이 최대 값(최소 값)을 우선순위로 판단하여, 어떠한 값이 들어와도, 항상 같은 순서의\r\n트리를 유지하며, 언제든지 최고 우선순위의 값을 적은 비용으로 쉽게 얻을수 있는 자료구조 입니다.\r\n\r\n### Heap의 속성 (특징)\r\n\r\n* 최대 힙(**또는 최소 힙**)은 `잎(leaf)`의 계층을 제외한 모든 노드는 자식의 노드 보다 큰(**또는 작은**) 값을 가지고 있어야합니다.\r\n* 왼쪽부터 차례대로 채워져있는 `완전 이진 트리(Complete binary tree)`이어야 합니다.\r\n* 같은 계층의 노드들과는 정렬하지 않습니다.\r\n* 루트(뿌리)노드로 부터 내려오는 위치의 노드들 오름차순(**또는 내림차순**)입니다\r\n\r\n![위 트리중 어떤것이 힙인지 찾아보세요.](/post/algorithm/heap/tree_images.svg)\r\n\r\n* 트리 A: 잎을 제외한 노드는 모두 정렬되었지만, 왼쪽부터 채워지지않아 Heap이 아닙니다.\r\n* 트리 B: 왼쪽부터 채워졌지만, 2번노드의 값은 그 자식에값보다 작습니다. 따라서 Heap이 아닙니다.\r\n* 트리 C: 잎을 제외한 모든 노드가 자식 또는 부모와 정렬 되어있고, 왼쪽부터 채워져있으므로 `Heap`입니다.\r\n\r\n> 이를 정리하면 아래와 같습니다.   \r\n> 1.`𝑛개`의 노드를 가진 힙은 정확히 하나만 있고 그 힙(트리)의 높이(height)는 `⎣log₂𝑛⎦`이다. 트리의 전체 노드의 개수가 `8`일경우 트리(힙)의 높이는 `3`이다. 즉 힢의 높이는 힙의 성질(속성)에 부합되는 노드들만 인정이 된다는 의미이다.  \r\n> 2.힙의 루트 노드는 항상 최댓값(**또는 최솟값**)을 저장한다. 최대 힙(**또는 최소 힙**)은 쵀댓값(**또는 최솟값**)을 효율적으로 관리하기 위한 자료구조이며, 루트에는 항상 가장 큰(**또는 작은**)값을 유지한다.  \r\n> 3.힙의 한 노드와 그 노드의 자손 노드들로 이루어진 부분 트리(subtree)도 힙이다. 힙은 힙으로 이루어져있으며 자식노드도 힙이 될수있지만, 노드의 자식이없다면 힙이될 수없다. 따라서 위 C 트리의 `4, 5, 6`번 노드는 힙이 아니다.  \r\n:{ \"type\": \"note\", \"icon\": \"info\" }\r\n\r\n### Heap을 만드는 방법\r\n\r\n힙을 구성 하기 위해서는 다음의 순서대로 진행됩니다.\r\n\r\n1. 순회를 시작할 힙이되는 마지막 노드`⎣𝑛/₂⎦`를 찾는다.\r\n2. 마지막 노드 i를 이용해 자식노드가 있는지, 또한 있다면 그 중 자신 보다 큰값을 자신과 찾는다.\r\n3. 찾은 값과 자신을 바꾸고 바꾼 자신의 위치는 그값의 자식이 되며, 자신보다 큰값이 나오지 않을때까지 반복한다.\r\n4. 다음 노드(i -1)에서 다시 `3.`을 반복한다.\r\n\r\n> 자식 노드의 위치를 찾을때는 왼쪽`arr[2i]`값과 오른쪽`arr[2i + 1]`로 구할 수 있습니다.\r\n:{ \"type\": \"tip\", \"icon\": \"lightbulb\" }\r\n\r\n위 의 내용을 정리하면 아래와 같습니다.\r\n\r\n\r\n![힙을 만드려면 완전 이진트리가 있어야 해요.](/post/algorithm/heap/first_iteration.svg)\r\n\r\n> 위의 트리는 *완전 이진트리* 입니다. 힙은 완전이진트리에서 만들수 있으므로, 일반 이진트리는 Compact하게 완전이진트리로 바꿔야 힙을 만들수 있습니다.\r\n> 왼쪽 트리의 마지막 힙의 값은 `15` 이며, 이는 자식(`6, 4`) 어느것 보다도 큰값입니다. 따라서 다음 순회로 넘어갑니다.\r\n> 순회는 내부 노드의 마지막 힙의 위치에서 부터 1까지 이어집니다. 따라서 다음 인덱스인 3번 노드(9)로 넘어갑니다.\r\n> 3번노드는 자신의 자식들 중 6번째, 7번째 (7, 12)와 비교하여 더 큰값을 가지는 12와 바꿉니다.\r\n:{ \"type\": \"note\", \"icon\": \"info\" }\r\n\r\n![만약 마지막 내부노드부터 순회할 때, 쵀대힙을 만드려면 위와 같이 만들수 있어요.](/post/algorithm/heap/other_iteration.svg)\r\n\r\n> 이후 과정은 위와 같이 반복됩니다. 내부노드를 순회하며 자신의 자식노드가 있는지 확인하고 있다면, 자신과 비교하여 더큰 값으로 바꿉니다. 이는 바꾼이후에도 `3.`이 반복되게 됩니다. 순회되는 노드가 최상위노드가 되고 모든 내부노드가 힙이 될때, 전체 트리는 힙이 됩니다.   \r\n> 마지막까지 바꾼 최종트리는 아래와 같습니다.\r\n:{ \"type\": \"note\", \"icon\": \"info\" }\r\n\r\n![최대힙을 만들어 이런 형태로 노드를 나눌수 있어요.](/post/algorithm/heap/last_iteration.svg)\r\n\r\n* 최상위 노드(루트)가 가장 큰값이 되며, 위는 최대힙을 만드는 단계였습니다.\r\n* 부모노드와 자식노드끼리는 순서의 값을 가지며, 항상 최대의 값을 가집니다.  \r\n\r\n### Heap이 우선 값을 유지하는 방법\r\n\r\n위에서는 완전이진트리로 힙을 어떻게 만드는지에 대해 알아봤습니다.\r\n하지만, 힙은 언제나 새로운값이 들어와도 항상 우선 순위로 값을 관리합니다. 만약 저기서 더큰값이 추가된다면,\r\n저 힙트리는 어떻게 바뀔까요? 새로운 값들을 추가해서 힙이 다시 어떻게 유지되는지 배워봅니다.\r\n\r\n#### 값추가\r\n\r\n힙트리에서 값을 추가 할때는 마지막 노드로 붙여주고 위에서 했던것과 동일하게 힙을 만들어 줍니다.\r\n만약 새로운 값 17이 힙에 들어온다면 순서는 아래와 같이 바뀝니다.\r\n\r\n![만약 다음의 힙에서 17이라는 값이 추가 된다면](/post/algorithm/heap/add_new_17.svg)\r\n![이런식으로 부모노드와 바꿔가며, 다시 힙을 유지할 수 있어요.](/post/algorithm/heap/add_new_17_2.svg)\r\n\r\n\r\n> A: 새로 들어온 값 17은 트리의 맨뒤인 10번노드로 들어갑니다.     \r\n> 또한 마지막 내부노드이자 자신의 부모인 5번 노드(4)부터 다시 순회를 시작하며,  \r\n> 자신보다 큰 값은 가진 자식 10번 노드(17)과 값을 바꿉니다. \r\n> B: 값이 바뀐 10번 노드(4)는 자식을 가지고있지 않으므로 다음 순회로 넘어갑니다.  \r\n> C: 다음 순회인 4번 노드(6)은 자식들보다 큰값이므로 다음 3번 노드(12)로 이동합니다. 하지만 이또한 자식들보다 값이 크므로, 2번 노드(8)로 이동합니다. 자신보다 큰값을 가지는 5번 자식노드(17)과 바꿉니다.  \r\n> D: 값이 바뀐 5번 노드(8)은 자식들 보다 값이 커, 바꿀 필요가 없으므로 다음 순회인 1번 노드(15)로 이동합니다.  \r\n> E: 현재 순회인 1번 노드(15)는 자신의 2번 노드(17)보다 값이 작으므로 바꿉니다.  \r\n> F: 최종적으로 힙이 완성되었습니다.\r\n:{ \"type\": \"tip\", \"icon\": \"check-circle\" }\r\n\r\n\r\n### Heap을 이용해 정렬을 하는 방법\r\n\r\n힙 정렬을 위해서는 사전에 완전 이진 트리를 힙으로 만들고, 정렬을 수행할 수 있습니다.\r\n위에서 만든 힙을 통해 정렬을 하는 방법을 구현합니다.  \r\n힙 정렬은 간단하게, 아래의 정렬하는 순서를 가지고있습니다.\r\n\r\n1. 최상위 노드 `A`와 가장 끝의 노드 `B`를 바꾼다.\r\n2. 바꿔진 A는 맨뒤로 가며,힙에서 제외한다. \r\n3. 바꾼 값 `B`는, 자신의 자식이 있다면, 두개를 비교하여 가장 큰 값과 맞 바꾼다.\r\n4. `3.`의 내용을 힙이될때까지 반복한다.\r\n\r\n위의 순서를 반복하며, 만든 힙 정렬은 아래와 같습니다.\r\n\r\n![힙 정렬 1](/post/algorithm/heap/heap_sort_1_1.svg)\r\n![힙 정렬 2](/post/algorithm/heap/heap_sort_1_2.svg)\r\n![힙 정렬 3](/post/algorithm/heap/heap_sort_1_3.svg)\r\n![힙 정렬 4](/post/algorithm/heap/heap_sort_1_4.svg)\r\n![힙 정렬 5](/post/algorithm/heap/heap_sort_1_5.svg)\r\n![힙 정렬 6](/post/algorithm/heap/heap_sort_1_6.svg)\r\n![힙 정렬 7](/post/algorithm/heap/heap_sort_1_7.svg)\r\n![힙 정렬 8](/post/algorithm/heap/heap_sort_1_8.svg)\r\n\r\n## 구현 코드 (Java)\r\n\r\n```java\r\nimport java.util.Arrays;\r\n\r\npublic class Heap {\r\n    \r\n    //== 힙(Heap) 을 만드는 메소드 ==//\r\n    public static void makeHeap(int arr[]) {\r\n        // last heap\r\n        int lh = arr.length / 2;\r\n        System.out.println(\"Normal Array = \" + Arrays.toString(arr));\r\n        int eh = arr.length;\r\n        while (lh-- > 0) {\r\n\r\n            System.out.println(\"i: \" + lh);\r\n            pushDown(arr, lh, eh);\r\n        }\r\n\r\n        System.out.println(\"Array as Max Heap = \" + Arrays.toString(arr));\r\n    }\r\n    \r\n    \r\n    //== 노드와 그 자식중에서 더큰(또는 작은) 위치를 찾는 메소드 ==//\r\n    public static int findLargest(int arr[], int node, int eh) {\r\n        // first child\r\n        int fc = (2 * (node + 1)) - 1;\r\n\r\n        if (fc + 1 < eh) {\r\n            if (arr[fc] <= arr[fc + 1]) {\r\n                return arr[fc + 1] <= arr[node] ? node : fc + 1;\r\n            } else {\r\n                return arr[fc] <= arr[node] ? node : fc;\r\n            }\r\n        }\r\n        if (fc < eh && arr[node] < arr[fc]) {\r\n            return fc;\r\n        } else {\r\n            return node;\r\n        }\r\n    }\r\n    //== 값을 아래로 내리는 메소드 ==//\r\n\r\n    /**\r\n     * 간단하게 보면 트리에서 마지막 힙의 위치를 구하고,\r\n     * 루트 노드까지 역순으로 힙을 만들어갑니다.\r\n     * \r\n     * 최대 힙(또는 최소 힙)의 조건에 따라 더큰(또는 더 작은)값을 기준으로,\r\n     * 해당 노드를 위로올리고 변경된 대상은 아래로 내려가며 계속 바꿉니다.\r\n     */\r\n    public static void pushDown(int arr[], int node, int eh) {\r\n        do {\r\n            System.out.println(\"j: \" + node);\r\n            int temp = arr[node];\r\n            int large = findLargest(arr, node, eh);\r\n            System.out.println(drawBinaryTree(arr));\r\n\r\n            if (large == node)\r\n                break;\r\n\r\n            arr[node] = arr[large];\r\n            arr[large] = temp;\r\n\r\n            node = large;\r\n        } while (node <= eh);\r\n    }\r\n\r\n    public static void sort(int arr[]) {\r\n        int last = arr.length;\r\n        makeHeap(arr);\r\n\r\n        while (--last >= 0) {\r\n\r\n            int temp = arr[0];\r\n            arr[0] = arr[last];\r\n            arr[last] = temp;\r\n\r\n            System.out.println(\"last: \" + last);\r\n            pushDown(arr, 0, last);\r\n        }\r\n        ;\r\n    }\r\n\r\n    //== 출력 메소드 ==//\r\n    public static String drawBinaryTree(int arr[]) {\r\n        StringBuilder builder = new StringBuilder();\r\n\r\n        int nol = (int) (Math.log(arr.length) / Math.log(2)) + 1;\r\n        int max = (int) Math.pow(2, nol - 1);\r\n\r\n        int printed = 0;\r\n        for (int i = 0; i < nol; i++) {\r\n            int perFloor = (int) Math.pow(2, i);\r\n            int tab = (max - perFloor) / 2 + (max - perFloor) % 2;\r\n            int last = printed + perFloor;\r\n\r\n            for (int j = 0; j < tab; j++) {\r\n                builder.append(\"  \");\r\n            }\r\n            for (int j = printed; (j < arr.length && j < last); j++) {\r\n                builder.append(String.format(\"(%d)\", arr[j]));\r\n            }\r\n            builder.append(\"\\n\");\r\n            printed += perFloor;\r\n        }\r\n\r\n        return builder.toString();\r\n    }\r\n    \r\n    public static void main(String args []) throws Exception {\r\n        //== 힙 으로 만들기==//\r\n        int arrForMake [] = {1, 5, 8, 2, 74, 9, 12, 104, 87, 43};\r\n        Heap.makeHeap();\r\n        \r\n        //== 힙 + 정렬 ==//\r\n        int arrForSort [] = {1, 8, 9, 15, 4, 7, 12, 6, 4, 17};\r\n        Heap.sort(arr);\r\n        \r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n"
  },
  {
    "path": "/wiki/io-manager",
    "header": {
      "layout": "wiki",
      "title": "입출력 관리자",
      "categories": [
        "computer",
        "hardware"
      ],
      "tags": [
        "I/O Manager",
        "I/O"
      ],
      "date": 1611035580000,
      "current-company": "Cubic INC",
      "current-position": "SI Researcher",
      "summary": "I/O Manager",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "computer",
        "hardware"
      ],
      "images": [],
      "headlines": {
        "grade": 0,
        "title": "root",
        "fragmentId": "root",
        "children": [
          {
            "grade": 2,
            "title": "I/O Manager란?",
            "fragmentId": "i%2Fo-manager%EB%9E%80%3F",
            "children": [],
            "isSelected": false
          },
          {
            "grade": 2,
            "title": "PCI express",
            "fragmentId": "pci-express",
            "children": [],
            "isSelected": false
          },
          {
            "grade": 2,
            "title": "Bridge (North Bridge, South Bridge)",
            "fragmentId": "bridge-(north-bridge%2C-south-bridge)",
            "children": [],
            "isSelected": false
          },
          {
            "grade": 2,
            "title": "I/O Manager의 역할",
            "fragmentId": "i%2Fo-manager%EC%9D%98-%EC%97%AD%ED%95%A0",
            "children": [],
            "isSelected": false
          }
        ],
        "isSelected": false
      }
    },
    "description": "",
    "content": "\r\n## I/O Manager란?\r\n\r\n## PCI express\r\n\r\n## Bridge (North Bridge, South Bridge)\r\n\r\n## I/O Manager의 역할\r\n"
  },
  {
    "path": "/wiki/interrupt",
    "header": {
      "layout": "wiki",
      "title": "CPU와 인터럽트",
      "categories": [
        "computer",
        "hardware"
      ],
      "tags": [
        "Operating System",
        "Interrupt"
      ],
      "date": 1610544780000,
      "current-company": "Cubic INC",
      "current-position": "SI Researcher",
      "summary": "인터럽트란?",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "computer"
      ],
      "images": [
        {
          "src": "/post/computer/move-unit.png",
          "alt": "캐릭터의 이동"
        }
      ],
      "headlines": {
        "grade": 0,
        "title": "root",
        "fragmentId": "root",
        "children": [
          {
            "grade": 2,
            "title": "인터럽트는 무엇인가?",
            "fragmentId": "%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%3F",
            "children": [],
            "isSelected": false
          },
          {
            "grade": 2,
            "title": "인터럽트 서비스 루틴",
            "fragmentId": "%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%A3%A8%ED%8B%B4",
            "children": [],
            "isSelected": false
          },
          {
            "grade": 2,
            "title": "인터럽트의 매커니즘",
            "fragmentId": "%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%9D%98-%EB%A7%A4%EC%BB%A4%EB%8B%88%EC%A6%98",
            "children": [],
            "isSelected": false
          }
        ],
        "isSelected": false
      }
    },
    "description": "",
    "content": "\r\n## 인터럽트는 무엇인가?\r\n\r\ninterrupt `[ˌɪntəˈrʌpt]`\r\n1. (말·행동을) 방해하다[중단시키다/가로막다]\r\n2. (무엇을 잠깐) 중단시키다\r\n\r\n사전 상의 `interrupt`(이하 인터럽트)는 위와 같은 어떤 행동이나 흐름을 중단시키는 의미로 등재 되어있다.\r\n컴퓨터에서도 인터럽트는 어떤 흐름을 중지하는 역할을 한다.\r\n\r\n[CPU]()는 순차적으로 명령어를 처리한다. 하지만 예상치못하거나 긴급한상황에 의도적으로 특별한 처리를 해야한다.\r\n예를 들어 스타크래프트나 리그오브레전드처럼 3인칭시점에서 마우스로 지면을 클릭하는 경우, 해당위치로 캐릭터가 이동한다.\r\n이 경우 이동이 끝나지 않아도, 우리는 새로운 위치를 클릭하여 방향을 바꿀수도있다. \r\n\r\n![캐릭터의 이동](/post/computer/move-unit.png)\r\n:{ \"wrapper-class\": \"justify-center\", \"max-width\": \"300px\", \"description\": \"눈꽃시비르의 방향을 조작하는 프로겐 선수\" }\r\n\r\n이 처럼 CPU가 명령을 실행하는중에도 긴급하거나, 실시간 처리가 필요한경우 IRQ를 통해, CPU에 인터럽트 신호를 보내 우선적으로 처리를 수행할 수 있다.\r\n\r\n> **I**nterrupt **R**e**Q**uest Line는 인터럽트 요청을 받을수있는 인터럽트 버스이다 이는 하드웨어에서 각 장치까지 물리적으로 연결된 신호선이다.\r\n:{ \"type\": \"note\", \"icon\": \"info\"}\r\n\r\n## 인터럽트 서비스 루틴\r\n\r\n**I**nterrupt **S**ervice **R**outine (이하 ISR)은 다른말로 Interrupt Handler(인터럽트 핸들러)라고도 한다.\r\n`ISR`은 인터럽트를 처리하기위한 어떤 일련의 프로세스이다. `IRQ`를 통해 `CPU`로 인터럽트 신호를 보내면(CPU의 인터럽트), CPU는 하던 일을 중단하고 ISR이 있는 주소로 실행을 옮긴다.\r\n그리고 `ISR`이 실행된후 다시 원래 연산을 재개한다. ISR은 인터럽트 번호 테이블로 구성되어있다. 이는 시스템마다 다를수 있고 콜백루틴 방식으로 처리된다.\r\n\r\n인터럽트 원인에 따라 처리되는 ISR이 별도로 있으며,이는 [커널(kernel)]()에 존재한다. \r\n인터럽트가 발생되는 원인은 일반적으로 `하드웨어 리셋`, `정해진 메모리 외부 참조`, `0으로 나누기` 등 여러 예외가 존재한다.\r\n\r\n인터럽트가 발생(*raise*)하면 `ISR`의 주소를 Interrupt Vector(이하 인터럽트 벡터)라고 하는 배열을 인터럽트 요청과 함께 장치 고유번호로 인덱싱한다.\r\n또한 `CPU`는 인터럽트를 포착(*catch*)하면 현재 실행 중이던 작업을 중단하고 `ISR`로 전송(*dispatch*)하면 루틴을 실행해야하기 때문에 실행중인 작업의 레지스터 값들을 스택에 저장하여 상태를 보존한다.\r\n이러한 값들에는 [프로그램 카운터(이하 PC)](), [스택 포인터]() 등 범용 레지스터 들이 포함된다. \r\n\r\n| 벡터 번호  | 설명                 |\r\n|--------|--------------------|\r\n| 0      | 나눗셈 에러             |\r\n| 1      | 디버그 예외             |\r\n| 2      | Null 인터럽터          |\r\n| ...    |\r\n| 18     | 기기 검사              |\r\n| 19~31  | (Intel에서 예약, 사용금지) |\r\n| 32~255 | Maskale 인터럽트       |\r\n:{ \"description\": \"표 1: Intel Processor 이벤트-벡터\", \"wrapper-class\": \"items-center\" }\r\n\r\n`ISR`이 실행되는 동안에는 프로세서의 레지스터 값을 변경할수 있기때문에, `ISR`이 끝나기전에 인터럽트를 지우고(*clear*) 스택에 저장해 두었던 레지스터 값들을 다시 복원 하여 CPU가 인터럽트 발생 전 상태로 되돌아 갈수 있게 레지스터 값을 원복한다.\r\n`ISR`실행 후 인터럽트 요청에서 받았았던 복귀 주소를 `PC`로 적재하여 인터럽트 발생시점부터 실행을 옮겨 중단되었던 연산을 다시 시작한다.\r\n\r\n실제로는 인터럽트 벡터의 주소 개수보다 많은 장치가 있기 때문에, `인터럽트 체인` 방식을 사용한다.   \r\n이는 벡터의 각 요소를 핸들럭 목록을 체인으로 묶어, 처리할수 있는 핸들러를 찾을 떄까지 하나씩 호출하는 방법이다.\r\n\r\n위에서 `표1`에서 0~31까지는 각 루틴에 대한 마스킹이 이미 되어있기때문에 `Non Maskable Interrupt`라고 하며 예약된 루틴이고, 32부터는 Maskable 이므로 그외 인터럽트를 처리하기 위해 사용된다.\r\n\r\n> 인터럽트 우선순위 레벨 (Interrupt Priority Level *이하 `IPL`)  \r\n> `IPL`은 인터럽트 별로 우선 순위를 정하여, 인터럽트 처리에도 우선순위를 둘 수 있다.  \r\n> `IPL`은 순위에 따라 처리를 연기하거나, 순위가 더높은 인터럽트가 실행을 선점 할 수 도있다.  \r\n: { \"type\": \"note\", \"icon\": \"info\" }\r\n\r\n\r\n## 인터럽트의 매커니즘\r\n\r\n인터럽트는 CPU연산 중 신호를 받아 `ISR`을 실행한다고 하였다. 하지만 컴퓨터는 동기순차회로이기 때문에 순차적으로 연산이 이루어져야 한다.\r\n때문에, CPU가 하나의 명령어 실행이 완료될 때마다 IRQ를 감지하여 인터럽트 번호를 읽어 이 번호를 인터럽트 벡터의 인덱스로 사용하고, `ISR`로 점프하여 인덱스와 관련된 주소에서 실행을 시작한다.\r\n인터럽트 처리후 복원까지 수행하면 `return_from_interrupt` 명령어로 CPU를 인터럽트 전 실행상태로 되돌린다.\r\n\r\n> 폴링 (Polling)  \r\n> CPU가 주기적으로 장치의 상태를 직접확인하고, 상태에따라 처리하는 방식이다.  \r\n> 이는 장치컨트롤러와 연관이이 있는데, CPU와 병렬로 실행되는 장치컨트롤러는 내부의 로컬버퍼와 장치간 데이터의 전송을 담당한다.  \r\n> 장치에서 입력이있다면, 로컬버퍼로 데이터를 이동시키고 상태 레지스터의 값을 변경한다. 여기서 CPU는 장치컨트롤러의 상태 레지스터를 주기적으로 확인하여, 상태가 변경되었는지 확인하며 로컬버퍼의 데이터를 읽어와 처리한다.  \r\n> 이러한 방식은 CPU가 주기적으로 장치의 상태를 확인하기 때문에, CPU의 부하가 높아지고, 실시간 처리에 적합하지 않다. 이때 전송하는 빈도를 폴링 레이트라고한다.  폴링레이트가 높을때 입력이 많은경우 CPU의 부하가 높아지는 이유가 이것 때문이다.  \r\n:{ \"icon\": \"warning-diamond\", \"type\": \"warning\" }\r\n\r\n"
  },
  {
    "path": "/docs/language/java/install-zulu-in-mac",
    "header": {
      "layout": "post",
      "title": "Azul System의 OpenJDK Zulu 설치하기",
      "categories": [
        "language"
      ],
      "tags": [
        "OpenJDK",
        "Azul System",
        "Zulu"
      ],
      "date": 1606890300000,
      "thumbnail": "/post/java/azul-java.webp",
      "current-company": "Cubic INC",
      "current-position": "SI Researcher",
      "summary": "OpenJDK Zulu 설치",
      "excerpt-separator": "<!--more-->",
      "hide": false,
      "breadcrumbs": [
        "문서",
        "언어",
        "자바"
      ],
      "images": [],
      "headlines": {
        "grade": 0,
        "title": "root",
        "fragmentId": "root",
        "children": [
          {
            "grade": 2,
            "title": "macOS에서 Open JDK 설치",
            "fragmentId": "macos%EC%97%90%EC%84%9C-open-jdk-%EC%84%A4%EC%B9%98",
            "children": [
              {
                "grade": 3,
                "title": "DMG Installer를 이용한 설치",
                "fragmentId": "dmg-installer%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%84%A4%EC%B9%98",
                "children": [],
                "isSelected": false
              },
              {
                "grade": 3,
                "title": "ZIP 또는 TAR.GZ로 설치",
                "fragmentId": "zip-%EB%98%90%EB%8A%94-tar.gz%EB%A1%9C-%EC%84%A4%EC%B9%98",
                "children": [],
                "isSelected": false
              }
            ],
            "isSelected": false
          }
        ],
        "isSelected": false
      }
    },
    "description": "\r\nZulu는 Azul System에서 제공하는 OpenJDK의 빌드이다.\r\nmacOS에서 설치하는 방법을 요약했다.\r\n\r\n",
    "content": "\r\n\r\n## macOS에서 Open JDK 설치\r\n\r\nMacOS는 일반적으로 `/Library/Java/JavaVirtualMachines` 하위 경로에 jdk를 저장하고 사용한다.\r\n\r\n\r\n### DMG Installer를 이용한 설치\r\n\r\n1. [Azul 다운로드](https://www.azul.com/downloads/?os=macos&_gl=1*dkdl9*_ga*MTQ0NjY0MDg1OS4xNjg4NjM4NTAz*_ga_42DEGWGYD5*MTcwNjc5MTg0NC40LjEuMTcwNjc5MjMwNy4yOC4wLjA.#zulu)에서 Azul Zulu를 위한 DMG Installer 다운로드\r\n2. 설치를 시작하기위해 파일 더블클릭하고, 설치 마법사 명령을 따르기\r\n\r\n기본 설치폴더는 다음과같다.\r\n\r\n```\r\n/Library/Java/JavaVirtualMachines/<zulu_folder>/Contents/Home\r\n```\r\n\r\n`<zulu_folder>` 플레이스 홀더는 그 버전과 Azul Zulu 패키지(JDK or JRE)의 타입을 말한다. \r\n\r\n| 패키지 |      Azul Zulu 폴더명      |     예시      |\r\n| :----: | :------------------------: | :-----------: |\r\n|  JDK   | `zulu-<major_version>.jdk` | `zulu-11.jdk` |\r\n|  JRE   | `zulu-<major_version>.jdk` | `zulu-11.jre` |\r\n:{ \"wrapper-class\": \"items-center\" }\r\n\r\n예를 들어, Azul Zulu JDK11을 위한 기본설치 폴더인경우:\r\n\r\n```\r\n/Library/Java/JavaVirtualMachines/zulu-11.jdk/Contents/Home\r\n```\r\n\r\n3. Azul zulu 설치를 확인하기위해 터미널 창에서 `java` 명령어를 실행한다.\r\n\r\n```bash\r\n$ java -version\r\n```\r\n\r\n다음과 같이 출력돼야 한다.  \r\n\r\n```\r\nopenjdk version \"11.0.11\" 2021-04-20 LTS\r\nOpenJDK Runtime Environment Zulu11.48+21-CA (build 11.0.11+9-LTS)\r\nOpenJDK 64-Bit Server VM Zulu11.48+21-CA (build 11.0.11+9-LTS, mixed mode)\r\n```\r\n\r\n### ZIP 또는 TAR.GZ로 설치\r\n\r\n1. [Azul 다운로드](https://www.azul.com/downloads/?os=macos)에서 TAR.GZ 또는 ZIP으로 Azul Zulu 다운로드\r\n\r\n2. **Finder** 실행 후 다운로드 폴더로 이동. 압축을 해제하기위해 더블클릭 한다. **사파리**에서 받았다면 자동으로 압축해제 된다.\r\n\r\n하지만, 압축해제하기 위해 아래처럼 한번의 명령어를 사용할 수도 있다.\r\n\r\nZIP 인 경우\r\n\r\n```bash\r\nunzip <zulu_package>.zip\r\n```\r\n\r\n   TAR.GZ 인 경우\r\n\r\n```\r\ntar -zxvf <zulu_package>.tar.gz\r\n```\r\n\r\n압축 해제한 폴더가 Zulu Azul 설치 폴더 이다.\r\n\r\n3. Azul Zulu 설치를 확인하기 위해, 터미널 창에서 다음의 커맨드를 실행한다.\r\n\r\n```bash\r\n$ <installation_folder>/bin/java -version\r\n```\r\n\r\n4. (선택사항) `<installation_folder>/bin/java` 을 `PATH` 환경변수에 추가하면, 특정한 전체 경로 없이 어디서는 `java` 를 실행할 수 있다.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
  }
]